diff --git a/data/locale/deutsch.locale b/data/locale/deutsch.locale
index dc8072f..f71795f 100644
--- a/data/locale/deutsch.locale
+++ b/data/locale/deutsch.locale
@@ -276,6 +276,12 @@ clock_size_height Höhe der Anzeige
 clock_switch_off Uhr ausblenden
 clock_switch_on Uhr einblenden
 color.gradient Farbverlauf
+color.gradient_a2b Farbe A zu B
+color.gradient_b2a Farbe B zu A
+color.gradient_d2l dunkel nach hell
+color.gradient_dld dunkel hell dunkel
+color.gradient_l2d hell nach dunkel
+color.gradient_ldl hell dunkel hell
 colorchooser.alpha alpha
 colorchooser.blue blau
 colorchooser.green grün
diff --git a/data/locale/english.locale b/data/locale/english.locale
index 738b388..2e8e8f0 100644
--- a/data/locale/english.locale
+++ b/data/locale/english.locale
@@ -276,7 +276,12 @@ clock_size_height Display height
 clock_switch_off Clock off
 clock_switch_on Clock on
 color.gradient Color gradient
-color.gradient_c2c Color to color gradient
+color.gradient_a2b color A to B
+color.gradient_b2a color B to A
+color.gradient_d2l dark nach light
+color.gradient_dld dark light dark
+color.gradient_l2d light to dark
+color.gradient_ldl light dark light
 colorchooser.alpha alpha
 colorchooser.blue blue
 colorchooser.green green
diff --git a/data/locale/nederlands.locale b/data/locale/nederlands.locale
index 0a5bf6e..f0ba5b8 100644
--- a/data/locale/nederlands.locale
+++ b/data/locale/nederlands.locale
@@ -270,6 +270,12 @@ clock_size_height Display hoogte
 clock_switch_off klok uit
 clock_switch_on klok aan
 color.gradient Kleur gradient
+color.gradient_a2b color A to B
+color.gradient_a2b color B to A
+color.gradient_d2l donker tot licht
+color.gradient_dld donker licht donker
+color.gradient_l2d licht tot donker
+color.gradient_ldl licht donker licht
 colorchooser.alpha Alpha
 colorchooser.blue Blauw
 colorchooser.green Groen
diff --git a/data/locale/slovak.locale b/data/locale/slovak.locale
index 04a5f69..4fc1428 100644
--- a/data/locale/slovak.locale
+++ b/data/locale/slovak.locale
@@ -276,6 +276,12 @@ clock_size_height Výška zobrazenia
 clock_switch_off Skryť hodiny
 clock_switch_on Zobraziť hodiny
 color.gradient Farebný gradient
+color.gradient_a2b color A to B
+color.gradient_b2a color B to A
+color.gradient_d2l dark nach light
+color.gradient_dld dark light dark
+color.gradient_l2d light to dark
+color.gradient_ldl light dark light
 colorchooser.alpha Priehľadnosť
 colorchooser.blue Modrý
 colorchooser.green Zelený
diff --git a/src/driver/colorgradient.cpp b/src/driver/colorgradient.cpp
index 50dacdd..e9ed0e9 100644
--- a/src/driver/colorgradient.cpp
+++ b/src/driver/colorgradient.cpp
@@ -185,11 +185,15 @@ fb_pixel_t* CColorGradient::gradientColorToColor(fb_pixel_t start_col,fb_pixel_t
 	int start_box = 0;
 	int end_box = bSize;
 
-	if (mode == gradientDark2Light) {
-		fb_pixel_t temp_col = start_col;
+	fb_pixel_t temp_col = end_col;
+	end_col =  start_col;
+	start_col = temp_col;
+
+	if (mode == gradientDark2Light){
+		temp_col = start_col;
 		start_col = end_col;
 		end_col = temp_col;
-		}
+	}
 
 	uint8_t start_tr = (uint8_t)((start_col & 0xFF000000) >> 24);
 	uint8_t start_r  = (uint8_t)((start_col & 0x00FF0000) >> 16);
diff --git a/src/driver/framebuffer.cpp b/src/driver/framebuffer.cpp
index dc58fcc..d1aae6a 100644
--- a/src/driver/framebuffer.cpp
+++ b/src/driver/framebuffer.cpp
@@ -2095,7 +2095,7 @@ bool CFrameBuffer::_checkFbArea(int _x, int _y, int _dx, int _dy, bool prev)
 //					waitForIdle();
 					fb_no_check = true;
 					if (prev)
-						CAudioMute::getInstance()->hide(true);
+						CAudioMute::getInstance()->hide();
 					else
 						CAudioMute::getInstance()->paint();
 					fb_no_check = false;
diff --git a/src/gui/audiomute.cpp b/src/gui/audiomute.cpp
index a89fd81..e9b3239 100644
--- a/src/gui/audiomute.cpp
+++ b/src/gui/audiomute.cpp
@@ -71,7 +71,7 @@ void CAudioMute::AudioMute(int newValue, bool isEvent)
 			if (do_paint_mute_icon)
 			{
 				frameBuffer->fbNoCheck(true);
-				this->hide(true);
+				this->hide();
 				frameBuffer->fbNoCheck(false);
 			}
 			frameBuffer->setFbArea(CFrameBuffer::FB_PAINTAREA_MUTEICON1);
@@ -88,7 +88,7 @@ void CAudioMute::AudioMute(int newValue, bool isEvent)
 		}
 		else {
 			if (do_paint_mute_icon)
-				this->hide(true);
+				this->hide();
 			frameBuffer->setFbArea(CFrameBuffer::FB_PAINTAREA_MUTEICON1);
 		}
 		frameBuffer->fbNoCheck(false);
@@ -108,7 +108,7 @@ void CAudioMute::enableMuteIcon(bool enable)
 	}
 	else {
 		if (neutrino->isMuted())
-			this->hide(true);
+			this->hide();
 		frameBuffer->doPaintMuteIcon(false);
 		do_paint_mute_icon = false;
 	}
diff --git a/src/gui/bedit/bouqueteditor_channels.cpp b/src/gui/bedit/bouqueteditor_channels.cpp
index 8126de0..f98e2a2 100644
--- a/src/gui/bedit/bouqueteditor_channels.cpp
+++ b/src/gui/bedit/bouqueteditor_channels.cpp
@@ -252,11 +252,18 @@ void CBEChannelWidget::initItem2DetailsLine (int pos, int /*ch_index*/)
 		//infobox
 		if (ibox == NULL){
 			ibox = new CComponentsInfoBox();
-			ibox->setDimensionsAll(x, ypos2, width, info_height);
-			ibox->setFrameThickness(2);
-			ibox->setCorner(RADIUS_LARGE);
-			ibox->setShadowOnOff(CC_SHADOW_OFF);
 		}
+
+		if (ibox->isPainted())
+			ibox->hide();
+		
+		ibox->setDimensionsAll(x, ypos2, width, info_height);
+		ibox->setFrameThickness(2);
+#if 0			
+		ibox->paint(false,true);
+#endif
+		ibox->setCorner(RADIUS_LARGE);
+		ibox->setShadowOnOff(CC_SHADOW_OFF);
 	}
 }
 
diff --git a/src/gui/channellist.cpp b/src/gui/channellist.cpp
index 13d06dd..fc1bc46 100644
--- a/src/gui/channellist.cpp
+++ b/src/gui/channellist.cpp
@@ -61,7 +61,7 @@
 #include <gui/widget/messagebox.h>
 #include <gui/widget/hintbox.h>
 #include <gui/movieplayer.h>
-
+#include <gui/infoclock.h>
 #include <system/settings.h>
 #include <gui/customcolor.h>
 
@@ -88,9 +88,9 @@ extern CBouquetList   * RADIOfavList;
 extern bool autoshift;
 
 extern CBouquetManager *g_bouquetManager;
-
-static CComponentsFrmClock *headerClock = NULL;
-static int headerClockWidth = 0;
+extern int old_b_id;
+static CComponentsChannelLogoScalable* CChannelLogo = NULL;
+static CComponentsHeader *header = NULL;
 extern bool timeset;
 
 CChannelList::CChannelList(const char * const pName, bool phistoryMode, bool _vlist)
@@ -138,12 +138,6 @@ CChannelList::~CChannelList()
 		delete 	cc_minitv;
 		cc_minitv = NULL;
 	}
-	if (headerClock) {
-		headerClock->clearSavedScreen();
-		delete headerClock;
-		headerClock = NULL;
-	}
-
 	if (CChannelLogo) {
 		delete CChannelLogo;
 		CChannelLogo = NULL;
@@ -312,6 +306,14 @@ int CChannelList::doChannelMenu(void)
 	CMenuWidget* menu = new CMenuWidget(LOCALE_CHANNELLIST_EDIT, NEUTRINO_ICON_SETTINGS);
 	menu->enableFade(false);
 	menu->enableSaveScreen(true);
+
+	if (g_settings.menu_pos == CMenuWidget::MENU_POS_TOP_RIGHT){
+		//using native callback to ensure stop header clock before paint this menu window
+		menu->OnBeforePaint.connect(sigc::mem_fun(header->getClockObject(), &CComponentsFrmClock::block));
+		//... and start header clock after hide menu window
+		menu->OnAfterHide.connect(sigc::mem_fun(header->getClockObject(), &CComponentsFrmClock::unblock));
+	}
+
 	CMenuSelectorTarget * selector = new CMenuSelectorTarget(&select);
 
 	bool empty = (*chanlist).empty();
@@ -420,7 +422,7 @@ int CChannelList::doChannelMenu(void)
 			{
 				previous_channellist_additional = g_settings.channellist_additional;
 				COsdSetup osd_setup;
-				osd_setup.showContextChanlistMenu();
+				osd_setup.showContextChanlistMenu(this);
 				//FIXME check font/options changed ?
 				hide();
 				calcSize();
@@ -941,8 +943,6 @@ int CChannelList::show()
 		printf("CChannelList:: bouquetList->exec res %d\n", res);
 	}
 
-	if (headerClock)
-		headerClock->Stop();
 
 	if(NeutrinoMessages::mode_ts == CNeutrinoApp::getInstance()->getMode())
 		return -1;
@@ -962,10 +962,11 @@ void CChannelList::hide()
 			delete cc_minitv;
 		cc_minitv = NULL;
 	}
-	if (headerClock) {
-		if (headerClock->Stop())
-			headerClock->hide();
-	}
+
+	header->kill();
+	if (CChannelLogo)
+		CChannelLogo->kill();
+
 	frameBuffer->paintBackgroundBoxRel(x, y, full_width, height + info_height);
 	clearItem2DetailsLine();
 }
@@ -2064,51 +2065,55 @@ void CChannelList::paint()
 
 void CChannelList::paintHead()
 {
-	static int gradient_head = g_settings.theme.menu_Head_gradient;
-	static int gradient_c2c  = g_settings.theme.gradient_c2c;
+	if (header == NULL)
+		header = new CComponentsHeader();
+
+	header->setDimensionsAll(x, y, full_width, theight);
 
-	CComponentsHeader header(x, y, full_width, theight, name /*no header icon*/);
 	if (bouquet && bouquet->zapitBouquet && bouquet->zapitBouquet->bLocked != g_settings.parentallock_defaultlocked)
-		header.setIcon(NEUTRINO_ICON_LOCK);
-	if (edit_state)
-		header.setCaption(std::string(g_Locale->getText(LOCALE_CHANNELLIST_EDIT)) + ": " + name);
+		header->setIcon(NEUTRINO_ICON_LOCK);
+
+	string header_txt 		= !edit_state ? name : string(g_Locale->getText(LOCALE_CHANNELLIST_EDIT)) + ": " + name;
+	fb_pixel_t header_txt_col 	= (edit_state ? COL_RED : COL_MENUHEAD_TEXT);
+	header->setColorBody(COL_MENUHEAD_PLUS_0); 
 
-	header.paint(CC_SAVE_SCREEN_NO);
+	header->setCaption(header_txt, CTextBox::NO_AUTO_LINEBREAK, header_txt_col);
 
-	if ((gradient_head != g_settings.theme.menu_Head_gradient || gradient_c2c != g_settings.theme.gradient_c2c) && headerClock != NULL) {
+	int gradient_head = header->getColBodyGradientMode();
+
+	if (gradient_head != g_settings.theme.menu_Head_gradient) {
 		gradient_head = g_settings.theme.menu_Head_gradient;
-		gradient_c2c  = g_settings.theme.gradient_c2c;
-		headerClock->clearSavedScreen();
-		delete headerClock;
-		headerClock = NULL;
+		header->enableColBodyGradient(gradient_head, COL_MENUCONTENT_PLUS_0);
+		header->getClockObject()->clearSavedScreen();
+		if (CChannelLogo)
+			CChannelLogo->clearFbData();
 	}
 
 	if (timeset) {
-		if (headerClock == NULL) {
-			headerClock = new CComponentsFrmClock(0, 0, 0, 0, "%H:%M", true);
-			headerClock->setClockBlink("%H %M");
-			headerClock->setClockIntervall(1);
-			headerClock->doPaintBg(!gradient_head);
-			headerClock->enableTboxSaveScreen(gradient_head);
-			headerClock->setCorner(RADIUS_LARGE, CORNER_TOP_RIGHT);
-		}
-		headerClock->setClockFont(SNeutrinoSettings::FONT_TYPE_MENU_TITLE);
-		headerClock->setYPos(y);
-		headerClock->setHeight(theight);
-		headerClock->setTextColor(header.getTextObject()->getTextColor());
-		headerClock->setColorBody(header.getColorBody());
-		headerClock->refresh();
-		headerClockWidth = headerClock->getWidth();
-		headerClock->setXPos(x + full_width - headerClockWidth - 10);
-		headerClockWidth += 6;
-
-		headerClock->Start();
+		if(!edit_state){
+			if (header->getContextBtnObject())
+				if (!header->getContextBtnObject()->empty())
+					header->removeContextButtons();
+			header->enableClock(true, "%H:%M", "%H %M", true);
+			logo_off = header->getClockObject()->getWidth() + 10;
+// 			header->getClockObject()->enableSegmentSaveScreen(gradient_head);
+			header->getClockObject()->setCorner(RADIUS_LARGE, CORNER_TOP_RIGHT);
+		}else{
+			if (header->getClockObject()){
+				header->disableClock();
+				header->setContextButton(CComponentsHeader::CC_BTN_EXIT);
+			}
+		}
 	}
 	else
-		headerClockWidth = 0;
+		logo_off = 10;
 
-	logo_off = headerClockWidth + 10;
-	headerNew = true;
+	header->paint(CC_SAVE_SCREEN_NO);
+}
+
+CComponentsHeader* CChannelList::getHeaderObject()
+{
+	return header;
 }
 
 void CChannelList::paintBody()
diff --git a/src/gui/channellist.h b/src/gui/channellist.h
index 33a0339..ccc2e9d 100644
--- a/src/gui/channellist.h
+++ b/src/gui/channellist.h
@@ -127,7 +127,7 @@ private:
 
 	int ChannelList_Rec;
 
-	CComponentsChannelLogoScalable* CChannelLogo;
+
 	bool headerNew;
 
 	void paintDetails(int index);
@@ -242,5 +242,6 @@ public:
 	};
 	unsigned Size() { return (*chanlist).size(); }
 	ZapitChannelList &getChannels() { return channels; };
+	CComponentsHeader* getHeaderObject();
 };
 #endif
diff --git a/src/gui/components/Makefile.am b/src/gui/components/Makefile.am
index 7f0a506..30c1604 100644
--- a/src/gui/components/Makefile.am
+++ b/src/gui/components/Makefile.am
@@ -27,6 +27,7 @@ noinst_LIBRARIES = libneutrino_gui_components.a
 libneutrino_gui_components_a_SOURCES = \
 	cc_base.cpp \
 	cc_detailsline.cpp \
+	cc_draw.cpp \
 	cc_frm_button.cpp \
 	cc_frm.cpp \
 	cc_frm_chain.cpp \
diff --git a/src/gui/components/cc.h b/src/gui/components/cc.h
index d7f0865..6bf62a9 100644
--- a/src/gui/components/cc.h
+++ b/src/gui/components/cc.h
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2013, Thilo Graf 'dbt'
+	Copyright (C) 2013-2015, Thilo Graf 'dbt'
 
 	License: GPL
 
@@ -17,10 +17,8 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 /// Basic CComponent class header.
@@ -43,7 +41,6 @@ Basic attributes and member functions for component sub classes
 #include "cc_detailsline.h"
 
 #include "cc_frm_scrollbar.h"
-#include "cc_frm.h"
 #include "cc_frm_chain.h"
 #include "cc_frm_button.h"
 #include "cc_frm_clock.h"
diff --git a/src/gui/components/cc_base.cpp b/src/gui/components/cc_base.cpp
index c5080b8..1820de4 100644
--- a/src/gui/components/cc_base.cpp
+++ b/src/gui/components/cc_base.cpp
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2014, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
 	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -18,10 +18,8 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifdef HAVE_CONFIG_H
@@ -31,304 +29,11 @@
 #include <global.h>
 #include <neutrino.h>
 #include "cc_base.h"
-#include <cs_api.h>
-#include <system/debug.h>
+
 using namespace std;
 
 //abstract basic class CComponents
-CComponents::CComponents() : COSDFader(g_settings.theme.menu_Content_alpha)
+CComponents::CComponents()
 {
-	x = saved_screen.x 	= 0;
-	y = saved_screen.y 	= 0;
-	cc_xr 			= x;
-	cc_yr 			= y;
-	height 			= saved_screen.dy = CC_HEIGHT_MIN;
-	width 			= saved_screen.dx = CC_WIDTH_MIN;
-
-	col_body 		= COL_MENUCONTENT_PLUS_0;
-	col_shadow 		= COL_MENUCONTENTDARK_PLUS_0;
-	col_frame 		= COL_MENUCONTENT_PLUS_6;
-	col_frame_sel 		= COL_MENUCONTENTSELECTED_PLUS_0;
-	corner_type 		= CORNER_ALL;
-	corner_rad		= 0;
 	cc_tag			= NULL;
-	shadow			= CC_SHADOW_OFF;
-	shadow_w		= SHADOW_OFFSET;
-	fr_thickness		= 0;
-	fr_thickness_sel	= 3;
-
-	firstPaint		= true;
-	is_painted		= false;
-	paint_bg		= true;
-	save_tbox_screen	= false;
-	cc_allow_paint		= true;
-	frameBuffer 		= CFrameBuffer::getInstance();
-	v_fbdata.clear();
-	saved_screen.pixbuf 	= NULL;
-	col_body_gradient	= false;
-	cc_body_gradient_c2c	= true;
-	cc_body_gradient_2nd_col= COL_MENUCONTENT_PLUS_0;
-	cc_gradientData.gradientBuf = NULL;
-	cc_gradientData.boxBuf = NULL;
-}
-
-CComponents::~CComponents()
-{
-	hide();
-	clearSavedScreen();
-	clearFbData();
-	if (cc_gradientData.gradientBuf)
-		free(cc_gradientData.gradientBuf);
-	if (cc_gradientData.boxBuf)
-		cs_free_uncached(cc_gradientData.boxBuf);
-}
-
-void CComponents::clearSavedScreen()
-{
-	if (saved_screen.pixbuf)
-		delete[] saved_screen.pixbuf;
-	saved_screen.pixbuf = NULL;
-}
-
-bool CComponents::CheckFbData(const comp_fbdata_t& fbdata, const char* func, const int line)
-{
-	int32_t rows = fbdata.dx / (int32_t)frameBuffer->getScreenWidth(true) - 1 + fbdata.y;
-	int32_t rest = fbdata.dx % (int32_t)frameBuffer->getScreenWidth(true);
-        int32_t end  = rows * (int32_t)frameBuffer->getScreenWidth(true) + rest;
-	if (	(fbdata.x < 0 || fbdata.y < 0) ||
-		(end >= (int32_t)frameBuffer->getScreenWidth(true)*(int32_t)frameBuffer->getScreenHeight(true)) 
-	   ) {
-			dprintf(DEBUG_NORMAL, "[CComponents] ERROR! Position < 0 or > FB end [%s - %d]\n\tx = %d  y = %d\n\tdx = %d  dy = %d\n",
-				func, line,
-				fbdata.x, fbdata.y,
-				fbdata.dx, fbdata.dy);
-			return false;
-		}
-		if (fbdata.dx == 0 || fbdata.dy == 0) {
-			dprintf(DEBUG_DEBUG,"[CComponents] INFO! dx and/or dy = 0 [%s - %d]\n\tx = %d  y = %d\n\tdx = %d  dy = %d\n",
-				func, line,
-				fbdata.x, fbdata.y,
-				fbdata.dx, fbdata.dy);
-			return false;
-		}
-	return true;
-}
-
-//paint framebuffer stuff and fill buffer
-void CComponents::paintFbItems(bool do_save_bg)
-{
-	//save background before first paint, do_save_bg must be true
-	if (firstPaint && do_save_bg){
-		for(size_t i=0; i<v_fbdata.size(); i++){
-			if (!CheckFbData(v_fbdata[i], __func__, __LINE__)){
-				break;
-			}
-
-	dprintf(DEBUG_DEBUG, "[CComponents]\n\t[%s - %d] firstPaint->save screen: %d, fbdata_type: %d\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
-			__func__,
-			__LINE__,
-			firstPaint,
-			v_fbdata[i].fbdata_type,
-			v_fbdata[i].x,
-			v_fbdata[i].y,
-			v_fbdata[i].dx,
-			v_fbdata[i].dy);
-
-		saved_screen.x = v_fbdata[i].x;
-		saved_screen.y = v_fbdata[i].y;
-		saved_screen.dx = v_fbdata[i].dx;
-		saved_screen.dy = v_fbdata[i].dy;
-		clearSavedScreen();
-		saved_screen.pixbuf = getScreen(saved_screen.x, saved_screen.y, saved_screen.dx, saved_screen.dy);
-		firstPaint = false;
-		break;
-		}
-	}
-
-	for(size_t i=0; i< v_fbdata.size(); i++){
-		// Don't paint on dimension or position error dx or dy are 0
-		if (!CheckFbData(v_fbdata[i], __func__, __LINE__)){
-			continue;
-		}
-		int fbtype = v_fbdata[i].fbdata_type;
-
-	dprintf(DEBUG_DEBUG, "[CComponents]\n\t[%s - %d], fbdata_[%d]\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
-			__func__,
-			__LINE__,
-			(int)i,
-			v_fbdata[i].x,
-			v_fbdata[i].y,
-			v_fbdata[i].dx,
-			v_fbdata[i].dy);
-
-		//some elements can be assembled from lines and must be handled as one unit (see details line),
-		//so all individual backgrounds of boxes must be saved and painted in "firstpaint mode"
-#if 0
-		if (firstPaint){
-
-			if (do_save_bg && fbtype == CC_FBDATA_TYPE_LINE)
-				v_fbdata[i].pixbuf = getScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
-
-			//ensure painting of all line fb items with saved screens
-			if (fbtype == CC_FBDATA_TYPE_LINE)
-				firstPaint = true;
-			else
-				firstPaint = false;
-		}
-#endif
-		if (do_save_bg && fbtype == CC_FBDATA_TYPE_LINE)
-			v_fbdata[i].pixbuf = getScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
-
-		//paint all fb relevant basic parts (frame and body) with all specified properties, paint_bg must be true
-		if (fbtype != CC_FBDATA_TYPE_BGSCREEN && paint_bg){
-			if (fbtype == CC_FBDATA_TYPE_FRAME) {
-				if (v_fbdata[i].frame_thickness > 0 && cc_allow_paint)
-					frameBuffer->paintBoxFrame(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].frame_thickness, v_fbdata[i].color, v_fbdata[i].r, corner_type);
-			}
-			else if (fbtype == CC_FBDATA_TYPE_BACKGROUND)
-				frameBuffer->paintBackgroundBoxRel(x, y, v_fbdata[i].dx, v_fbdata[i].dy);
-			else if (fbtype == CC_FBDATA_TYPE_SHADOW_BOX) {
-				if (shadow) {
-					int sw = shadow_w;
-					int sw_cur = sw;
-					int x_sh = v_fbdata[i].x + v_fbdata[i].dx - sw;
-					int y_sh = v_fbdata[i].y + v_fbdata[i].dy - sw;
-					if (corner_type && v_fbdata[i].r) {
-						//calculate positon of shadow areas
-						x_sh += sw - 2*v_fbdata[i].r;
-						y_sh += sw - 2*v_fbdata[i].r;
-						//calculate current shadow width depends of current corner_rad
-						sw_cur = max(2*v_fbdata[i].r, sw);
-					}
-					if (cc_allow_paint && !is_painted){
-						// shadow right
-						frameBuffer->paintBoxRel(x_sh, v_fbdata[i].y, sw_cur, v_fbdata[i].dy-sw_cur, v_fbdata[i].color, v_fbdata[i].r, corner_type & CORNER_TOP_RIGHT);
-						// shadow bottom
-						frameBuffer->paintBoxRel(v_fbdata[i].x, y_sh, v_fbdata[i].dx, sw_cur, v_fbdata[i].color, v_fbdata[i].r, corner_type & CORNER_BOTTOM);
-					}
-				}
-			}
-			else {
-				if(cc_allow_paint) {
-					if  (col_body_gradient && (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BOX) && (v_fbdata[i].data != NULL)) {
-						// color gradient
-						gradientData_t *gradientData = static_cast<gradientData_t*> (v_fbdata[i].data);
-						if (gradientData->boxBuf == NULL)
-							gradientData->boxBuf = frameBuffer->paintBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, 0, gradientData, v_fbdata[i].r, corner_type);
-						else
-//							frameBuffer->blit2FB(gradientData->boxBuf, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].x, v_fbdata[i].y);
-							frameBuffer->blitBox2FB(gradientData->boxBuf, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].x, v_fbdata[i].y);
-					} else
-						frameBuffer->paintBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].color, v_fbdata[i].r, corner_type);
-				}
-			}
-		}
-	}
-
-	is_painted = true;
-}
-
-//screen area save
-inline fb_pixel_t* CComponents::getScreen(int ax, int ay, int dx, int dy)
-{
-	if (dx * dy == 0)
-		return NULL;
-
-	fb_pixel_t* pixbuf = new fb_pixel_t[dx * dy];
-	frameBuffer->waitForIdle("CComponents::getScreen()");
-	frameBuffer->SaveScreen(ax, ay, dx, dy, pixbuf);
-	return pixbuf;
-}
-
-//restore screen from buffer
-inline void CComponents::hide()
-{
-	for(size_t i =0; i< v_fbdata.size() ;i++) {
-		if (v_fbdata[i].pixbuf){
-			frameBuffer->waitForIdle("CComponents::hide()");
-			frameBuffer->RestoreScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].pixbuf);
-		}
-	}
-
-	clearFbData();
-	is_painted = false;
-}
-
-//erase or paint over rendered objects
-void CComponents::kill(const fb_pixel_t& bg_color, const int& corner_radius)
-{
-	for(size_t i =0; i< v_fbdata.size() ;i++){
-#if 0
-		if (bg_color != COL_BACKGROUND_PLUS_0)
-#endif
-			int r =  v_fbdata[i].r;
-			if (corner_radius > -1)
-				r = corner_radius;
-			frameBuffer->paintBoxRel(v_fbdata[i].x,
-						 v_fbdata[i].y,
-						 v_fbdata[i].dx,
-						 v_fbdata[i].dy,
-						 bg_color,
-						 r,
-						 corner_type);
-			if (v_fbdata[i].frame_thickness)
-					frameBuffer->paintBoxFrame(v_fbdata[i].x,
-								   v_fbdata[i].y,
-								   v_fbdata[i].dx,
-								   v_fbdata[i].dy,
-								   v_fbdata[i].frame_thickness,
-								   bg_color,
-								   r,
-								   corner_type);
-
-#if 0
-		else
-			frameBuffer->paintBackgroundBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
-#endif
-	}
-	clearFbData();
-	firstPaint = true;
-	is_painted = false;
-}
-
-//clean old screen buffer
-void CComponents::clearFbData()
-{
-	for(size_t i =0; i< v_fbdata.size() ;i++) {
-		if (v_fbdata[i].pixbuf)
-			delete[] v_fbdata[i].pixbuf;
-
-#if 0
-		if (v_fbdata[i].data && (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BOX)) {
-			gradientData_t *gradientData = static_cast<gradientData_t*> (v_fbdata[i].data);
-			if (gradientData->boxBuf)
-				cs_free_uncached(gradientData->boxBuf);
-		}
-#endif
-	}
-	v_fbdata.clear();
-}
-
-inline void CComponents::setXPos(const int& xpos)
-{
-	x = xpos;
-}
-
-inline void CComponents::setYPos(const int& ypos)
-{
-	y = ypos;
-}
-
-void CComponents::setFrameThickness(const int& thickness, const int& thickness_sel)
-{
-	fr_thickness = thickness;
-
-	if (fr_thickness_sel != thickness_sel)
-		fr_thickness_sel = thickness_sel;
-}
-
-
-void CComponents::enableColBodyGradient(bool do_paint_gradient)
-{
-	col_body_gradient = do_paint_gradient;
 }
diff --git a/src/gui/components/cc_base.h b/src/gui/components/cc_base.h
index 38663ae..6ad4f00 100644
--- a/src/gui/components/cc_base.h
+++ b/src/gui/components/cc_base.h
@@ -3,7 +3,8 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2014, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
+	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
 
 	License: GPL
 
@@ -17,362 +18,38 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
-#ifndef __COMPONENTS__
-#define __COMPONENTS__
+#ifndef __CC_BASE__
+#define __CC_BASE__
 
 #include "cc_types.h"
 #include "cc_signals.h"
-#include <gui/widget/textbox.h>
-#include <vector>
-#include <string>
-#include <driver/pictureviewer/pictureviewer.h>
-#include <gui/widget/icons.h>
-#include <driver/fade.h>
-#include <driver/colorgradient.h>
+#include "cc_draw.h"
+
 /// Basic component class.
 /*!
 Basic attributes and member functions for component sub classes
 */
 
-class CComponents : public CComponentsSignals, public COSDFader
+class CComponents : public CComponentsSignals, public CCDraw
 {
-	private:
-		///pixel buffer handling, returns pixel buffer depends of given parameters
-		fb_pixel_t* getScreen(int ax, int ay, int dx, int dy);
-
 	protected:
-		///object: framebuffer object, usable in all sub classes
-		CFrameBuffer * frameBuffer;
-		///container: for frambuffer properties and pixel buffer
-		std::vector<comp_fbdata_t> v_fbdata;
-
-		///property: x-position on screen, to alter with setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
-		int x;
-		///property: y-position on screen, to alter setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
-		int y;
-		///property: contains real x-position on screen
-		int cc_xr;
-		///property: contains real y-position on screen
-		int cc_yr;
-		///property: height-dimension on screen, to alter with setHeight() or setDimensionsAll()
-		int height;
-		///property: width-dimension on screen, to alter with setWidth() or setDimensionsAll()
-		int width;
-		///property: has corners with definied type, types are defined in /driver/frambuffer.h, without effect, if corner_radius=0
-		int corner_type;
-		///property: defined radius of corner, without effect, if corner_type=0
-		int corner_rad;
-		///property: tag for component, can contain any value if required, default value is NULL, you can fill with a cast, see also setTag() and getTag() 
+	
+		///property: tag for component, can contains any value if required, default value is NULL, you can fill with a cast, see also setTag() and getTag() 
 		void *cc_tag;
-		///property: color of body
-		fb_pixel_t col_body;
-		fb_pixel_t old_gradient_color;
-		int old_gradient_c2c;
-		///property: color of shadow
-		fb_pixel_t col_shadow;
-		///property: color of frame
-		fb_pixel_t col_frame;
-		///property: color of frame if component is selected, Note: fr_thickness_sel must be set
-		fb_pixel_t col_frame_sel;
-
-		///property: contains data for gradiant handling
-		gradientData_t cc_gradientData;
-		///property: true component can paint gradient, see also enableColBodyGradient()
-		bool col_body_gradient;
-		///property: background gradient mode
-		int cc_body_gradient_mode;
-		///property: background gradient intensity
-		int cc_body_gradient_intensity;
-		///property: background gradient intensity value min
-		uint8_t cc_body_gradient_intensity_v_min;
-		///property: background gradient intensity value max
-		uint8_t cc_body_gradient_intensity_v_max;
-		///property: background gradient saturation
-		uint8_t cc_body_gradient_saturation;
-		///property: background gradient direction
-		int cc_body_gradient_direction;
-		///property: background gradient mode
-		bool cc_body_gradient_c2c;
-		///property: background gradient 2nd color
-		fb_pixel_t cc_body_gradient_2nd_col;
-
-		///property: true=component has shadow
-		bool shadow;
-		///property: width of shadow
-		int shadow_w;
-
-		 ///property: frame thickness, see also setFrameThickness()
-		int fr_thickness;
-		///property: frame thickness of selected component, see also setFrameThickness()
-		int fr_thickness_sel;
 
-		///status: true=component was painted for 1st time
-		bool firstPaint;
-		///status: true=component was rendered
-		bool is_painted;
-		///mode: true=activate rendering of basic elements (frame, shadow and body)
-		bool paint_bg;
-		bool save_tbox_screen;
-		///mode:  true=allows painting of item, see also allowPaint()
-		bool cc_allow_paint;
-
-		///rendering of framebuffer elements at once,
-		///elements are contained in v_fbdata, presumes added frambuffer elements with paintInit(),
-		///parameter do_save_bg=true, saves background of element to pixel buffer, this can be restore with hide()
-		void paintFbItems(bool do_save_bg = true);
-
-		///check current fbdtata position and dimensions, parameter fbdata is an element of v_fbdata, returns false on error
-		bool CheckFbData(const comp_fbdata_t& fbdata, const char* func, const int line);
-
-		///clean up old screen buffer saved in v_fbdata
-		virtual void clearFbData();
-
-		///container: contains saved pixel buffer with position and dimensions
-		comp_screen_data_t saved_screen; 	
-		
 	public:
 		///basic component class constructor.
 		CComponents();
-		virtual~CComponents();
-
-		///set screen x-position, parameter as int
-		virtual void setXPos(const int& xpos);
-		///set screen y-position, parameter as int
-		virtual void setYPos(const int& ypos);
-		///set x and y position at once
-		///Note: position of bound components (items) means position related within parent form, not for screen!
-		///to set the real screen position, look at setRealPos()
-		inline virtual void setPos(const int& xpos, const int& ypos){x = xpos; y = ypos;};
-
-		///sets real x position on screen. Use this, if item is added to a parent form
-		virtual void setRealXPos(const int& xr){cc_xr = xr;};
-		///sets real y position on screen. Use this, if item is added to a parent form
-		virtual void setRealYPos(const int& yr){cc_yr = yr;};
-		///sets real x and y position on screen at once. Use this, if item is added to a parent form
-		virtual void setRealPos(const int& xr, const int& yr){cc_xr = xr; cc_yr = yr;};
-		///get real x-position on screen. Use this, if item contains own render methods and item is bound to a form
-		virtual int getRealXPos(){return cc_xr;};
-		///get real y-position on screen. Use this, if item contains own render methods and item is bound to a form
-		virtual int getRealYPos(){return cc_yr;};
-		
-		///set height of component on screen
-		inline virtual void setHeight(const int& h){height = h;};
-		///set width of component on screen
-		inline virtual void setWidth(const int& w){width = w;};
-		///set all positions and dimensions of component at once
-		inline virtual void setDimensionsAll(const int& xpos, const int& ypos, const int& w, const int& h){x = xpos; y = ypos; width = w; height = h;};
-
-		///return screen x-position of component
-		///Note: position of bound components (items) means position related within parent form, not for screen!
-		///to get the real screen position, use getRealXPos(), to find in CComponentsItem sub classes
-		inline virtual int getXPos(){return x;};
-		///return screen y-position of component
-		///Note: position of bound components (items) means position related within parent form, not for screen!
-		///to get the real screen position, use getRealYPos(), to find in CComponentsItem sub classes
-		inline virtual int getYPos(){return y;};
-		///return height of component
-		inline virtual int getHeight(){return height;};
-		///return width of component
-		inline virtual int getWidth(){return width;};
-		///return of frame thickness
-		inline virtual int getFrameThickness(){return fr_thickness;};
-
-		///return/set (pass through) width and height of component
-		inline virtual void getSize(int* w, int* h){*w=width; *h=height;};
-		///return/set (pass through) position and dimensions of component at once
-		inline virtual void getDimensions(int* xpos, int* ypos, int* w, int* h){*xpos=x; *ypos=y; *w=width; *h=height;};
+		virtual~CComponents(){};
 
 		///sets tag as void*, see also cc_tag
 		virtual void setTag(void* tag){cc_tag = tag;};
 		///gets tag as void*, see also cc_tag
-		inline virtual void* getTag(){return cc_tag;};
-
-		///set frame color
-		inline virtual void setColorFrame(fb_pixel_t color){col_frame = color;};
-		///set selected frame color
-		inline virtual void setColorFrameSel(fb_pixel_t color){col_frame_sel = color;};
-		///set body color
-		inline virtual void setColorBody(fb_pixel_t color){col_body = color;};
-		///set shadow color
-		inline virtual void setColorShadow(fb_pixel_t color){col_shadow = color;};
-		///set all basic framebuffer element colors at once
-		///Note: Possible color values are defined in "gui/color.h" and "gui/customcolor.h"
-		inline virtual void setColorAll(fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow){col_frame = color_frame; col_body = color_body; col_shadow = color_shadow;};
-		///set color gradient on/off
-		virtual void enableColBodyGradient(bool do_paint_gradient);
-		///set color gradient properties, possible parameter values for mode and intensity to find in CColorGradient, in driver/framebuffer.h>
-		virtual void setColBodyGradient(const int& mode, const int& direction, const int& intensity = CColorGradient::normal, uint8_t v_min=0x40, uint8_t v_max=0xE0, uint8_t s=0xC0)
-						{ cc_body_gradient_mode = mode;
-						  cc_body_gradient_direction = direction;
-						  cc_body_gradient_intensity=intensity;
-						  cc_body_gradient_intensity_v_min=v_min;
-						  cc_body_gradient_intensity_v_max=v_max;
-						  cc_body_gradient_saturation=s; };
-
-		virtual void set2ndColor(fb_pixel_t col_2nd){ cc_body_gradient_c2c = true; cc_body_gradient_2nd_col = col_2nd;};
-
-		///get frame color
-		inline virtual fb_pixel_t getColorFrame(){return col_frame;};
-		///get body color
-		inline virtual fb_pixel_t getColorBody(){return col_body;};
-		///get shadow color
-		inline virtual fb_pixel_t getColorShadow(){return col_shadow;};
-
-		///set corner types
-		///Possible corner types are defined in CFrameBuffer (see: driver/framebuffer.h)
-		///Note: default values are given from settings
-		inline virtual void setCornerType(const int& type){corner_type = type;};
-		///set corner radius and type
-		inline virtual void setCorner(const int& radius, const int& type = CORNER_ALL){corner_rad = radius; corner_type = type;};
-		///get corner types
-		inline virtual int getCornerType(){return corner_type;};
-		///get corner radius
-		inline virtual int getCornerRadius(){return corner_rad;};
-
-		///set frame thickness
-		virtual void setFrameThickness(const int& thickness, const int& thickness_sel = 3);
-		///switch shadow on/off
-		///Note: it's recommended to use #defines: CC_SHADOW_ON=true or CC_SHADOW_OFF=false as parameter, see also cc_types.h
-		inline virtual void setShadowOnOff(bool has_shadow){shadow = has_shadow;};
-
-		///hide current screen and restore background
-		virtual void hide();
-
-		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
-		///from CFrameBuffer but with possiblity to define color, default color is COL_BACKGROUND_PLUS_0 (empty background)
-		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, const int& corner_radius = -1);
-
-		///returns paint mode, true=item was painted
-		virtual bool isPainted(){return is_painted;}
-		///allows paint of elementary item parts (shadow, frame and body), similar as background, set it usually to false, if item used in a form
-		virtual void doPaintBg(bool do_paint){paint_bg = do_paint;};
-		// enable/disable CTextBox screen saving on paint
-		virtual void enableTboxSaveScreen(bool enable){ save_tbox_screen = enable; };
-
-		///allow/disalows paint of item and its contents, but initialize of other properties are not touched
-		///this can be understood as a counterpart to isPainted(), but before paint and value of is_painted is modified temporarily till next paint of item //TODO: is this sufficiently?
-		void allowPaint(bool allow){cc_allow_paint = allow; is_painted = cc_allow_paint ? false : true;};
-		///returns visibility mode
-		virtual bool paintAllowed(){return cc_allow_paint;};
-
-		///cleans saved pixel buffer
-		virtual void clearSavedScreen();
-};
-
-class CComponentsItem : public CComponents
-{
-	protected:
-		///property: define of item type, see cc_types.h for possible types
-		int cc_item_type;
-		///property: define of item index, all bound items get an index,
-		///default: CC_NO_INDEX as identifer for not embedded item and default index=0 for form as main parent
-		///see also getIndex(), setIndex()
-		int cc_item_index;
-		///property: default enabled
-		bool cc_item_enabled;
-		///property: default not selected
-		bool cc_item_selected;
-		///property: page number, this defines current item page location, means: this item is embedded in a parent container on page number n, see also setPageNumber()
-		///default value is 0 for page one, any value > 0 causes handling for mutilple pages at parent container
-		uint8_t cc_page_number;
-		///specifies that some certain operations especially eg. exec events for that item are possible, see also setFocus(), hasFocus()
-		bool cc_has_focus;
-
-		///Pointer to the form object in which this item is embedded.
-		///Is typically the type CComponentsForm or derived classes, default intialized with NULL
-		CComponentsForm *cc_parent;
-
-		///hides item, arg: no_restore=true causes no restore of background, but clean up pixel buffer if required
-		void hideCCItem(bool no_restore = false);
-		
-		///initialze of basic framebuffer elements with shadow, background and frame.
-		///must be called first in all paint() members before paint any item,
-		///If backround is not required, it's possible to override this with variable paint_bg=false, use doPaintBg(true/false) to set this!
-		///arg do_save_bg=false avoids using of unnecessary pixel memory, eg. if no hide with restore is provided. This is mostly the case  whenever
-		///an item will be hide or overpainted with other methods, or it's embedded  (bound)  in a parent form.
-		void paintInit(bool do_save_bg);
-
-		///add "this" current item to parent
-		void initParent(CComponentsForm* parent);
-
-
-	public:
-		CComponentsItem(CComponentsForm *parent = NULL);
-
-		///sets pointer to the form object in which this item is embedded.
-		virtual void setParent(CComponentsForm *parent){cc_parent = parent;};
-		///returns pointer to the form object in which this item is embedded.
-		virtual CComponentsForm* getParent(){return cc_parent;};
-		///property: returns true if item is added to a form
-		virtual bool isAdded();
-		///indicates wether item has focus
-		virtual bool hasFocus(){return cc_has_focus;}
-		///set or unset focus of item, stand alone items without parent have always set focus to true, inside of a parent form object, always the last added item has focus
-		virtual void setFocus(bool focus);
-
-		///abstract: paint item, arg: do_save_bg see paintInit() above
-		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES) = 0;
-		///hides item, arg: no_restore see hideCCItem() above
-		virtual void hide(bool no_restore = false);
-
-		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
-		///from CFrameBuffer but with possiblity to define color, default color is 0 (empty background)
-		///NOTE: Items with parent binding use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
-		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, bool ignore_parent = false);
-
-		///get the current item type, see attribute cc_item_type above
-		virtual int getItemType();
-		///syncronizes item colors with current color settings if required, NOTE: overwrites internal values!
-		virtual void syncSysColors();
-		
-		///set select mode, see also col_frame_sel
-		virtual void setSelected(bool selected){cc_item_selected = selected;};
-		///set enable mode, see also cc_item_enabled
-		virtual void setEnable(bool enabled){cc_item_enabled = enabled;};
-		
-		///get select mode, see also setSelected() above
-		virtual bool isSelected(){return cc_item_selected;};
-		///get enable mode, see also setEnable() above
-		virtual bool isEnabled(){return cc_item_enabled;};
-
-		///get current index of item, see also attribut cc_item_index
-		virtual int getIndex(){return cc_item_index;};
-		///set an index to item, see also attribut cc_item_index.
-		///To generate an index, use genIndex()
-		virtual void setIndex(const int& index){cc_item_index = index;};
-
-		///sets page location of current item, parameter as uint8_t, see: cc_page_number
-		virtual void setPageNumber(const uint8_t& on_page_number){cc_page_number = on_page_number;};
-		///returns current number of page location of current item, see: cc_page_number
-		virtual u_int8_t getPageNumber(){return cc_page_number;};
-
-		///set screen x-position, parameter as int
-		virtual void setXPos(const int& xpos);
-		///set screen y-position, parameter as int
-		virtual void setYPos(const int& ypos);
-		///set screen x-position, parameter as uint8_t, percent x value related to current width of parent form or screen
-		virtual void setXPosP(const uint8_t& xpos_percent);
-		///set screen y-position, parameter as uint8_t, percent y value related to current height of parent form or screen
-		virtual void setYPosP(const uint8_t& ypos_percent);
-		///set x and y position as percent value related to current parent form or screen dimensions at once
-		virtual void setPosP(const uint8_t& xpos_percent, const uint8_t& ypos_percent);
-
-		///do center item on screen or within a parent form, parameter along_mode assigns direction of centering
-		virtual void setCenterPos(int along_mode = CC_ALONG_X | CC_ALONG_Y);
-
-		///set item height, parameter as uint8_t, as percent value related to current height of parent form or screen
-		virtual void setHeightP(const uint8_t& h_percent);
-		///set item width, parameter as uint8_t, as percent value related to current width of parent form or screen
-		virtual void setWidthP(const uint8_t& w_percent);
-
-		///sub: init body color gradient
-		virtual void initBodyGradient();
+		virtual void* getTag(){return cc_tag;};
 };
 
 #endif
diff --git a/src/gui/components/cc_detailsline.cpp b/src/gui/components/cc_detailsline.cpp
index 6a032d4..2ba5d9f 100644
--- a/src/gui/components/cc_detailsline.cpp
+++ b/src/gui/components/cc_detailsline.cpp
@@ -31,6 +31,7 @@
 #include <global.h>
 #include <neutrino.h>
 #include "cc_detailsline.h"
+#include "cc_draw.h"
 
 using namespace std;
 
@@ -61,6 +62,7 @@ void CComponentsDetailLine::initVarDline(	const int& x_pos, const int& y_pos_top
 
 	//CComponentsDetailLine
 	thickness 	= 4;
+	cc_body_gradient_enable = false;
 }
 
 CComponentsDetailLine::~CComponentsDetailLine()
@@ -85,41 +87,50 @@ CComponentsDetailLine::~CComponentsDetailLine()
 //paint details line with current parameters
 void CComponentsDetailLine::paint(bool do_save_bg)
 {
-	clearFbData();
+	cc_save_bg = do_save_bg;
 
-	int y_mark_top = y-h_mark_top/2+thickness/2;
-	int y_mark_down = y_down-h_mark_down/2+thickness/2;
+	hide();
+	if (hasChanges())
+		clearFbData();
 
-	int sw = shadow_w;
+	if (v_fbdata.empty()){
 
-	comp_fbdata_t fbdata[] =
-	{
-		/* vertical item mark | */
-		{CC_FBDATA_TYPE_LINE, x+width-thickness-sw, 	y_mark_top, 		thickness, 		h_mark_top, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-sw,		y_mark_top+sw, 		sw, 			h_mark_top-sw, 		col_shadow, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-thickness,	y_mark_top+h_mark_top, 	thickness, 		sw,	 		col_shadow, 	0, 0, NULL, NULL},
+		int y_mark_top = y-h_mark_top/2+thickness/2;
+		int y_mark_down = y_down-h_mark_down/2+thickness/2;
 
-		/* horizontal item line - */
-		{CC_FBDATA_TYPE_LINE, x, 			y,			width-thickness-sw,	thickness, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+thickness,		y+thickness,		width-2*thickness-sw,	sw, 			col_shadow, 	0, 0, NULL, NULL},
+		int sw = shadow_w;
 
-		/* vertical connect line [ */
-		{CC_FBDATA_TYPE_LINE, x,			y+thickness, 		thickness, 		y_down-y-thickness, 	col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+thickness,		y+thickness+sw,		sw, 			y_down-y-thickness-sw,	col_shadow, 	0, 0, NULL, NULL},
+		cc_fbdata_t fbdata[] =
+		{
+			/*buffered bg full width and height */
+			{CC_FBDATA_TYPE_BGSCREEN,	x,			y_mark_top, 		width,			y_mark_down-y_mark_top+h_mark_down,	0, 0, 0, 0, NULL, NULL, NULL},
 
-		/* horizontal info line - */
-		{CC_FBDATA_TYPE_LINE, x,			y_down, 		width-thickness-sw, 	thickness, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+sw,			y_down+thickness, 	width-thickness-2*sw,	sw, 			col_shadow, 	0, 0, NULL, NULL},
+			/* vertical item mark | */
+			{CC_FBDATA_TYPE_BOX, 		x+width-thickness-sw, 	y_mark_top, 		thickness, 		h_mark_top, 		col_body, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	x+width-sw,		y_mark_top+sw, 		sw, 			h_mark_top-sw, 		col_shadow, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_BOX, 		x+width-thickness,	y_mark_top+h_mark_top, 	thickness, 		sw,	 		col_shadow, 	0, 0, 0, NULL, NULL, NULL},
 
-		/* vertical info mark | */
-		{CC_FBDATA_TYPE_LINE, x+width-thickness-sw,	y_mark_down, 		thickness, 		h_mark_down, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-sw,		y_mark_down+sw,		sw, 			h_mark_down-sw,		col_shadow, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-thickness,	y_mark_down+h_mark_down,thickness, 		sw,	 		col_shadow, 	0, 0, NULL, NULL},
-	};
+			/* horizontal item line - */
+			{CC_FBDATA_TYPE_BOX, 		x, 			y,			width-thickness-sw,	thickness, 		col_body, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	x+thickness,		y+thickness,		width-2*thickness-sw,	sw, 			col_shadow, 	0, 0, 0, NULL, NULL, NULL},
 
-	for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++)
-		v_fbdata.push_back(fbdata[i]);
+			/* vertical connect line [ */
+			{CC_FBDATA_TYPE_BOX, 		x,			y+thickness, 		thickness, 		y_down-y-thickness, 	col_body, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	x+thickness,		y+thickness+sw,		sw, 			y_down-y-thickness-sw,	col_shadow, 	0, 0, 0, NULL, NULL, NULL},
 
+			/* horizontal info line - */
+			{CC_FBDATA_TYPE_BOX, 		x,			y_down, 		width-thickness-sw, 	thickness, 		col_body, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	x+sw,			y_down+thickness, 	width-thickness-2*sw,	sw, 			col_shadow, 	0, 0, 0, NULL, NULL, NULL},
+
+			/* vertical info mark | */
+			{CC_FBDATA_TYPE_BOX, 		x+width-thickness-sw,	y_mark_down, 		thickness, 		h_mark_down, 		col_body, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	x+width-sw,		y_mark_down+sw,		sw, 			h_mark_down-sw,		col_shadow, 	0, 0, 0, NULL, NULL, NULL},
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	x+width-thickness,	y_mark_down+h_mark_down,thickness, 		sw,	 		col_shadow, 	0, 0, 0, NULL, NULL, NULL},
+		};
+
+		for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++)
+			v_fbdata.push_back(fbdata[i]);
+	}
 	paintFbItems(do_save_bg);
 }
 
diff --git a/src/gui/components/cc_draw.cpp b/src/gui/components/cc_draw.cpp
new file mode 100644
index 0000000..271f3d6
--- /dev/null
+++ b/src/gui/components/cc_draw.cpp
@@ -0,0 +1,651 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <global.h>
+#include <neutrino.h>
+#include "cc_draw.h"
+#include <cs_api.h>
+
+#include <system/debug.h>
+
+CCDraw::CCDraw() : COSDFader(g_settings.theme.menu_Content_alpha)
+{
+	frameBuffer 		= CFrameBuffer::getInstance();
+	x = cc_xr = x_old	= 0;
+	y = cc_yr = y_old	= 0;
+	height	= height_old	= CC_HEIGHT_MIN;
+	width	= width_old	= CC_WIDTH_MIN;
+
+	col_body = col_body_old			= COL_MENUCONTENT_PLUS_0;
+	col_shadow = col_shadow_old 		= COL_MENUCONTENTDARK_PLUS_0;
+	col_frame = col_frame_old 		= COL_MENUCONTENT_PLUS_6;
+	col_frame_sel = col_frame_sel_old 	= COL_MENUCONTENTSELECTED_PLUS_0;
+
+	fr_thickness = fr_thickness_old		= 0;
+	fr_thickness_sel = fr_thickness_sel_old	= 3;
+
+	corner_type = corner_type_old		= CORNER_ALL;
+	corner_rad = corner_rad_old		= 0;
+
+	shadow			= CC_SHADOW_OFF;
+	shadow_w = shadow_w_old	= SHADOW_OFFSET;
+
+	cc_paint_cache		= false;
+	cc_scrdata.pixbuf	= NULL;
+	cc_save_bg		= false;
+	firstPaint		= true;
+	is_painted		= false;
+	paint_bg 		= true;
+	cc_allow_paint		= true;
+
+	cc_body_gradient_enable	= cc_body_gradient_enable_old 	= CC_COLGRAD_OFF;
+	cc_body_gradient_2nd_col = cc_body_gradient_2nd_col_old	= COL_MENUCONTENT_PLUS_0;
+
+	cc_body_gradient_mode 					= CColorGradient::gradientLight2Dark;
+	cc_body_gradient_intensity 				= CColorGradient::light;
+	cc_body_gradient_intensity_v_min 			= 0x40;
+	cc_body_gradient_intensity_v_max 			= 0xE0;
+	cc_body_gradient_saturation 				= 0xC0;
+	cc_body_gradient_direction 				= CFrameBuffer::gradientVertical;
+
+	v_fbdata.clear();
+}
+
+CCDraw::~CCDraw()
+{
+	hide();
+	clearFbData();
+}
+
+inline bool CCDraw::applyPosChanges()
+{
+	bool ret = false;
+	if (x != x_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], Pos changes x %d != x_old %d...\033[0m\n", __func__, __LINE__, x, x_old);
+		x_old = x;
+		ret = true;
+	}
+	if (y != y_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], Pos changes y %d != y_old %d...\033[0m\n", __func__, __LINE__, y, y_old);
+		y_old = y;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline bool CCDraw::applyDimChanges()
+{
+	bool ret = false;
+	if (height != height_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes height %d != height_old %d...\033[0m\n", __func__, __LINE__, height, height_old);
+		height_old = height;
+		ret = true;
+	}
+	if (width != width_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes width %d != width_old %d...\033[0m\n", __func__, __LINE__, width, width_old);
+		width_old = width;
+		ret = true;
+	}
+	if (fr_thickness != fr_thickness_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes fr_thickness %d != fr_thickness_old %d...\033[0m\n", __func__, __LINE__, fr_thickness, fr_thickness_old);
+		fr_thickness_old = fr_thickness;
+		ret = true;
+	}
+	if (fr_thickness_sel != fr_thickness_sel_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes fr_thickness_sel %d != fr_thickness_sel_old %d...\033[0m\n", __func__, __LINE__, fr_thickness_sel, fr_thickness_sel_old);
+		fr_thickness_old = fr_thickness;
+		ret = true;
+	}
+	if (shadow_w != shadow_w_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes shadow_w_sel %d != shadow_w_old %d...\033[0m\n", __func__, __LINE__, shadow_w, shadow_w_old);
+		shadow_w_old = shadow_w;
+		ret = true;
+	}
+	if (corner_rad != corner_rad_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes corner_rad %d != corner_rad_old %d...\033[0m\n", __func__, __LINE__, corner_rad, corner_rad_old);
+		corner_rad_old = corner_rad;
+		ret = true;
+	}
+	if (corner_type != corner_type_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes corner_type %d != corner_type_old %d...\033[0m\n", __func__, __LINE__, corner_type, corner_type_old);
+		corner_type_old = corner_type;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline bool CCDraw::applyColChanges()
+{
+	bool ret = false;
+	if (col_body != col_body_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_body %d != col_body_old %d...\033[0m\n", __func__, __LINE__, col_body, col_body_old);
+		col_body_old = col_body;
+		ret = true;
+	}
+	if (col_shadow != col_shadow_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_shadow %d != col_shadow_old %d...\033[0m\n", __func__, __LINE__, col_shadow, col_shadow_old);
+		col_shadow_old = col_shadow;
+		ret = true;
+	}
+	if (col_frame != col_frame_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_frame %d != col_frame_old %d...\033[0m\n", __func__, __LINE__, col_frame, col_frame_old);
+		col_frame_old = col_frame;
+		ret = true;
+	}
+	if (col_frame_sel != col_frame_sel_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_frame_sel %d != col_frame_sel_old %d...\033[0m\n", __func__, __LINE__, col_frame_sel, col_frame_sel_old);
+		col_frame_old = col_frame;
+		ret = true;
+	}
+	if (cc_body_gradient_enable != cc_body_gradient_enable_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes cc_body_gradient_enable %d != cc_body_gradient_enable_old %d...\033[0m\n", __func__, __LINE__, cc_body_gradient_enable, cc_body_gradient_enable_old);
+		cc_body_gradient_enable_old = cc_body_gradient_enable;
+		ret = true;
+	}
+	if (cc_body_gradient_2nd_col != cc_body_gradient_2nd_col_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes cc_body_gradient_2nd_col %d != cc_body_gradient_2nd_col_old %d...\033[0m\n", __func__, __LINE__, cc_body_gradient_2nd_col, cc_body_gradient_2nd_col_old);
+		cc_body_gradient_2nd_col_old = cc_body_gradient_2nd_col;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline bool CCDraw::hasChanges()
+{
+	if (applyPosChanges())
+		return true;
+	if (applyDimChanges())
+		return true;
+	if (applyColChanges())
+		return true;
+
+	return false;
+}
+
+inline void CCDraw::setXPos(const int& xpos)
+{
+	x = xpos;
+}
+
+inline void CCDraw::setYPos(const int& ypos)
+{
+	y = ypos;
+}
+
+inline void CCDraw::setHeight(const int& h)
+{
+	height = h;
+}
+
+inline void CCDraw::setWidth(const int& w)
+{
+	width = w;
+}
+
+void CCDraw::setFrameThickness(const int& thickness, const int& thickness_sel)
+{
+	fr_thickness = thickness;
+
+	if (fr_thickness_sel != thickness_sel)
+		fr_thickness_sel = thickness_sel;
+}
+
+void CCDraw::enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color)
+{
+	if ((cc_body_gradient_enable != enable_mode) || (enable_mode == CC_COLGRAD_OFF))
+		clearFbGradientData();
+
+	cc_body_gradient_enable = enable_mode;
+
+	if (enable_mode == CC_COLGRAD_COL_A_2_COL_B || enable_mode == CC_COLGRAD_COL_B_2_COL_A)
+		set2ndColor(sec_color);
+}
+
+inline void CCDraw::setCornerType(const int& type)
+{
+	corner_type = type;
+}
+
+inline void CCDraw::setCorner(const int& radius, const int& type)
+{
+	corner_rad = radius; 
+	setCornerType(type);
+}
+
+gradientData_t* CCDraw::getGradientData()
+{
+	if (cc_body_gradient_enable == CC_COLGRAD_OFF)
+		return NULL;
+
+	gradientData_t* gdata 	= new gradientData_t;
+	gdata->gradientBuf 	= NULL;
+	gdata->boxBuf 		= NULL;
+	gdata->direction 	= cc_body_gradient_direction;
+	gdata->mode 		= CFrameBuffer::pbrg_noFree;
+	CColorGradient ccGradient;
+	int gsize = cc_body_gradient_direction == CFrameBuffer::gradientVertical ? height : width;
+	//TODO: add modes for direction and intensity
+	switch (cc_body_gradient_enable){
+		case  CC_COLGRAD_LIGHT_2_DARK:
+			cc_body_gradient_mode = CColorGradient::gradientLight2Dark;
+			break;
+		case  CC_COLGRAD_DARK_2_LIGHT:
+			cc_body_gradient_mode = CColorGradient::gradientDark2Light;
+			break;
+		case  CC_COLGRAD_COL_A_2_COL_B:
+			cc_body_gradient_mode = CColorGradient::gradientLight2Dark;
+			break;
+		case  CC_COLGRAD_COL_B_2_COL_A:
+			cc_body_gradient_mode = CColorGradient::gradientDark2Light;
+			break;
+		case  CC_COLGRAD_COL_LIGHT_DARK_LIGHT:
+			cc_body_gradient_mode = CColorGradient::gradientLight2Dark2Light;
+			break;
+		case  CC_COLGRAD_COL_DARK_LIGHT_DARK:
+			cc_body_gradient_mode = CColorGradient::gradientDark2Light2Dark;
+			break;
+	}
+
+	if (cc_body_gradient_enable == CC_COLGRAD_COL_A_2_COL_B || cc_body_gradient_enable == CC_COLGRAD_COL_B_2_COL_A){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], init gradient c2c)...\033[0m\n", __func__, __LINE__);
+		gdata->gradientBuf = ccGradient.gradientColorToColor(col_body,
+								cc_body_gradient_2nd_col,
+								NULL,
+								gsize,
+								cc_body_gradient_mode,
+								cc_body_gradient_intensity);
+	}else{
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], init gradient single color)...\033[0m\n", __func__, __LINE__);
+		gdata->gradientBuf = ccGradient.gradientOneColor(col_body,
+							NULL,
+							gsize,
+							cc_body_gradient_mode,
+							cc_body_gradient_intensity,
+							cc_body_gradient_intensity_v_min,
+							cc_body_gradient_intensity_v_max,
+							cc_body_gradient_saturation);
+	}
+
+	return gdata;
+}
+
+bool CCDraw::clearSavedScreen()
+{
+	/* Here we clean only screen buffers from background layers.
+	 * Paint cache and gradient are not touched.
+	*/
+	bool ret = false;
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BGSCREEN){
+			if (v_fbdata[i].pixbuf){
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], cleanup bg...\033[0m\n", __func__, __LINE__);
+				delete[] v_fbdata[i].pixbuf;
+				v_fbdata[i].pixbuf = NULL;
+				ret = true;
+			}
+		}
+	}
+	return ret;
+}
+
+bool CCDraw::clearPaintCache()
+{
+	/* Here we clean only the paint cache from foreground layers.
+	 * BG layer is not touched.
+	*/
+	bool ret = false;
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].fbdata_type != CC_FBDATA_TYPE_BGSCREEN){
+			if (v_fbdata[i].pixbuf){
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], cleanup paint cache layer...\033[0m\n", __func__, __LINE__);
+				delete[] v_fbdata[i].pixbuf;
+				v_fbdata[i].pixbuf = NULL;
+				ret = true;
+			}
+		}
+	}
+	return ret;
+}
+
+//clean old gradient buffer
+bool CCDraw::clearFbGradientData()
+{
+	bool ret = false;
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].gradient_data){
+			if (v_fbdata[i].gradient_data->gradientBuf){
+				free(v_fbdata[i].gradient_data->gradientBuf);
+				v_fbdata[i].gradient_data->gradientBuf = NULL;
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], clean up gradientBuf...\033[0m\n", __func__, __LINE__);
+			}
+			if (v_fbdata[i].gradient_data->boxBuf){
+				cs_free_uncached(v_fbdata[i].gradient_data->boxBuf);
+				v_fbdata[i].gradient_data->boxBuf = NULL;
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], clean up boxBuf...\033[0m\n", __func__, __LINE__);
+			}
+			delete v_fbdata[i].gradient_data;
+			v_fbdata[i].gradient_data = NULL;
+			ret = true;
+		}
+	}
+	return ret;
+}
+
+bool CCDraw::clearScreenBuffer()
+{
+	bool ret = false;
+	if (clearSavedScreen())
+		ret = true;
+	if (clearPaintCache())
+		ret = true;
+	if (clearFbGradientData())
+		ret = true;
+
+	return ret;
+}
+
+void CCDraw::clearFbData()
+{
+	clearScreenBuffer();
+	v_fbdata.clear();
+}
+
+bool CCDraw::CheckFbData(const cc_fbdata_t& fbdata, const char* func, const int line)
+{
+	int32_t rows = fbdata.dx / (int32_t)frameBuffer->getScreenWidth(true) - 1 + fbdata.y;
+	int32_t rest = fbdata.dx % (int32_t)frameBuffer->getScreenWidth(true);
+        int32_t end  = rows * (int32_t)frameBuffer->getScreenWidth(true) + rest;
+	if (	(fbdata.x < 0 || fbdata.y < 0) ||
+		(end >= (int32_t)frameBuffer->getScreenWidth(true)*(int32_t)frameBuffer->getScreenHeight(true)) 
+	   ) {
+			dprintf(DEBUG_NORMAL, "[CCDraw] ERROR! Position < 0 or > FB end [%s - %d]\n\tx = %d  y = %d\n\tdx = %d  dy = %d\n",
+				func, line,
+				fbdata.x, fbdata.y,
+				fbdata.dx, fbdata.dy);
+			return false;
+		}
+		if (fbdata.dx == 0 || fbdata.dy == 0) {
+			dprintf(DEBUG_DEBUG,"[CCDraw]\t[%s - %d], INFO! dx and/or dy = 0, tx = %d,  y = %d, dx = %d,  dy = %d\n",
+				func, line,
+				fbdata.x, fbdata.y,
+				fbdata.dx, fbdata.dy);
+			return false;
+		}
+	return true;
+}
+
+
+
+//screen area save
+fb_pixel_t* CCDraw::getScreen(int ax, int ay, int dx, int dy)
+{
+	if (dx * dy == 0)
+		return NULL;
+
+	dprintf(DEBUG_INFO, "[CCDraw] INFO! [%s - %d], ax = %d, ay = %d, dx = %d, dy = %d\n", __func__, __LINE__, ax, ay, dx, dy);
+	fb_pixel_t* pixbuf = new fb_pixel_t[dx * dy];
+	frameBuffer->waitForIdle("CCDraw::getScreen()");
+	frameBuffer->SaveScreen(ax, ay, dx, dy, pixbuf);
+	return pixbuf;
+}
+
+cc_screen_data_t CCDraw::getScreenData(const int& ax, const int& ay, const int& dx, const int& dy)
+{
+	cc_screen_data_t res;
+	res.pixbuf = getScreen(ax, ay, dx, dy);
+	res.x = ax; res.y = ay; res.dx = dx; res.dy = dy;
+
+	return res;
+}
+
+void CCDraw::enableSaveBg(bool save_bg)
+{
+	cc_save_bg = save_bg;
+	if (!cc_save_bg)
+		clearSavedScreen();
+}
+
+void CCDraw::enablePaintCache(bool enable)
+{
+	cc_paint_cache = enable;
+	if (!cc_paint_cache)
+		clearPaintCache();
+}
+
+//paint framebuffer layers
+void CCDraw::paintFbItems(bool do_save_bg)
+{
+	//first modify background handling
+	enableSaveBg(do_save_bg);
+
+	if (hasChanges()){
+		if (!firstPaint){
+			firstPaint = true;
+		}else{
+			clearScreenBuffer();
+		}
+	}
+
+	//save background before first paint, cc_save_bg must be true
+	if (firstPaint && cc_save_bg){
+		/* On first we must ensure that screen buffer is empty.
+		 * Here we clean possible screen buffers in bg layers,
+		 * paint cache and gradient buffer.
+		*/
+		clearScreenBuffer();
+
+		/* On second step we check for
+		 * usable item dimensions and exit here if found any problem
+		*/
+		for(size_t i=0; i<v_fbdata.size(); i++){
+			if (!CheckFbData(v_fbdata[i], __func__, __LINE__)){
+				break;
+			}
+
+			dprintf(DEBUG_DEBUG, "[CCDraw]\n\t[%s - %d] firstPaint->save screen: %d, fbdata_type: %d\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
+			__func__,
+			__LINE__,
+			firstPaint,
+			v_fbdata[i].fbdata_type,
+			v_fbdata[i].x,
+			v_fbdata[i].y,
+			v_fbdata[i].dx,
+			v_fbdata[i].dy);
+
+			/* here we save the background of current box before paint.
+			* Only the reserved fbdata type CC_FBDATA_TYPE_BGSCREEN is here required and is used for this.
+			* This pixel buffer is required for the hide() method that will
+			* call the restore method from framebuffer class to restore
+			* background.
+			*/
+			if (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BGSCREEN){
+				v_fbdata[i].pixbuf = getScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
+				break;
+			}
+		}
+		firstPaint = false;
+	}
+	
+	for(size_t i=0; i< v_fbdata.size(); i++){
+		cc_fbdata_t& fbdata = v_fbdata[i];
+
+		// Don't paint on dimension or position error dx or dy are 0
+		if (!CheckFbData(fbdata, __func__, __LINE__)){
+			continue;
+		}
+		int fbtype = fbdata.fbdata_type;
+
+			dprintf(DEBUG_DEBUG, "[CCDraw]\n\t[%s - %d], fbdata_[%d]\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
+			__func__,
+			__LINE__,
+			(int)i,
+			fbdata.x,
+			fbdata.y,
+			fbdata.dx,
+			fbdata.dy);
+
+		/*paint all fb relevant basic parts (shadow, frame and body)
+		 * with all specified properties, paint_bg must be enabled
+		*/
+		if (paint_bg){				
+			if (fbtype == CC_FBDATA_TYPE_FRAME) {
+				if (fbdata.frame_thickness > 0 && cc_allow_paint)
+					frameBuffer->paintBoxFrame(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.frame_thickness, fbdata.color, fbdata.r, fbdata.rtype);
+			}
+			else if (fbtype == CC_FBDATA_TYPE_BACKGROUND){
+				frameBuffer->paintBackgroundBoxRel(x, y, fbdata.dx, fbdata.dy);
+			}
+			else if (fbtype == CC_FBDATA_TYPE_SHADOW_BOX && !is_painted) {
+				if (shadow) {
+					/* here we paint the shadow around the body
+					 * on 1st step we check for already cached screen buffer, if true
+					 * then restore this instead to call the paint methode.
+					 * This could be usally, if we use existant instances of "this" object
+					*/
+					if (cc_allow_paint){
+						if (fbdata.pixbuf){
+							dprintf(DEBUG_NORMAL, "\033[33m[CCDraw]\t[%s - %d], paint shadow from cache...\033[0m\n", __func__, __LINE__);
+							frameBuffer->RestoreScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.pixbuf);
+						}else					
+							frameBuffer->paintBoxRel(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.color, fbdata.r, fbdata.rtype);
+
+						//if is paint cache enabled
+						if (cc_paint_cache && fbdata.pixbuf == NULL)
+							fbdata.pixbuf = getScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy);
+					}
+				}
+			}
+			else if (fbtype == CC_FBDATA_TYPE_BOX){
+				if(cc_allow_paint) {
+					//ensure clean gradient data on disabled gradient
+					if(cc_body_gradient_enable == CC_COLGRAD_OFF && fbdata.gradient_data){
+						dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], gradient mode is disabled but filled\033[0m\n", __func__, __LINE__);
+						clearFbGradientData();
+					}
+					if (cc_body_gradient_enable != CC_COLGRAD_OFF){
+						/* if color gradient enabled we create a gradient_data 
+						* instance and add it to the fbdata object
+						* On disabled coloor gradient we do paint only a default box
+						*/
+						if (fbdata.gradient_data == NULL){
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], crate new gradient data)...\033[0m\n", __func__, __LINE__);
+							fbdata.gradient_data = getGradientData();
+						}
+
+						// if found empty gradient buffer, create it, otherwise paint from cache
+						if (fbdata.gradient_data->boxBuf == NULL){
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint new gradient)...\033[0m\n", __func__, __LINE__);
+							fbdata.gradient_data->boxBuf = frameBuffer->paintBoxRel(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, 0, fbdata.gradient_data, fbdata.r, fbdata.rtype);
+						}else{
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint cached gradient)...\033[0m\n", __func__, __LINE__);
+							frameBuffer->blitBox2FB(fbdata.gradient_data->boxBuf, fbdata.dx, fbdata.dy, fbdata.x, fbdata.y);
+						}
+					}else{
+						/* here we paint the main body of box
+						* on 1st step we check for already cached background buffer, if true
+						* then restore this instead to call the paint methodes and gradient creation
+						* paint cache can be enable/disable with enablePaintCache()
+						*/
+						if (fbdata.pixbuf){
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint body from cache...\033[0m\n", __func__, __LINE__);
+							frameBuffer->RestoreScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.pixbuf);
+						}else{
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint default box)...\033[0m\n", __func__, __LINE__);
+							frameBuffer->paintBoxRel(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.color, fbdata.r, fbdata.rtype);
+							if (cc_paint_cache)
+								fbdata.pixbuf = getScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	is_painted = true;
+}
+
+
+
+void CCDraw::hide()
+{
+	bool restored = false;
+
+	//restore saved screen background of item if available
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BGSCREEN){
+			if (v_fbdata[i].pixbuf) {
+				//restore screen from backround layer
+				frameBuffer->waitForIdle("CCDraw::hide()");
+				frameBuffer->RestoreScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].pixbuf);
+				restored = true;
+			}
+		}
+	}
+	//cleanup background layer, but only if restore was required
+	if (restored)
+		clearSavedScreen();
+
+	is_painted = false;
+	firstPaint = true;
+}
+
+//erase or paint over rendered objects
+void CCDraw::kill(const fb_pixel_t& bg_color, const int& corner_radius)
+{
+	for(size_t i =0; i< v_fbdata.size() ;i++){
+#if 0
+		if (bg_color != COL_BACKGROUND_PLUS_0)
+#endif
+			int r =  v_fbdata[i].r;
+			if (corner_radius > -1)
+				r = corner_radius;
+			frameBuffer->paintBoxRel(v_fbdata[i].x,
+						 v_fbdata[i].y,
+						 v_fbdata[i].dx,
+						 v_fbdata[i].dy,
+						 bg_color,
+						 r,
+						 corner_type);
+			if (v_fbdata[i].frame_thickness)
+					frameBuffer->paintBoxFrame(v_fbdata[i].x,
+								   v_fbdata[i].y,
+								   v_fbdata[i].dx,
+								   v_fbdata[i].dy,
+								   v_fbdata[i].frame_thickness,
+								   bg_color,
+								   r,
+								   corner_type);
+
+#if 0
+		else
+			frameBuffer->paintBackgroundBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
+#endif
+	}
+	clearFbData();
+	firstPaint = true;
+	is_painted = false;
+}
diff --git a/src/gui/components/cc_draw.h b/src/gui/components/cc_draw.h
new file mode 100644
index 0000000..fea06c2
--- /dev/null
+++ b/src/gui/components/cc_draw.h
@@ -0,0 +1,297 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_DRAW__
+#define __CC_DRAW__
+
+#include "cc_types.h"
+#include <driver/colorgradient.h>
+#include <driver/fade.h>
+#include <gui/color.h>
+
+/// Basic component class.
+/*!
+Basic paint attributes and member functions for component classes
+*/
+
+class CCDraw : public COSDFader
+{
+	protected:
+		///pixel buffer handling, returns pixel buffer depends of given parameters
+		fb_pixel_t* getScreen(int ax, int ay, int dx, int dy);
+		///returns screen data as screen_data_t
+		cc_screen_data_t getScreenData(const int& ax, const int& ay, const int& dx, const int& dy);
+		cc_screen_data_t cc_scrdata;
+
+		///object: framebuffer object, usable in all sub classes
+		CFrameBuffer * frameBuffer;
+		
+		///property: x-position on screen, to alter with setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
+		int x, x_old;
+		///property: y-position on screen, to alter setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
+		int y, y_old;
+		///property: contains real x-position on screen
+		int cc_xr;
+		///property: contains real y-position on screen
+		int cc_yr;
+		///property: height-dimension on screen, to alter with setHeight() or setDimensionsAll()
+		int height, height_old;
+		///property: width-dimension on screen, to alter with setWidth() or setDimensionsAll()
+		int width, width_old;
+
+		///property: color of body
+		fb_pixel_t col_body, col_body_old;
+		///property: color of shadow
+		fb_pixel_t col_shadow, col_shadow_old;
+		///property: color of frame
+		fb_pixel_t col_frame, col_frame_old;
+		///property: color of frame if component is selected, Note: fr_thickness_sel must be set
+		fb_pixel_t col_frame_sel, col_frame_sel_old;
+
+		 ///property: frame thickness, see also setFrameThickness()
+		int fr_thickness, fr_thickness_old;
+		///property: frame thickness of selected component, see also setFrameThickness()
+		int fr_thickness_sel, fr_thickness_sel_old;
+
+		///property: has corners with definied type, types are defined in /driver/frambuffer.h, without effect, if corner_radius=0
+		int corner_type, corner_type_old;
+		///property: defined radius of corner, without effect, if corner_type=0
+		int corner_rad, corner_rad_old;
+
+		///property: true=component has shadow
+		bool shadow;
+		///property: width of shadow
+		int shadow_w, shadow_w_old;
+
+		///returns true if internal property was changed
+		virtual bool hasChanges();
+		///apply current position changes and returns true if internal values were changed
+		virtual bool applyPosChanges();
+		///apply current dimension changes and returns true if internal values were changed
+		virtual bool applyDimChanges();
+		///apply current color changes and returns true if internal values were changed
+		virtual bool applyColChanges();
+
+		///paint caching for body and shadow, default init value = true, see also enablePaintCache() NOTE: has no effect if paint_bg = false
+		bool cc_paint_cache;
+		
+		///enable/disable background buffer, default init value = false, see also enableSaveBg()
+		bool cc_save_bg;
+
+		///container: for frambuffer properties and pixel buffer
+		std::vector<cc_fbdata_t> v_fbdata;
+
+		///status: true=component was painted for 1st time
+		bool firstPaint;
+		///status: true=component was rendered
+		bool is_painted;
+		///mode: true=activate rendering of basic elements (frame, shadow and body)
+		bool paint_bg;
+		///mode:  true=allows painting of item, see also allowPaint()
+		bool cc_allow_paint;
+
+		///property: true component can paint gradient, see also enableColBodyGradient()
+		int cc_body_gradient_enable, cc_body_gradient_enable_old;
+		///property: background gradient mode
+		int cc_body_gradient_mode;
+		///property: background gradient intensity
+		int cc_body_gradient_intensity;
+		///property: background gradient intensity value min
+		uint8_t cc_body_gradient_intensity_v_min;
+		///property: background gradient intensity value max
+		uint8_t cc_body_gradient_intensity_v_max;
+		///property: background gradient saturation
+		uint8_t cc_body_gradient_saturation;
+		///property: background gradient direction
+		int cc_body_gradient_direction;
+
+		//TODO: move into layers
+		int old_gradient_color;
+		///property: background gradient 2nd color
+		fb_pixel_t cc_body_gradient_2nd_col, cc_body_gradient_2nd_col_old;
+
+		///check current fbdtata position and dimensions, parameter fbdata is an element of v_fbdata, returns false on error
+		bool CheckFbData(const cc_fbdata_t& fbdata, const char* func, const int line);
+
+		///sub: get gradient data evaluted with current parameters
+		gradientData_t* getGradientData();
+
+		///rendering of framebuffer elements at once,
+		///elements are contained in v_fbdata, presumes added frambuffer elements with paintInit(),
+		///parameter do_save_bg=true, saves background of element to pixel buffer, this can be restore with hide()
+		void paintFbItems(bool do_save_bg = true);
+
+	public:
+		///basic component class constructor.
+		CCDraw();
+		virtual~CCDraw();
+
+		///cleans saved screen buffer, required by hide(), returns true if any buffer was deleted
+		virtual bool clearSavedScreen();
+		///cleanup paint cache, removes saved buffer contents from cached foreground layers, returns true if any buffer was removed
+		virtual bool clearPaintCache();
+		///cleanup old gradient buffers, returns true if any gradient buffer data was removed
+		virtual bool clearFbGradientData();
+
+		///cleans all possible screen buffers, it calls clearSavedScreen(), clearPaintCache() and  clearFbGradientData() at once
+		virtual bool clearScreenBuffer();
+		///does the same like clearScreenBuffer(), additional cleans v_fbdata layers and reset layer properties
+		virtual void clearFbData();
+
+		///set screen x-position, parameter as int
+		virtual void setXPos(const int& xpos);
+		///set screen y-position, parameter as int
+		virtual void setYPos(const int& ypos);
+		///set x and y position at once
+		///Note: position of bound components (items) means position related within parent form, not for screen!
+		///to set the real screen position, look at setRealPos()
+		virtual void setPos(const int& xpos, const int& ypos){setXPos(xpos); setYPos(ypos);}
+
+		///sets real x position on screen. Use this, if item is added to a parent form
+		virtual void setRealXPos(const int& xr){cc_xr = xr;}
+		///sets real y position on screen. Use this, if item is added to a parent form
+		virtual void setRealYPos(const int& yr){cc_yr = yr;}
+		///sets real x and y position on screen at once. Use this, if item is added to a parent form
+		virtual void setRealPos(const int& xr, const int& yr){cc_xr = xr; cc_yr = yr;}
+		///get real x-position on screen. Use this, if item contains own render methods and item is bound to a form
+		virtual int getRealXPos(){return cc_xr;}
+		///get real y-position on screen. Use this, if item contains own render methods and item is bound to a form
+		virtual int getRealYPos(){return cc_yr;}
+		
+		///set height of component on screen
+		virtual void setHeight(const int& h);
+		///set width of component on screen
+		virtual void setWidth(const int& w);
+		///set all positions and dimensions of component at once
+		virtual void setDimensionsAll(const int& xpos, const int& ypos, const int& w, const int& h){setPos(xpos, ypos); setWidth(w); setHeight(h);}
+
+		///return screen x-position of component
+		///Note: position of bound components (items) means position related within parent form, not for screen!
+		///to get the real screen position, use getRealXPos(), to find in CComponentsItem sub classes
+		virtual int getXPos(){return x;};
+		///return screen y-position of component
+		///Note: position of bound components (items) means position related within parent form, not for screen!
+		///to get the real screen position, use getRealYPos(), to find in CComponentsItem sub classes
+		virtual int getYPos(){return y;}
+		///return height of component
+		virtual int getHeight(){return height;}
+		///return width of component
+		virtual int getWidth(){return width;}
+
+		///return/set (pass through) width and height of component
+		virtual void getSize(int* w, int* h){*w=width; *h=height;}
+		///return/set (pass through) position and dimensions of component at once
+		virtual void getDimensions(int* xpos, int* ypos, int* w, int* h){*xpos=x; *ypos=y; *w=width; *h=height;}
+
+		///set frame thickness
+		virtual void setFrameThickness(const int& thickness, const int& thickness_sel = 3);
+		///return of frame thickness
+		virtual int getFrameThickness(){return fr_thickness;}
+		///set frame color
+		virtual void setColorFrame(fb_pixel_t color){col_frame = color;}
+		///set selected frame color
+		virtual void setColorFrameSel(fb_pixel_t color){col_frame_sel = color;}
+		virtual void set2ndColor(fb_pixel_t col_2nd){cc_body_gradient_2nd_col = col_2nd;}
+
+		///get frame color
+		virtual fb_pixel_t getColorFrame(){return col_frame;}
+		///get body color
+		virtual fb_pixel_t getColorBody(){return col_body;}
+		///get shadow color
+		virtual fb_pixel_t getColorShadow(){return col_shadow;}
+
+		///set body color
+		virtual void setColorBody(fb_pixel_t color){col_body = color;}
+		///set shadow color
+		virtual void setColorShadow(fb_pixel_t color){col_shadow = color;}
+		///set all basic framebuffer element colors at once
+		///Note: Possible color values are defined in "gui/color.h" and "gui/customcolor.h"
+		virtual void setColorAll(fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow){col_frame = color_frame; col_body = color_body; col_shadow = color_shadow;};
+
+		///set corner types
+		///Possible corner types are defined in CFrameBuffer (see: driver/framebuffer.h)
+		///Note: default values are given from settings
+		virtual void setCornerType(const int& type);
+		///set corner radius and type
+		virtual void setCorner(const int& radius, const int& type = CORNER_ALL);
+		///get corner types
+		inline virtual int getCornerType(){return corner_type;};
+		///get corner radius
+		inline virtual int getCornerRadius(){return corner_rad;};
+
+		///switch shadow on/off
+		///Note: it's recommended to use #defines: CC_SHADOW_ON=true or CC_SHADOW_OFF=false as parameter, see also cc_types.h
+		inline virtual void setShadowOnOff(bool has_shadow){shadow = has_shadow;};
+
+		///paint caching for body and shadow, see also cc_paint_cache NOTE: has no effect if paint_bg = false
+		virtual void enablePaintCache(bool enable = true);
+		///disable paint caching for body and shadow
+		virtual void disablePaintCache(){enablePaintCache(false);}
+
+		///returns paint mode, true=item was painted
+		virtual bool isPainted(){return is_painted;}
+		///allows paint of elementary item parts (shadow, frame and body), similar as background, set it usually to false, if item used in a form
+		virtual void doPaintBg(bool do_paint){paint_bg = do_paint;}
+		///enable/disable background buffering, default action = enable, see also cc_save_bg
+		virtual void enableSaveBg(bool save_bg = true);
+		///disable background buffering, does the same like enableSaveBg(false), NOTE: cleans existant pixbuffer content!
+		virtual void disableSaveBg(){enableSaveBg(false);}
+
+		///allow/disalows paint of item and its contents, but initialize of other properties are not touched
+		///this can be understood as a counterpart to isPainted(), but before paint and value of is_painted is modified temporarily till next paint of item //TODO: is this sufficiently?
+		void allowPaint(bool allow){cc_allow_paint = allow; is_painted = cc_allow_paint ? false : true;}
+		///returns visibility mode
+		virtual bool paintAllowed(){return cc_allow_paint;};
+
+		///set color gradient on/off
+		virtual void enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/);
+		///disable color gradient
+		virtual void disableColBodyGradient(){enableColBodyGradient(CC_COLGRAD_OFF);}
+		///set color gradient properties, possible parameter values for mode and intensity to find in CColorGradient, in driver/framebuffer.h>
+		virtual void setColBodyGradient(const int& mode, const int& direction, const int& intensity = CColorGradient::normal, uint8_t v_min=0x40, uint8_t v_max=0xE0, uint8_t s=0xC0)
+						{ cc_body_gradient_mode = mode;
+						  cc_body_gradient_direction = direction;
+						  cc_body_gradient_intensity=intensity;
+						  cc_body_gradient_intensity_v_min=v_min;
+						  cc_body_gradient_intensity_v_max=v_max;
+						  cc_body_gradient_saturation=s; };
+		///gets current color gradient mode
+		virtual int getColBodyGradientMode(){return cc_body_gradient_enable;}
+
+		///abstract: paint item, arg: do_save_bg see paintInit() above
+		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES) = 0;
+
+		/*!
+		 Removes current item from screen and
+		 restore last displayed background before item was painted and
+		 ensures demage of already existing screen buffers too.
+		*/
+		virtual void hide();
+
+		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
+		///from CFrameBuffer but with possiblity to define color, default color is COL_BACKGROUND_PLUS_0 (empty background)
+		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, const int& corner_radius = -1);
+};
+
+#endif
diff --git a/src/gui/components/cc_frm.cpp b/src/gui/components/cc_frm.cpp
index fb4b3c7..70e181c 100644
--- a/src/gui/components/cc_frm.cpp
+++ b/src/gui/components/cc_frm.cpp
@@ -47,18 +47,11 @@ CComponentsForm::CComponentsForm(	const int x_pos, const int y_pos, const int w,
 {
 	cc_item_type 	= CC_ITEMTYPE_FRM;
 
-	x		= x_pos;
-	y 		= y_pos;
-	cc_xr 		= x;
-	cc_yr 		= y;
-	width 		= w;
-	height	 	= h;
-
-	shadow		= has_shadow;
-	col_frame 	= color_frame;
-	col_body	= color_body;
-	col_shadow	= color_shadow;
+	Init(x_pos, y_pos, w, h, color_frame, color_body, color_shadow);
+	cc_xr 	= x;
+	cc_yr 	= y;
 
+	shadow 		= has_shadow;
 	shadow_w	= SHADOW_OFFSET;
 	corner_rad	= RADIUS_LARGE;
 	corner_type 	= CORNER_ALL;
@@ -80,6 +73,15 @@ CComponentsForm::CComponentsForm(	const int x_pos, const int y_pos, const int w,
 	this->OnExec.connect(sl);
 }
 
+void CComponentsForm::Init(	const int& x_pos, const int& y_pos, const int& w, const int& h,
+				const fb_pixel_t& color_frame,
+				const fb_pixel_t& color_body,
+				const fb_pixel_t& color_shadow)
+{
+	setDimensionsAll(x_pos, y_pos, w, h);
+	setColorAll(color_frame, color_body, color_shadow);
+}
+
 CComponentsForm::~CComponentsForm()
 {
 	clear();
@@ -292,7 +294,7 @@ void CComponentsForm::insertCCItem(const uint& cc_item_id, CComponentsItem* cc_I
 
 	if (v_cc_items.empty()){
 		addCCItem(cc_Item);
-		dprintf(DEBUG_DEBUG, "[CComponentsForm]  %s insert cc_Item not possible, v_cc_items is empty, cc_Item added\n", __func__);
+		dprintf(DEBUG_NORMAL, "[CComponentsForm]  %s insert cc_Item not possible, v_cc_items is empty, cc_Item added\n", __func__);
 	}else{
 		v_cc_items.insert(v_cc_items.begin()+cc_item_id, cc_Item);
 		cc_Item->setParent(this);
@@ -520,23 +522,23 @@ void CComponentsForm::paintCCItems()
 		cc_item->allowPaint(item_visible);
 	}
 }
-
-void CComponentsForm::hide(bool no_restore)
+#if 0
+void CComponentsForm::hide()
 {
 	// hack: ensure hiding of minitv during hide of forms and inherited classes,
 	// because the handling of minitv items are different to other item types
 	// and need an explizit call of hide()
 	for(size_t i=0; i<v_cc_items.size(); i++) {
 		if (v_cc_items[i]->getItemType() == CC_ITEMTYPE_PIP){
-			v_cc_items[i]->hide();
+			v_cc_items[i]->kill();
 			break;
 		}
 	}
 
 	//hide body
-	hideCCItem(no_restore);
+	CComponents::hide();
 }
-
+#endif
 //erase or paint over rendered objects
 void CComponentsForm::killCCItems(const fb_pixel_t& bg_color, bool ignore_parent)
 {
diff --git a/src/gui/components/cc_frm.h b/src/gui/components/cc_frm.h
index 4736598..a4f7fba 100644
--- a/src/gui/components/cc_frm.h
+++ b/src/gui/components/cc_frm.h
@@ -26,7 +26,8 @@
 
 
 #include "config.h"
-#include <gui/components/cc_base.h>
+#include "cc_base.h"
+#include "cc_item.h"
 #include "cc_frm_scrollbar.h"
 
 class CComponentsForm : public CComponentsItem
@@ -55,6 +56,12 @@ class CComponentsForm : public CComponentsItem
 		///enable/disable page scrolling, default enabled with page scroll mode up/down keys, see also enablePageScroll()
 		int page_scroll_mode;
 
+		///initialize basic properties
+		virtual void Init(	const int& x_pos, const int& y_pos, const int& w, const int& h,
+					const fb_pixel_t& color_frame,
+					const fb_pixel_t& color_body,
+					const fb_pixel_t& color_shadow);
+
 	public:
 		CComponentsForm(	const int x_pos = 0, const int y_pos = 0, const int w = 800, const int h = 600,
 					CComponentsForm *parent = NULL,
@@ -66,8 +73,6 @@ class CComponentsForm : public CComponentsItem
 
 		///paints current form on screen, for paint a page use paintPage()
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
-		///hides current form, background will be restored, if parameter = false
-		void hide(bool no_restore = false);
 
 		///same like CComponentsItem::kill(), but erases all embedded items inside of parent at once, this = parent
 		///NOTE: Items always have parent bindings to "this" and use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
diff --git a/src/gui/components/cc_frm_button.cpp b/src/gui/components/cc_frm_button.cpp
index 92c193c..63f5ac7 100644
--- a/src/gui/components/cc_frm_button.cpp
+++ b/src/gui/components/cc_frm_button.cpp
@@ -102,10 +102,10 @@ void CComponentsButton::initVarButton(	const int& x_pos, const int& y_pos, const
 	shadow		= has_shadow;
 	shadow_w	= SHADOW_OFFSET;
 
-	col_body_gradient = false/*g_settings.gradiant*/; //gradient is prepared for use but disabled at the moment till some other parts of gui parts are provide gradient
+	cc_body_gradient_enable = false/*g_settings.gradiant*/; //gradient is prepared for use but disabled at the moment till some other parts of gui parts are provide gradient
 	setColBodyGradient(CColorGradient::gradientLight2Dark, CFrameBuffer::gradientVertical, CColorGradient::light);
 	col_frame 	= color_frame;
-	col_body	= col_body_gradient? COL_DARK_GRAY : color_body;
+	col_body	= cc_body_gradient_enable? COL_DARK_GRAY : color_body;
 	col_shadow	= color_shadow;
 
 	cc_item_enabled  = enabled;
@@ -115,8 +115,8 @@ void CComponentsButton::initVarButton(	const int& x_pos, const int& y_pos, const
 	append_y_offset = 0;
 	corner_rad	= 0;
 	
-	cc_btn_capt_col		= col_body_gradient ? COL_BUTTON_TEXT_ENABLED : COL_INFOBAR_SHADOW_TEXT;
-	cc_btn_capt_disable_col = col_body_gradient ? COL_BUTTON_TEXT_DISABLED : COL_MENUCONTENTINACTIVE_TEXT;
+	cc_btn_capt_col		= cc_body_gradient_enable ? COL_BUTTON_TEXT_ENABLED : COL_INFOBAR_SHADOW_TEXT;
+	cc_btn_capt_disable_col = cc_body_gradient_enable ? COL_BUTTON_TEXT_DISABLED : COL_MENUCONTENTINACTIVE_TEXT;
 	cc_btn_icon_obj	= NULL;
 	cc_btn_capt_obj = NULL;
 	cc_btn_dy_font  = CNeutrinoFonts::getInstance();
@@ -175,7 +175,7 @@ void CComponentsButton::initCaption()
 		if (cc_btn_capt_obj == NULL){
 			cc_btn_capt_obj = new CComponentsLabel();
 			cc_btn_capt_obj->doPaintBg(false);
-			cc_btn_capt_obj->enableTboxSaveScreen(save_tbox_screen);
+			cc_btn_capt_obj->enableTboxSaveScreen(cc_txt_save_screen);
 			addCCItem(cc_btn_capt_obj);
 		}
 	}else{
diff --git a/src/gui/components/cc_frm_button.h b/src/gui/components/cc_frm_button.h
index 95d2a9d..4bae3bf 100644
--- a/src/gui/components/cc_frm_button.h
+++ b/src/gui/components/cc_frm_button.h
@@ -31,6 +31,7 @@
 #include "cc_frm_chain.h"
 #include "cc_item_picture.h"
 #include "cc_item_text.h"
+#include <gui/widget/icons.h>
 #include <string>
 #include <driver/neutrinofonts.h>
 #include <driver/rcinput.h>
@@ -43,7 +44,7 @@
 /*!
 Shows a button box with caption and optional icon.
 */
-class CComponentsButton : public CComponentsFrmChain
+class CComponentsButton : public CComponentsFrmChain, public CCTextScreen
 {
 	protected:
 		///object: picture object
diff --git a/src/gui/components/cc_frm_clock.cpp b/src/gui/components/cc_frm_clock.cpp
index 1db2ac0..7cf15d7 100644
--- a/src/gui/components/cc_frm_clock.cpp
+++ b/src/gui/components/cc_frm_clock.cpp
@@ -27,22 +27,23 @@
 
 #include <global.h>
 #include <neutrino.h>
-#include <driver/neutrinofonts.h>
 
 #include "cc_frm_clock.h"
 #include <time.h>
-#include <pthread.h>
+
 #include <unistd.h>
 #include <errno.h>
 #include <ctype.h>
 #include <system/helpers.h>
+#include <system/debug.h>
 
 using namespace std;
 
-
 CComponentsFrmClock::CComponentsFrmClock( 	const int& x_pos, const int& y_pos, const int& w, const int& h,
-						const char* format_str,
+						const char* prformat_str,
+						const char* secformat_str,
 						bool activ,
+						const int& interval_seconds,
 						CComponentsForm* parent,
 						bool has_shadow,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
@@ -51,45 +52,41 @@ CComponentsFrmClock::CComponentsFrmClock( 	const int& x_pos, const int& y_pos, c
 	x 		= x_pos;
 	y 		= y_pos;
 	width 		= w;
-	height	 	= h;
+	height	 	= height_old = h;
+
 	shadow		= has_shadow;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
 
-	cc_item_type 		= CC_ITEMTYPE_FRM_CLOCK;
-	corner_rad		= RADIUS_SMALL;
-
-	cl_font_type		= SNeutrinoSettings::FONT_TYPE_INFOBAR_INFO;
-	cl_font 		= &g_Font[cl_font_type];
-	dyn_font_size		= 0;
-
-	cl_col_text		= COL_MENUCONTENT_TEXT;
-	cl_format_str		= format_str;
-	cl_align		= CC_ALIGN_VER_CENTER | CC_ALIGN_HOR_CENTER;
-
-	cl_thread 		= 0;
-	cl_interval		= 1;
-
-	activeClock		= true;
-	cl_blink_str		= format_str;
-	paintClock		= false;
-
-	activeClock		= activ;
-
+	cc_item_type 	= CC_ITEMTYPE_FRM_CLOCK;
+	corner_rad	= RADIUS_SMALL;
+	cl_font		= NULL;
+	cl_font_style	= CNeutrinoFonts::FONT_STYLE_BOLD;
+	cl_col_text	= COL_MENUCONTENT_TEXT;
+	cc_txt_save_screen = true;
+	setClockFormat(prformat_str, secformat_str);
+	cl_interval	= interval_seconds;
+	cl_timer 	= NULL;
+	paintClock	= false;
+#if 0
 	may_blit		= true;
+#endif	
 
 	initCCLockItems();
 	initParent(parent);
 
-	if (activeClock)
-		startThread();
+	cl_sl = sigc::mem_fun0(*this, &CComponentsFrmClock::ShowTime);
+	
+	if (activ)
+		startClock();
 }
 
 CComponentsFrmClock::~CComponentsFrmClock()
 {
-	stopThread();
+	if (cl_timer)
+		delete cl_timer;
 }
 
 
@@ -97,8 +94,34 @@ void CComponentsFrmClock::initTimeString()
 {
 	struct tm t;
 	time_t ltime;
-	ltime=time(NULL);
-	strftime(cl_timestr, sizeof(cl_timestr), getTimeFormat(ltime), localtime_r(&ltime, &t));
+	ltime=time(&ltime);
+
+	toggleFormat();
+
+	strftime(cl_timestr, sizeof(cl_timestr), cl_format.c_str(), localtime_r(&ltime, &t));
+}
+
+//formating time string with possible blink string
+void CComponentsFrmClock::toggleFormat()
+{
+	if (cl_format_str.length() != cl_blink_str.length())
+		kill();
+	
+	if (cl_format == cl_blink_str)
+		cl_format = cl_format_str;
+	else
+		cl_format = cl_blink_str;
+}
+
+//set current time format string
+void CComponentsFrmClock::setClockFormat(const char* prformat_str, const char* secformat_str)
+{
+	cl_format_str = prformat_str;
+
+	if (secformat_str == NULL)
+		cl_blink_str = cl_format_str;
+	else
+		cl_blink_str = secformat_str;
 }
 
 // How does it works?
@@ -117,23 +140,54 @@ void CComponentsFrmClock::initTimeString()
 
 void CComponentsFrmClock::initCCLockItems()
 {
+	//prepare and set current time string
 	initTimeString();
 	string s_time = cl_timestr;
-	
-	//get minimal required height, width from raw text
-	int min_text_w = (*getClockFont())->getRenderWidth(s_time);
-	int min_text_h = (*getClockFont())->getHeight();
+
+	/*prepare and set current height
+	 * If current assigned clock height = 0, then use the current system height from settings 
+	*/
+	if (height < height_old)
+		height_old = height;
+	if (height == 0){
+		int dx = 0;
+		int dy = height = g_settings.infoClockFontSize;
+		cl_font = *CNeutrinoFonts::getInstance()->getDynFont(dx, dy, "", CNeutrinoFonts::FONT_STYLE_BOLD);
+		dprintf(DEBUG_NORMAL, "[CComponentsFrmClock]    [%s - %d]  Warning: clock height is set to 0 using defaults = [%d] ...\n", __func__, __LINE__, height);
+	}
+
+	//compare with old height and set new value if required
+	if (height_old != height)
+		height_old = height;
+
+	/*If no font was assigned, then use current height as reference for required font
+	 * and use the dynamic font mode
+	*/ 
+	if (cl_font == NULL){
+		int dx = 0;
+		int dy = height;
+		cl_font = *CNeutrinoFonts::getInstance()->getDynFont(dx, dy, "", cl_font_style);
+	}
+
+	//get minimal required height and width from raw text
+	int min_text_w = cl_font->getRenderWidth(s_time);
+	int min_text_h = cl_font->getHeight();
+
+	//set minimal required dimensions
 	height = max(height, min_text_h);
 	width = max(width, min_text_w);
 
-	int cl_x = 0;
+	//set some temporary variables
+	int cl_x = x;
 	int cl_h = min_text_h;
-	int cl_y = 0;
+	int cl_y = y;
 	int w_lbl_tmp = 0;
-	
-	//create label objects and add to container, ensure count of items = count of chars (one char = one segment)
+
+	/*create label objects and add to container, ensure count of items = count of chars (one char = one segment)
+	 * this is required for the case, if any time string format was changed
+	*/
 	if (v_cc_items.size() != s_time.size()){
-		
+
 		//clean up possible old items before add new items
 		clear();
 
@@ -141,7 +195,7 @@ void CComponentsFrmClock::initCCLockItems()
 		for (size_t i = 0; i < s_time.size(); i++){
 			CComponentsLabel * lbl = new CComponentsLabel();
 			addCCItem(lbl);
-			
+
 			//background paint of item is not required
 			lbl->doPaintBg(false);
 			
@@ -152,14 +206,17 @@ void CComponentsFrmClock::initCCLockItems()
 			lbl->setTextBorderWidth(0,0);
 		}
 	}
-	
+
 	//calculate minimal separator width, we use char size of some possible chars
 	int minSepWidth = 0;
 	string sep[] ={" ", ".", ":"};
 	for (size_t i = 0; i < sizeof(sep)/sizeof(sep[0]); i++)
-		minSepWidth = max((*getClockFont())->getRenderWidth(sep[i]), minSepWidth);
+		minSepWidth = max(cl_font->getRenderWidth(sep[i]), minSepWidth);
 
-	//modify available label items with current segment chars
+	/* modify available label items with current segment chars
+	 * we are using segments with only one char per segment,
+	 * these chars are predefined via format string 
+	*/
 	for (size_t i = 0; i < v_cc_items.size(); i++)
 	{
 		//v_cc_items are only available as CComponent-items here, so we must cast them before
@@ -181,18 +238,18 @@ void CComponentsFrmClock::initCCLockItems()
 		//get width of current segment
 		int wtmp = 0;
 		if (isdigit(stmp.at(0)) ) //check for digits, if true, we use digit width
-			wtmp = (*getClockFont())->getMaxDigitWidth();
+			wtmp = cl_font->getMaxDigitWidth();
 		else //not digit found, we use render width or minimal width
-			wtmp = max((*getClockFont())->getRenderWidth(stmp), minSepWidth);
+			wtmp = max(cl_font->getRenderWidth(stmp), minSepWidth);
 
 		//set size, text, color of current item
 		lbl->setDimensionsAll(cl_x, cl_y, wtmp, cl_h);
 		lbl->setTextColor(cl_col_text);
 		lbl->setColorAll(col_frame, col_body, col_shadow);
-		lbl->setText(stmp, CTextBox::CENTER, *getClockFont());
+		lbl->setText(stmp, CTextBox::CENTER, cl_font);
 
 		lbl->doPaintTextBoxBg(paint_bg);
-		lbl->enableTboxSaveScreen(save_tbox_screen);
+		lbl->enableTboxSaveScreen(cc_txt_save_screen);
 
 		//use matching height for digits for better vertical centerring into form
 		CTextBox* ctb = lbl->getCTextBoxObject();
@@ -203,140 +260,97 @@ void CComponentsFrmClock::initCCLockItems()
 		bool force_txt_and_bg = (lbl->textChanged() || this->paint_bg);
 		lbl->forceTextPaint(force_txt_and_bg);
 #endif
-		//set xpos of item
+		//set xpos and width of item (segment)
 		cl_x += wtmp;
-
 		lbl->setWidth(wtmp);
 
-		//set current width for form
+		//sum required width for clock (this)
 		w_lbl_tmp += wtmp;
 	}
 
-	//set required width
+	//set required width for clock (this)
 	width = max(width, w_lbl_tmp);
 
-	initSegmentAlign(&w_lbl_tmp, &min_text_h);
-}
-
-//handle alignment
-void CComponentsFrmClock::initSegmentAlign(int* segment_width, int* segment_height)
-{	
-	int wadd = 0;
-	int hadd = 0;
-	int* w_lbl_tmp = segment_width;
-	int* min_text_h = segment_height;
-
 	//use first item as reference and set x and y position to the 1st segement item with definied alignment
-	if (cl_align & CC_ALIGN_RIGHT){
-		wadd = width-*w_lbl_tmp;
-		v_cc_items[0]->setXPos(wadd);
-	}
-	else if (cl_align & CC_ALIGN_LEFT){
-		v_cc_items[0]->setXPos(wadd);
-	}
-	else if  (cl_align & CC_ALIGN_HOR_CENTER){
-		hadd = height/2-*min_text_h/2;
-		v_cc_items[0]->setYPos(hadd);
-	}
+	int x_lbl = width/2-w_lbl_tmp/2;
+	v_cc_items[0]->setXPos(x_lbl);
 
-	if (cl_align & CC_ALIGN_TOP){
-		v_cc_items[0]->setYPos(hadd);
-	}
-	else if  (cl_align & CC_ALIGN_BOTTOM){
-		hadd = height-*min_text_h;
-		v_cc_items[0]->setYPos(hadd);
-	}
-	else if  (cl_align & CC_ALIGN_VER_CENTER){
-		wadd = width/2-*w_lbl_tmp/2;
-		v_cc_items[0]->setXPos(wadd);
-	}
+	int y_lbl = height/2-min_text_h/2;
+	v_cc_items[0]->setYPos(y_lbl);
 
 	//set all evaluated position values to all other segement items
 	for (size_t i = 1; i < v_cc_items.size(); i++){
-		wadd += v_cc_items[i-1]->getWidth();
-		v_cc_items[i]->setPos(wadd, hadd);
+		x_lbl += v_cc_items[i-1]->getWidth();
+		v_cc_items[i]->setPos(x_lbl, y_lbl);
 	}
 }
 
-//thread handle
-void* CComponentsFrmClock::initClockThread(void *arg)
+
+//this member is provided for slot with timer event "OnTimer"
+void CComponentsFrmClock::ShowTime()
 {
-	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,0);
- 	pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS,0);
-
-	CComponentsFrmClock *clock = static_cast<CComponentsFrmClock*>(arg);
-	//start loop for paint
-	while (true) {
-		clock->mutex.lock();
-		if (clock->paintClock)
-			clock->paint(CC_SAVE_SCREEN_NO);
-		clock->mutex.unlock();
-		int interval = clock->cl_interval;
-		mySleep(interval);
+	if (paintClock) {
+		//paint segements, but wihtout saved backgrounds
+		paint(CC_SAVE_SCREEN_NO);
 	}
-	return 0;
 }
 
-//start up ticking clock with own thread, return true on succses
-bool CComponentsFrmClock::startThread()
+//start up ticking clock controled by timer with signal/slot, return true on succses
+bool CComponentsFrmClock::startClock()
 {
-	void *ptr = static_cast<void*>(this);
-	
-	if(!cl_thread) {
-		int res = pthread_create (&cl_thread, NULL, initClockThread, ptr) ;
-		if (res != 0){
-			printf("[CComponentsFrmClock]    [%s]  pthread_create  %s\n", __func__, strerror(errno));
-			return false;
-		}
-		pthread_detach(cl_thread);
+	if (cl_interval <= 0){
+		dprintf(DEBUG_NORMAL, "[CComponentsFrmClock]    [%s]  clock is set to active, but interval is initialized with value %d ...\n", __func__, cl_interval);
+		return false;
+	}
+
+	if (cl_timer == NULL){
+		cl_timer = new CComponentsTimer();
+		dprintf(DEBUG_INFO, "[CComponentsFrmClock]    [%s]  init slot...\n", __func__);
+		cl_timer->OnTimer.connect(cl_sl);
 	}
-	return  true;
+	cl_timer->setTimerIntervall(cl_interval);
+
+	if (cl_timer->isRun())
+		return true;
+	
+	return  false;
 }
 
-//stop ticking clock and kill thread, return true on succses
-bool CComponentsFrmClock::stopThread()
+//stop ticking clock and internal timer, return true on succses
+bool CComponentsFrmClock::stopClock()
 {
-	if(cl_thread) {
-		int res = pthread_cancel(cl_thread);
-		if (res != 0){
-			printf("[CComponentsFrmClock]    [%s] pthread_cancel  %s\n", __func__, strerror(errno));
-			return false;
+	if (cl_timer){
+		if (cl_timer->stopTimer()){
+			dprintf(DEBUG_INFO, "[CComponentsFrmClock]    [%s]  stopping clock...\n", __func__);
+			delete cl_timer;
+			cl_timer = NULL;
+			return true;
 		}
-#if 0
-		res = pthread_join(cl_thread, NULL);
-		if (res != 0){
-			printf("[CComponentsFrmClock]    [%s] pthread_join  %s\n", __func__, strerror(errno));
-			return false;
-		}
-#endif
+		else
+			dprintf(DEBUG_NORMAL, "[CComponentsFrmClock]    [%s]  stopping timer failed...\n", __func__);
 	}
-	hide();
-	cl_thread = 0;
-	return true;
+	return false;
 }
 
 bool CComponentsFrmClock::Start(bool do_save_bg)
 {
-	if (!activeClock)
-		return false;
-	if (!cl_thread)
-		startThread();
-	if (cl_thread) {
+	if (startClock()) {
 		//ensure paint of segements on first paint
 		paint(do_save_bg);
 		paintClock = true;
+		return true;
 	}
-	return cl_thread == 0 ? false : true;
+	return false;
 }
 
 bool CComponentsFrmClock::Stop()
 {
-	if (!activeClock)
-		return false;
-	mutex.lock();
-	paintClock = false;
-	mutex.unlock();
-	return cl_thread == 0 ? false : true;
+	if (stopClock()){
+		paintClock = false;
+		return true;
+	}
+
+	return false;
 }
 
 void CComponentsFrmClock::paint(bool do_save_bg)
@@ -345,38 +359,38 @@ void CComponentsFrmClock::paint(bool do_save_bg)
 	initCCLockItems();
 
 	//paint form contents
-	paintForm(do_save_bg);
-
+	CComponentsForm::paint(do_save_bg);
+#if 0 //has no effect
 	if (may_blit)
 		frameBuffer->blit();
+#endif
 }
 
-void CComponentsFrmClock::setClockFontSize(int font_size)
+void CComponentsFrmClock::setClockFont(Font *font, const int& style)
 {
-	int tmp_w = 0;
-	dyn_font_size = font_size;
-	cl_font	= CNeutrinoFonts::getInstance()->getDynFont(tmp_w, dyn_font_size, "", CNeutrinoFonts::FONT_STYLE_BOLD, CNeutrinoFonts::FONT_ID_INFOCLOCK);
+	cl_font = font;
+	if (style != -1)
+		cl_font_style = style;
+	initCCLockItems();
 }
 
-void CComponentsFrmClock::setClockFont(int font)
+Font* CComponentsFrmClock::getClockFont()
 {
-	cl_font_type = font;
-	cl_font      = &g_Font[cl_font_type];
+	return cl_font;
 }
 
-Font** CComponentsFrmClock::getClockFont()
+void CComponentsFrmClock::kill(const fb_pixel_t& bg_color, bool ignore_parent)
 {
-	if (dyn_font_size == 0)
-		cl_font = &g_Font[cl_font_type];
-	return cl_font;
-
+	Stop();
+	CComponentsForm::kill(bg_color, ignore_parent);
 }
 
-void CComponentsFrmClock::setClockActiv(bool activ/* = true*/)
+void CComponentsFrmClock::enableSegmentSaveScreen(bool mode)
 {
-	activeClock = activ;
-	if (activ && !cl_thread)
-		startThread();
-	if (!activ && cl_thread)
-		stopThread();
+	if (cc_txt_save_screen == mode || v_cc_items.empty())
+		return;
+
+	cc_txt_save_screen = mode;
+	for (size_t i = 0; i < v_cc_items.size(); i++)
+		static_cast <CComponentsLabel*>(v_cc_items[i])->enableTboxSaveScreen(cc_txt_save_screen);
 }
diff --git a/src/gui/components/cc_frm_clock.h b/src/gui/components/cc_frm_clock.h
index 64e6a63..8f7170d 100644
--- a/src/gui/components/cc_frm_clock.h
+++ b/src/gui/components/cc_frm_clock.h
@@ -31,120 +31,128 @@
 #include <config.h>
 #endif
 
-#include <OpenThreads/ScopedLock>
-#include <OpenThreads/Thread>
-#include <OpenThreads/Condition>
-
+#include <driver/neutrinofonts.h>
 #include "cc_base.h"
 #include "cc_frm.h"
-
-
+#include "cc_timer.h"
+#include "cc_text_screen.h"
 //! Sub class of CComponents. Show clock with digits on screen. 
 /*!
 Usable as simple fixed display or as ticking clock.
 */
 
-class CComponentsFrmClock : public CComponentsForm
+class CComponentsFrmClock : public CComponentsForm, public CCTextScreen
 {
 	private:
-		
-// 		bool cl_force_segment_paint;
+		CComponentsTimer *cl_timer;
+		void ShowTime();
+		int height_old;
+#if 0
 		bool may_blit;
-	
+#endif
+
 	protected:
-		///thread
-		pthread_t  cl_thread;
+		///slot for timer event, reserved for ShowTime()
+		sigc::slot0<void> cl_sl;
+
 		///refresh interval in seconds
 		int cl_interval;
-		///init function to start clock in own thread
-		static void* initClockThread(void *arg);
 
 		///raw time chars
 		char cl_timestr[20];
 
 		///handle paint clock within thread and is not similar to cc_allow_paint
 		bool paintClock;
-		//TODO: please add comments!
-		bool activeClock;
 
 		///object: font render object
-		Font **cl_font;
-
-		int cl_font_type;
-		int dyn_font_size;
+		Font *cl_font;
+		int cl_font_style;
 
 		///text color
 		int cl_col_text;
-		///time format
-		const char *cl_format_str;
-		///time format for blink
-		const char *cl_blink_str;
-		///time string align, default align is ver and hor centered
-		int cl_align;
+
+		///current time format
+		std::string cl_format;
+		///primary time format
+		std::string cl_format_str;
+		///secondary time format for blink
+		std::string cl_blink_str;
 
 		///initialize clock contents  
 		void initCCLockItems();
 		///initialize timestring, called in initCCLockItems()
 		virtual void initTimeString();
-		///initialize of general alignment of timestring segments within form area
-		void initSegmentAlign(int* segment_width, int* segment_height);
-		//return current time string format
-		const char *getTimeFormat(time_t when) { return (when & 1) ? cl_format_str : cl_blink_str; }
+
+		///start ticking clock, returns true on success, if false causes log output
+		bool startClock();
+		///stop ticking clock, returns true on success, if false causes log output
+		bool stopClock();
+		///switch between primary and secondary format
+		void toggleFormat();
 
 		///return pointer of font object
-		inline Font** getClockFont();
+		Font* getClockFont();
 
 	public:
-		OpenThreads::Mutex mutex;
 
-		CComponentsFrmClock( 	const int& x_pos = 1, const int& y_pos = 1, const int& w = 200, const int& h = 48,
+		CComponentsFrmClock( 	const int& x_pos = 1, const int& y_pos = 1, const int& w = 0, const int& h = 0,
 					const char* format_str = "%H:%M",
+					const char* secformat_str = NULL,
 					bool activ=false,
+					const int& interval_seconds = 1,
 					CComponentsForm *parent = NULL,
 					bool has_shadow = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 		virtual ~CComponentsFrmClock();
 
-		///set font type or font size for segments
-		virtual void setClockFont(int font);
-		virtual void setClockFontSize(int font_size);
+		/*! Sets font type for clock segments.
+		 * 1st parameter expects a pointer to font type, usually a type from the global g_Font collection, but also possible 
+		 * are dynamic font.
+		 * The use of NULL pointer enforces dynamic font.
+		 * 2nd paramter is relevant for dynamic fonts only, you can use the enum types
+		 * - FONT_STYLE_REGULAR
+		 * - FONT_STYLE_BOLD
+		 * - FONT_STYLE_ITALIC
+		 * (see /.src/driver/neutrinofonts.h)
+		*/
+		virtual void setClockFont(Font * font, const int& style = -1);
 
 		///set text color
 		virtual void setTextColor(fb_pixel_t color_text){ cl_col_text = color_text;};
 
-		///set alignment of timestring, possible modes see align types in cc_types.h 
-		virtual void setClockAlignment(int align_type){cl_align = align_type;};
-
 		///use string expession: "%H:%M" = 12:22, "%H:%M:%S" = 12:22:12
-		virtual void setClockFormat(const char* format_str){cl_format_str = format_str;};
-
-		///time format for blink ("%H %M", "%H:%M %S" etc.)
-		virtual void setClockBlink(const char* format_str){cl_blink_str = format_str;};
-
-		///start ticking clock thread, returns true on success, if false causes log output
-		virtual bool startThread();
-		///stop ticking clock thread, returns true on success, if false causes log output
-		virtual bool stopThread();
+		///set current time format string, 1st parameter set the default format, 2nd parameter sets an alternatively format for use as blink effect
+		virtual void setClockFormat(const char* prformat_str, const char* secformat_str = NULL);
 
+		///start and paint ticking clock
 		virtual bool Start(bool do_save_bg = CC_SAVE_SCREEN_NO);
+		///same like Start() but for usage as simple call without return value
+		virtual void unblock(/*bool do_save_bg = CC_SAVE_SCREEN_NO*/){Start(/*do_save_bg*/);}
+		///stop ticking clock, but don't hide, use kill() or hide() to remove from screen
 		virtual bool Stop();
+		///same like Stop() but for usage as simple call without return value
+		virtual void block(){Stop();}
 
-		///returns true, if clock is running in thread
-		virtual bool isClockRun() const {return cl_thread == 0 ? false:true;};
+		///returns true, if clock is running
+		virtual bool isRun() const {return cl_timer ? true : false;};
 		///set refresh interval in seconds, default value=1 (=1 sec)
 		virtual void setClockIntervall(const int& seconds){cl_interval = seconds;};
 
 		///show clock on screen
 		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
+		///hide clock on screen
+		virtual void hide(){Stop(); CComponentsForm::hide();}
+		///does the same like kill() from base class, but stopping clock before kill
+		void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, bool ignore_parent = false);
 
 		///reinitialize clock contents
 		virtual void refresh() { initCCLockItems(); }
-
-		///set clock activ/inactiv
-		virtual void setClockActiv(bool activ = true);
-
+		///allows to save bg screen behind text within segment objects, see also cl_save_segment_screen
+		void enableSegmentSaveScreen(bool mode);
+#if 0
 		///enable/disable automatic blitting
 		void setBlit(bool _may_blit = true) { may_blit = _may_blit; }
+#endif
 };
 
 #endif
diff --git a/src/gui/components/cc_frm_ext_text.cpp b/src/gui/components/cc_frm_ext_text.cpp
index 49b0613..74c989b 100644
--- a/src/gui/components/cc_frm_ext_text.cpp
+++ b/src/gui/components/cc_frm_ext_text.cpp
@@ -105,7 +105,7 @@ void CComponentsExtTextForm::initLabel()
 	if (ccx_label_obj == NULL){
 		ccx_label_obj = new CComponentsLabel();
 		ccx_label_obj->doPaintBg(false);
-		ccx_label_obj->enableTboxSaveScreen(save_tbox_screen);
+		ccx_label_obj->enableTboxSaveScreen(cc_txt_save_screen);
 	}	
 
 	//add label object
@@ -128,7 +128,7 @@ void CComponentsExtTextForm::initText()
 	if (ccx_text_obj == NULL){
 		ccx_text_obj = new CComponentsText();
 		ccx_text_obj->doPaintBg(false);
-		ccx_text_obj->enableTboxSaveScreen(save_tbox_screen);
+		ccx_text_obj->enableTboxSaveScreen(cc_txt_save_screen);
 	}
 
 	//add text object
@@ -161,12 +161,12 @@ void CComponentsExtTextForm::setLabelAndText(const neutrino_locale_t& locale_lab
 	setLabelAndText(g_Locale->getText(locale_label_text), g_Locale->getText(locale_text), font_text);
 }
 
-void CComponentsExtTextForm::setLabelAndTexts(const string_ext_txt_t& texts)
+void CComponentsExtTextForm::setLabelAndTexts(const cc_string_ext_txt_t& texts)
 {
 	setLabelAndText(texts.label_text, texts.text, texts.font);
 }
 
-void CComponentsExtTextForm::setLabelAndTexts(const locale_ext_txt_t& locale_texts)
+void CComponentsExtTextForm::setLabelAndTexts(const cc_locale_ext_txt_t& locale_texts)
 {
 	setLabelAndText(g_Locale->getText(locale_texts.label_text), g_Locale->getText(locale_texts.text), locale_texts.font);
 }
diff --git a/src/gui/components/cc_frm_ext_text.h b/src/gui/components/cc_frm_ext_text.h
index 66a2172..99b8a4b 100644
--- a/src/gui/components/cc_frm_ext_text.h
+++ b/src/gui/components/cc_frm_ext_text.h
@@ -28,7 +28,7 @@
 #include "cc_item_text.h"
 
 
-class CComponentsExtTextForm : public CComponentsForm
+class CComponentsExtTextForm : public CComponentsForm, public CCTextScreen
 {
 	private:
 		///property: content of label, see also setLabelAndText()
@@ -94,10 +94,10 @@ class CComponentsExtTextForm : public CComponentsForm
 		///assigns text Font type
 		void setLabelAndTextFont(Font* font);
 
-		///assigns texts for label and text, parameter as struct (locale_ext_txt_t), parameters provide the same properties like setLabelAndText()
-		void setLabelAndTexts(const locale_ext_txt_t& texts);
-		///assigns texts for label and text, parameter as struct (string_ext_txt_t), parameters provide the same properties like setLabelAndText()
-		void setLabelAndTexts(const string_ext_txt_t& locale_texts);
+		///assigns texts for label and text, parameter as struct (cc_locale_ext_txt_t), parameters provide the same properties like setLabelAndText()
+		void setLabelAndTexts(const cc_locale_ext_txt_t& texts);
+		///assigns texts for label and text, parameter as struct (cc_string_ext_txt_t), parameters provide the same properties like setLabelAndText()
+		void setLabelAndTexts(const cc_string_ext_txt_t& locale_texts);
 
 		///assigns colors for text for label text, parameter as fb_pixel_t
 		void setLabelAndTextColor(const fb_pixel_t label_color , const fb_pixel_t text_color);
diff --git a/src/gui/components/cc_frm_footer.cpp b/src/gui/components/cc_frm_footer.cpp
index 369e3d0..ad8a97a 100644
--- a/src/gui/components/cc_frm_footer.cpp
+++ b/src/gui/components/cc_frm_footer.cpp
@@ -76,7 +76,7 @@ void CComponentsFooter::initVarFooter(	const int& x_pos, const int& y_pos, const
 	col_frame	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
-	col_body_gradient		= false; /*g_settings.theme.Foot_gradient*/; //TODO: not implemented at the moment
+	cc_body_gradient_enable		= g_settings.theme.menu_ButtonBar_gradient; //TODO: not complete implemented at the moment
 	cc_body_gradient_direction	= CFrameBuffer::gradientVertical;
 	cc_body_gradient_mode		= CColorGradient::gradientDark2Light;
 	btn_auto_frame_col	= false;
diff --git a/src/gui/components/cc_frm_header.cpp b/src/gui/components/cc_frm_header.cpp
index 59359b7..c25d273 100644
--- a/src/gui/components/cc_frm_header.cpp
+++ b/src/gui/components/cc_frm_header.cpp
@@ -33,6 +33,12 @@
 using namespace std;
 
 //-------------------------------------------------------------------------------------------------------
+
+//	x/y	    width
+//	+---------------------------------------------------------+
+//	||icon |caption                    |clock|context buttons||height
+//	+---------------------------------------------------------+
+
 //sub class CComponentsHeader inherit from CComponentsForm
 CComponentsHeader::CComponentsHeader(CComponentsForm* parent)
 {
@@ -98,7 +104,7 @@ void CComponentsHeader::initVarHeader(	const int& x_pos, const int& y_pos, const
 	col_body	= color_body;
 	col_shadow	= color_shadow;
 	col_body 	= COL_MENUHEAD_PLUS_0;
-	col_body_gradient		= g_settings.theme.menu_Head_gradient;
+	cc_body_gradient_enable		= g_settings.theme.menu_Head_gradient;
 	cc_body_gradient_direction	= CFrameBuffer::gradientVertical;
 	cc_body_gradient_mode		= CColorGradient::gradientLight2Dark;
 	cch_text	= caption;
@@ -110,15 +116,22 @@ void CComponentsHeader::initVarHeader(	const int& x_pos, const int& y_pos, const
 	cch_icon_obj		= NULL;
 	cch_text_obj		= NULL;
 	cch_btn_obj		= NULL;
+	cch_cl_obj		= NULL;
 	cch_col_text		= COL_MENUHEAD_TEXT;
 	cch_caption_align	= CTextBox::NO_AUTO_LINEBREAK;
 	cch_items_y 		= CC_CENTERED;
 	cch_offset		= 8;
 	cch_icon_x 		= cch_offset;
 	cch_icon_w		= 0;
+	cch_clock_w		= 0;
 	cch_text_x		= cch_offset;
 	cch_buttons_space	= cch_offset;
 
+	cch_cl_enable 		= false;
+	cch_cl_format		= "%H:%M";
+	cch_cl_sec_format 	= cch_cl_format;
+	cch_cl_enable_run	= false;
+
 	addContextButton(buttons);
 	initCCItems();
 	initParent(parent);
@@ -130,16 +143,18 @@ CComponentsHeader::~CComponentsHeader()
 	v_cch_btn.clear();
 }
 
-void CComponentsHeader::setCaption(const std::string& caption, const int& align_mode)
+void CComponentsHeader::setCaption(const std::string& caption, const int& align_mode, const fb_pixel_t& text_color)
 {
 	cch_text		= caption;
 	cch_caption_align 	= align_mode;
+	cch_col_text 		= text_color;
 }
 
-void CComponentsHeader::setCaption(neutrino_locale_t caption_locale, const int& align_mode)
+void CComponentsHeader::setCaption(neutrino_locale_t caption_locale, const int& align_mode, const fb_pixel_t& text_color)
 {
-	cch_text		= g_Locale->getText(caption_locale);
-	cch_caption_align 	= align_mode;
+	if (cch_cl_obj)
+		cch_cl_obj->Stop();
+	setCaption(string(g_Locale->getText(caption_locale)), align_mode, text_color);
 }
 
 void CComponentsHeader::setCaptionFont(Font* font)
@@ -226,7 +241,7 @@ void CComponentsHeader::initIcon()
 		//global adapt height
 		height = max(height, cch_icon_obj->getHeight());
 
-// 		//re-align height of icon object
+//		//re-assign height of icon object, for the case of changed height
 // 		cch_icon_obj->setHeight(height);
 	}
 }
@@ -310,7 +325,7 @@ void CComponentsHeader::initButtons()
 
 	//set button form properties
 	if (cch_btn_obj){
-		cch_btn_obj->setDimensionsAll(0, cch_items_y, 0, 0);
+		cch_btn_obj->setYPos(cch_items_y);
 		cch_btn_obj->doPaintBg(false);
 		cch_btn_obj->setAppendOffset(cch_buttons_space, 0);
 		cch_btn_obj->removeAllIcons();
@@ -336,6 +351,71 @@ void CComponentsHeader::initButtons()
 	}
 }
 
+
+void CComponentsHeader::enableClock(bool enable, const char* format, const char* sec_format_str, bool run)
+{
+	cch_cl_enable	= enable;
+	cch_cl_format 	= format;
+	if (sec_format_str)
+		cch_cl_sec_format = sec_format_str;
+	cch_cl_enable_run 	= run;
+	if (!enable){
+		if (cch_cl_obj){
+			cch_cl_enable_run = false;
+			removeCCItem(cch_cl_obj);
+			cch_cl_obj = NULL;
+		}
+	}
+	initCCItems();
+}
+
+
+void CComponentsHeader::disableClock()
+{
+	enableClock(false, cch_cl_format, cch_cl_sec_format, false);
+}
+
+void CComponentsHeader::initClock()
+{
+	//create instance for header clock object and add to container
+	if (cch_cl_obj == NULL){
+		dprintf(DEBUG_DEBUG, "[CComponentsHeader]\n    [%s - %d] init clock...\n", __func__, __LINE__);
+		cch_cl_obj = new CComponentsFrmClock(0, cch_items_y, 0, height, cch_cl_format, NULL, false, 1, this);
+		cch_cl_obj->doPaintBg(false);
+	}
+
+	//set clock form properties
+	if (cch_cl_obj){
+		cch_cl_obj->setYPos(cch_items_y);
+		cch_cl_obj->setHeight(height);
+
+		//disallow paint of clock, if disabled and exit method
+		if (!cch_cl_enable){
+			cch_cl_obj->allowPaint(false);
+			cch_cl_obj->Stop();
+			return;
+		}
+
+		//assign time size and format
+		cch_cl_obj->setClockFont(cch_font);
+		cch_cl_obj->setClockFormat(cch_cl_format, cch_cl_sec_format);
+
+		//set corner mode of button item
+		int cc_btn_corner_type = corner_type;
+		if (corner_type == CORNER_TOP_RIGHT || corner_type == CORNER_TOP)
+			cc_btn_corner_type = CORNER_TOP_RIGHT;
+		else
+			cc_btn_corner_type = CORNER_RIGHT;
+		cch_cl_obj->setCorner(corner_rad-fr_thickness, cc_btn_corner_type);
+
+		//global adapt height
+		height = max(height, cch_cl_obj->getHeight());
+
+		//re-assign height of clock object, for the case of changed height
+		cch_cl_obj->setHeight(height);
+	}
+}
+
 void CComponentsHeader::initCaption()
 {
 	//recalc header text position if header icon is defined
@@ -346,42 +426,75 @@ void CComponentsHeader::initCaption()
 
 	//calc width of text object in header
 	cc_text_w = width-cch_text_x-cch_offset;
+
+	//context buttons
 	int buttons_w = 0;
 	if (cch_btn_obj){
 		//get width of buttons object
-		buttons_w = cch_btn_obj->getWidth();
+		buttons_w = cch_btn_obj->empty() ? 0 : cch_btn_obj->getWidth();
+		dprintf(DEBUG_DEBUG, "[CComponentsHeader]\n    [%s - %d] init context buttons...x=%d, y=%d, width=%d, height=%d\n", __func__, __LINE__, cch_btn_obj->getXPos(), cch_btn_obj->getYPos(), cch_btn_obj->getWidth(), cch_btn_obj->getHeight());
 		//set x position of buttons
 		cch_btn_obj->setXPos(width - buttons_w);
+
+		//set required width of caption object
+		cc_text_w -= (buttons_w + cch_offset);
+	}
+
+	//clock
+	if (cch_cl_obj){
+		//refresh clock properties
+		cch_cl_obj->refresh();
+
+		//get width of clock object
+		int clock_w = cch_cl_enable ? cch_cl_obj->getWidth() : 0;
+
+		//set x position of clock
+		cch_cl_obj->setXPos(width - buttons_w - clock_w - cch_offset);
+
+		//set required width of caption object
+		cc_text_w -= (clock_w + cch_offset);
+
+		//stop clock if disabled or option run is disabled and clock is running
+		if (cch_cl_enable){
+			if (!cch_cl_enable_run  && cch_cl_obj->isRun()){
+				cch_cl_obj->Stop();
+				cch_cl_obj->allowPaint(false);
+			}
+		}
+
+		//clock visible or not visible if run or not
+		cch_cl_obj->allowPaint(cch_cl_enable);
 	}
-	//set required width of caption object
-	cc_text_w -= buttons_w-cch_offset;
+
 
 	//create cch_text_obj and add to collection
 	if (cch_text_obj == NULL){
 		dprintf(DEBUG_DEBUG, "[CComponentsHeader]\n    [%s - %d] init header text: %s [ x %d w %d ]\n", __func__, __LINE__, cch_text.c_str(), cch_text_x, cc_text_w);
-		cch_text_obj = new CComponentsText();
+		cch_text_obj = new CComponentsText(this);
 	}
 
-	//add text item
-	if (!cch_text_obj->isAdded())
-		addCCItem(cch_text_obj); //text
-
 	//set header text properties
 	if (cch_text_obj){
-			//set alignment of text item in dependency from text alignment
+		//set alignment of text item in dependency from text alignment
 		if (cch_caption_align == CTextBox::CENTER)
 			cch_text_x = CC_CENTERED;
+
+		//assign general properties
 		cch_text_obj->setDimensionsAll(cch_text_x, cch_items_y, cc_text_w, height);
 		cch_text_obj->doPaintBg(false);
 		cch_text_obj->setText(cch_text, cch_caption_align, cch_font);
 		cch_text_obj->forceTextPaint(); //here required
 		cch_text_obj->setTextColor(cch_col_text);
 		cch_text_obj->setColorBody(col_body);
-		cch_text_obj->enableTboxSaveScreen(save_tbox_screen);
+		cch_text_obj->enableTboxSaveScreen(cc_txt_save_screen);
 
 		//corner of text item
 		cch_text_obj->setCorner(corner_rad-fr_thickness, corner_type);
 
+		//synchronize clock color with caption color
+		if (cch_cl_obj)
+			cch_cl_obj->setTextColor(cch_col_text);
+
 		/*
 		   global adapt height not needed here again
 		   because this object is initialized at last
@@ -392,6 +505,9 @@ void CComponentsHeader::initCaption()
 
 void CComponentsHeader::initCCItems()
 {
+	//set basic properties
+	Init(x, y, width, height, col_frame, col_body, col_shadow);
+
 	//set size
 	initCaptionFont();
 
@@ -401,6 +517,9 @@ void CComponentsHeader::initCCItems()
 	//init buttons
 	initButtons();
 
+	//init clock
+	initClock();
+
 	//init text
 	initCaption();
 }
@@ -412,4 +531,10 @@ void CComponentsHeader::paint(bool do_save_bg)
 	
 	//paint form contents
 	paintForm(do_save_bg);
+
+	//start clock if enabled
+	if (cch_cl_obj){
+		if (cch_cl_enable && cch_cl_enable_run)
+			cch_cl_obj->Start();
+	}
 }
diff --git a/src/gui/components/cc_frm_header.h b/src/gui/components/cc_frm_header.h
index a551546..a385438 100644
--- a/src/gui/components/cc_frm_header.h
+++ b/src/gui/components/cc_frm_header.h
@@ -29,13 +29,14 @@
 #include "cc_item_picture.h"
 #include "cc_item_text.h"
 #include "cc_frm_icons.h"
+#include "cc_frm_clock.h"
 #include <driver/colorgradient.h>
 
 //! Sub class of CComponentsForm. Shows a header with prepared items.
 /*!
 CComponentsHeader provides prepared items like icon, caption and context button icons, mostly for usage in menues or simple windows
 */
-class CComponentsHeader : public CComponentsForm
+class CComponentsHeader : public CComponentsForm, public CCTextScreen
 {
 	private:
 		///member: init genaral variables, parameters for mostly used properties
@@ -56,6 +57,8 @@ class CComponentsHeader : public CComponentsForm
 		CComponentsText * cch_text_obj;
 		///object: context button object, see also addContextButton(), removeContextButtons()
 		CComponentsIconForm * cch_btn_obj;
+		///object: clock object
+		CComponentsFrmClock * cch_cl_obj;
 
 		///property: caption text, see also setCaption()
 		std::string cch_text;
@@ -72,6 +75,8 @@ class CComponentsHeader : public CComponentsForm
 		int cch_icon_x;
 		///property: internal width for icon object
 		int cch_icon_w;
+		///property: internal width for clock object
+		int cch_clock_w;
 		///property: internal x-position for caption object
 		int cch_text_x;
 		///property: internal offset of context button icons within context button object
@@ -84,6 +89,14 @@ class CComponentsHeader : public CComponentsForm
 		int cch_size_mode;
 		///property: alignment of caption within header, see also setCaptionAlignment(), possible values are CTextBox::CENTER, default = CTextBox::NO_AUTO_LINEBREAK (left)
 		int cch_caption_align;
+		///property: enable/disable of clock, see also enableClock()
+		bool cch_cl_enable;
+		///property: clock format
+		const char* cch_cl_format;
+		///property: secondary clock format
+		const char* cch_cl_sec_format;
+		///property: enable running clock
+		bool cch_cl_enable_run;
 
 		///init font object and recalculates height if required
 		void initCaptionFont(Font* font = NULL);
@@ -93,6 +106,8 @@ class CComponentsHeader : public CComponentsForm
 		void initCaption();
 		///sub: init context button object
 		void initButtons();
+		///sub: init clock object
+		void initClock();
 
 	public:
 		enum
@@ -116,9 +131,9 @@ class CComponentsHeader : public CComponentsForm
 		virtual ~CComponentsHeader();
 
 		///set caption text, parameters: string, int align_mode (default left) 
-		virtual void setCaption(const std::string& caption, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK);
+		virtual void setCaption(const std::string& caption, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK, const fb_pixel_t& text_color = COL_MENUHEAD_TEXT);
 		///set caption text, parameters: loacle, int align_mode (default left)
-		virtual void setCaption(neutrino_locale_t caption_locale, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK);
+		virtual void setCaption(neutrino_locale_t caption_locale, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK, const fb_pixel_t& text_color = COL_MENUHEAD_TEXT);
 
 		///set alignment of caption within header, possible paramters are CTextBox::CENTER, CTextBox::NO_AUTO_LINEBREAK
 		virtual void setCaptionAlignment(const int& align_mode){cch_caption_align = align_mode;};
@@ -181,7 +196,7 @@ class CComponentsHeader : public CComponentsForm
 		};
 
 		///set offset between icons within context button object
-		virtual void setButtonsSpace(const int buttons_space){cch_buttons_space = buttons_space;};
+		virtual void setButtonsSpace(const int buttons_space){cch_buttons_space = buttons_space;}
 
 		enum
 		{
@@ -189,15 +204,28 @@ class CComponentsHeader : public CComponentsForm
 			CC_HEADER_SIZE_SMALL 	= 1
 		};
 		///set size of header, possible values are CC_HEADER_SIZE_LARGE, CC_HEADER_SIZE_SMALL
-		virtual void setSizeMode(const int& size_mode){cch_size_mode = size_mode; initCCItems();};
+		virtual void setSizeMode(const int& size_mode){cch_size_mode = size_mode; initCCItems();}
 
 		///init all items within header object
 		virtual void initCCItems();
 		///returns the text object
-		virtual CComponentsText* getTextObject(){return cch_text_obj;};
+		virtual CComponentsText* getTextObject(){return cch_text_obj;}
+
+		///returns the clock object
+		virtual CComponentsFrmClock* getClockObject(){return cch_cl_obj;}
+
+		///enable display of clock, parameter bool enable, const char* format, bool run
+		virtual void enableClock(bool enable = true, const char* format = "%H:%M", const char* sec_format_str = NULL, bool run = false);
+		///disable clock, without parameter
+		virtual void disableClock();
 
 		///paint header
 		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
+
+		///hides item, arg: no_restore see hideCCItem()
+		void hide(){disableClock(); CComponents::hide();}
+		///erase current screen without restore of background, it's similar to paintBackgroundBoxRel() from CFrameBuffer
+		virtual void kill(){disableClock(); CComponentsForm::kill();}
 };
 
 //! Sub class of CComponentsHeader.
diff --git a/src/gui/components/cc_frm_scrollbar.cpp b/src/gui/components/cc_frm_scrollbar.cpp
index 464c503..d290db5 100644
--- a/src/gui/components/cc_frm_scrollbar.cpp
+++ b/src/gui/components/cc_frm_scrollbar.cpp
@@ -165,12 +165,12 @@ void CComponentsScrollBar::initSegments()
 		//set color for marked id
 		if (sb_mark_id == id){
 			item->setColorBody(COL_MENUCONTENTSELECTED_PLUS_0);
-			item->enableColBodyGradient(true);
+			item->enableColBodyGradient(CC_COLGRAD_COL_A_2_COL_B);
 			item->setColBodyGradient(CColorGradient::gradientDark2Light2Dark, CFrameBuffer::gradientHorizontal);
 		}
 		else{
 			item->setColorBody(COL_MENUCONTENT_PLUS_1);
-			item->enableColBodyGradient(false);
+			item->disableColBodyGradient();
 		}
 	}
 
diff --git a/src/gui/components/cc_frm_signalbars.cpp b/src/gui/components/cc_frm_signalbars.cpp
index 8af1782..614b561 100644
--- a/src/gui/components/cc_frm_signalbars.cpp
+++ b/src/gui/components/cc_frm_signalbars.cpp
@@ -143,6 +143,8 @@ void CSignalBar::initSBarValue()
 	if (sb_vlbl == NULL){
 		sb_vlbl = new CComponentsLabel();
 		sb_vlbl->doPaintBg(false);
+		sb_vlbl->doPaintTextBoxBg(false);
+		sb_vlbl->enableTboxSaveScreen(true);
 		sb_vlbl->setText("  0%", sb_val_mode, sb_font);
 	}
 
@@ -167,9 +169,9 @@ void CSignalBar::initSBarName()
 	if (sb_lbl == NULL){
 		sb_lbl = new CComponentsLabel();
 		sb_lbl->doPaintBg(false);
+		sb_lbl->doPaintTextBoxBg(false);
+		sb_lbl->enableTboxSaveScreen(true);
 		sb_lbl->setText(sb_name, CTextBox::NO_AUTO_LINEBREAK | CTextBox::RIGHT, sb_font);
-		sb_lbl->forceTextPaint();
-		sb_lbl->doPaintTextBoxBg(true);
 	}
 
 	//move and set dimensions
@@ -182,6 +184,7 @@ void CSignalBar::initSBarName()
 	sb_lbl->setTextColor(sb_caption_color);
 	sb_lbl->setColorBody(col_body);
 
+
 	//add name label object to container
 	if (!sb_lbl->isAdded())
 		addCCItem(sb_lbl);
@@ -218,12 +221,6 @@ void CSignalBar::paintScale()
 		percent += "%";
 		sb_vlbl->setText(percent, sb_val_mode, sb_font);
 
-		//we must force paint backround, because of changing values
-		sb_vlbl->doPaintBg(true);
-		sb_vlbl->forceTextPaint();
-		sb_vlbl->doPaintTextBoxBg(true);
-		sb_vlbl->setColorBody(col_body);
-
 		//repaint labels
 		for(size_t i=0; i<this->v_cc_items.size(); i++)
 			v_cc_items[i]->paint(false);
diff --git a/src/gui/components/cc_item.cpp b/src/gui/components/cc_item.cpp
index 2c2b158..45aa875 100644
--- a/src/gui/components/cc_item.cpp
+++ b/src/gui/components/cc_item.cpp
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2014, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
 	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -18,10 +18,8 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifdef HAVE_CONFIG_H
@@ -30,7 +28,7 @@
 
 #include <global.h>
 #include <neutrino.h>
-#include "cc_base.h"
+#include "cc_item.h"
 #include <driver/screen_max.h>
 #include <system/debug.h>
 #include <cs_api.h>
@@ -46,19 +44,12 @@ using namespace std;
 //abstract sub class CComponentsItem from CComponents
 CComponentsItem::CComponentsItem(CComponentsForm* parent)
 {
-	cc_item_type 		= CC_ITEMTYPE_BASE;
+	cc_item_type 		= CC_ITEMTYPE_GENERIC;
 	cc_item_index 		= CC_NO_INDEX;
 	cc_item_enabled 	= true;
 	cc_item_selected 	= false;
 	cc_page_number		= 0;
 	cc_has_focus		= true;
-	cc_gradientData.gradientBuf = NULL;
-	cc_body_gradient_mode 	= CColorGradient::gradientLight2Dark;
-	cc_body_gradient_intensity = CColorGradient::light;
-	cc_body_gradient_intensity_v_min = 0x40;
-	cc_body_gradient_intensity_v_max = 0xE0;
-	cc_body_gradient_saturation = 0xC0;
-	cc_body_gradient_direction = CFrameBuffer::gradientVertical;
 	initParent(parent);
 }
 
@@ -69,86 +60,60 @@ void CComponentsItem::initParent(CComponentsForm* parent)
 		cc_parent->addCCItem(this);
 }
 
-// Paint container background in cc-items with shadow, background and frame.
+// init container properties in cc-items for shadow, background and frame.
 // This member must be called first in all paint() members before paint other items into the container.
 // If backround is not required, it's possible to override this with variable paint_bg=false, use doPaintBg(true/false) to set this!
 void CComponentsItem::paintInit(bool do_save_bg)
 {
-	//init color gradient
-	if (col_body_gradient)
-		initBodyGradient();
+	if (v_fbdata.empty()){
+		int th = fr_thickness;
+		fb_pixel_t col_frame_cur = col_frame;
 
-	clearFbData();
-
-	int th = fr_thickness;
-	fb_pixel_t col_frame_cur = col_frame;
+		//calculate current needed frame thickeness and color, if item selected or not
+		if (cc_item_selected){
+			col_frame_cur = col_frame_sel;
+			th = max(fr_thickness_sel, fr_thickness);
+		}
 
-	//calculate current needed frame thickeness and color, if item selected or not
-	if (cc_item_selected){
-		col_frame_cur = col_frame_sel;
-		th = max(fr_thickness_sel, fr_thickness);
-	}
+		//calculate current needed corner radius for body box, depends of frame thickness
+		int rad = (corner_rad>th) ? corner_rad-th : corner_rad;
+		int sw = (shadow) ? shadow_w : 0;
 
-	//calculate current needed corner radius for body box, depends of frame thickness
-	int rad = (corner_rad>th) ? corner_rad-th : corner_rad;
-	int sw = (shadow) ? shadow_w : 0;
+		//if item is bound on a parent form, we must use real x/y values and from parent form as reference
+		int ix = x, iy = y;
+		if (cc_parent){
+			ix = cc_xr;
+			iy = cc_yr;
+		}
 
-	//if item is bound on a parent form, we must use real x/y values and from parent form as reference
-	int ix = x, iy = y;
-	if (cc_parent){
-		ix = cc_xr;
-		iy = cc_yr;
-	}
+		//handle shadow width
+		if (width <= sw || height <= sw) //don't use shadow, if item dimensions too small
+			sw = 0;
+		int isw = sw*2;
+		int ixsr = ix + width - isw/2;
+		int iysb = iy + height - isw/2;
+
+		//init paint layers
+		cc_fbdata_t fbdata[] =
+		{
+			{CC_FBDATA_TYPE_BGSCREEN,	ix,		iy, 		width+isw/2, 	height+isw/2, 	0, 		0, 		0,				0, 	NULL, NULL, NULL}, //buffered bg
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	ixsr,		iy+isw/2,	isw, 		height, 	col_shadow, 	corner_rad,	corner_type & CORNER_RIGHT,	0, 	NULL, NULL, NULL}, //shadow right
+			{CC_FBDATA_TYPE_SHADOW_BOX, 	ix+isw/2,	iysb, 		width, 		isw, 		col_shadow, 	corner_rad,	corner_type & CORNER_BOTTOM,	0, 	NULL, NULL, NULL}, //shadow bottom
+			{CC_FBDATA_TYPE_FRAME,		ix,		iy, 		width, 		height, 	col_frame_cur, 	corner_rad,	corner_type,			th, 	NULL, NULL, NULL}, //frame
+			{CC_FBDATA_TYPE_BOX,		ix+th,  	iy+th,  	width-2*th,     height-2*th,    col_body,       rad,		corner_type,			0, 	NULL, NULL, NULL}, //body
+		};
+
+		for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++) {
+			if ((fbdata[i].fbdata_type == CC_FBDATA_TYPE_FRAME) && !fr_thickness)
+				continue;
+			v_fbdata.push_back(fbdata[i]);
+		}
 
-	cc_gradientData.mode = CFrameBuffer::pbrg_noFree;
-	void* gradientData = (cc_gradientData.gradientBuf == NULL) ? NULL : &cc_gradientData;
-	comp_fbdata_t fbdata[] =
-	{
-		{CC_FBDATA_TYPE_BGSCREEN,	ix,	iy, 	width+sw, 	height+sw, 	0, 		0, 		0, 	NULL,	NULL},
-		{CC_FBDATA_TYPE_SHADOW_BOX, 	ix+sw,	iy+sw, 	width, 		height, 	col_shadow, 	corner_rad, 	0, 	NULL,	NULL},//shadow
-		{CC_FBDATA_TYPE_FRAME,		ix,	iy, 	width, 		height, 	col_frame_cur, 	corner_rad, 	th, 	NULL,	NULL},//frame
-		{CC_FBDATA_TYPE_BOX,		ix+th,  iy+th,  width-2*th,     height-2*th,    col_body,       rad, 		0, 	NULL, 	gradientData},//body
-	};
-
-	for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++) {
-		if (((fbdata[i].fbdata_type == CC_FBDATA_TYPE_SHADOW_BOX) && !shadow) ||
-		    ((fbdata[i].fbdata_type == CC_FBDATA_TYPE_FRAME) && !fr_thickness))
-			continue;
-		v_fbdata.push_back(fbdata[i]);
+		dprintf(DEBUG_DEBUG, "[CComponentsItem] %s:\ncc_item_type: %d\ncc_item_index = %d\nheight = %d\nwidth = %d\n", __func__, cc_item_type,  cc_item_index, height, width);
 	}
-
-	dprintf(DEBUG_DEBUG, "[CComponentsItem] %s:\ncc_item_type: %d\ncc_item_index = %d\nheight = %d\nwidth = %d\n", __func__, cc_item_type,  cc_item_index, height, width);
-
 	paintFbItems(do_save_bg);
 }
 
-//restore last saved screen behind form box,
-//Do use parameter 'no restore' to override the restore funtionality.
-//For embedded items is it mostly not required to restore saved screens, so no_resore=true also is default parameter
-//for such items.
-//This member ensures demage of already existing screen buffer too, if parameter no_restore was changed while runtime.
-void CComponentsItem::hideCCItem(bool no_restore)
-{
-	//restore saved screen if available
-	if (saved_screen.pixbuf) {
-		frameBuffer->waitForIdle("CComponentsItem::hideCCItem()");
-		frameBuffer->RestoreScreen(saved_screen.x, saved_screen.y, saved_screen.dx, saved_screen.dy, saved_screen.pixbuf);
-
-		if (no_restore) { //on parameter no restore=true delete saved screen if available
-				delete[] saved_screen.pixbuf;
-				saved_screen.pixbuf = NULL;
-				firstPaint = true;
-			}
-	}
-
-	is_painted = false;
-}
-
-void CComponentsItem::hide(bool no_restore)
-{
-	hideCCItem(no_restore);
-}
-
 //erase or paint over rendered objects
 void CComponentsItem::kill(const fb_pixel_t& bg_color, bool ignore_parent)
 {
@@ -194,20 +159,6 @@ bool CComponentsItem::isAdded()
 	return false;
 }
 
-inline void CComponentsItem::setXPos(const int& xpos)
-{
-	x = xpos;
-	if (cc_parent)
-		setRealXPos(cc_parent->getRealXPos() + x);
-}
-
-inline void CComponentsItem::setYPos(const int& ypos)
-{
-	y = ypos;
-	if (cc_parent)
-		setRealYPos(cc_parent->getRealYPos() + y);
-}
-
 void CComponentsItem::setXPosP(const uint8_t& xpos_percent)
 {
 	int x_tmp  = cc_parent ? xpos_percent*cc_parent->getWidth() : xpos_percent*frameBuffer->getScreenWidth();
@@ -254,28 +205,3 @@ void CComponentsItem::setFocus(bool focus)
 	}
 	cc_has_focus = focus;
 }
-
-void CComponentsItem::initBodyGradient()
-{
-	if (col_body_gradient && cc_gradientData.gradientBuf && (old_gradient_color != col_body || old_gradient_c2c != g_settings.theme.gradient_c2c)) {
-		free(cc_gradientData.gradientBuf);
-		cc_gradientData.gradientBuf = NULL;
-		if (cc_gradientData.boxBuf) {
-			cs_free_uncached(cc_gradientData.boxBuf);
-			cc_gradientData.boxBuf = NULL;
-		}
-	}
-	if (cc_gradientData.gradientBuf == NULL) {
-		CColorGradient ccGradient;
-		int gsize = cc_body_gradient_direction == CFrameBuffer::gradientVertical ? height : width;
-		if (g_settings.theme.gradient_c2c)
-			cc_gradientData.gradientBuf = ccGradient.gradientColorToColor(col_body, cc_body_gradient_2nd_col, NULL, gsize, cc_body_gradient_mode, cc_body_gradient_intensity);
-		else
-			cc_gradientData.gradientBuf = ccGradient.gradientOneColor(col_body, NULL, gsize, cc_body_gradient_mode, cc_body_gradient_intensity, cc_body_gradient_intensity_v_min, cc_body_gradient_intensity_v_max, cc_body_gradient_saturation);
-		old_gradient_color = col_body;
-		old_gradient_c2c = g_settings.theme.gradient_c2c;
-	}
-
-	cc_gradientData.direction = cc_body_gradient_direction;
-	cc_gradientData.mode = CFrameBuffer::pbrg_noOption;
-}
diff --git a/src/gui/components/cc_item.h b/src/gui/components/cc_item.h
new file mode 100644
index 0000000..a3a7134
--- /dev/null
+++ b/src/gui/components/cc_item.h
@@ -0,0 +1,129 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project 
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_ITEMS__
+#define __CC_ITEMS__
+
+#include "cc_types.h"
+#include "cc_base.h"
+#include "cc_draw.h"
+#include <vector>
+#include <string>
+#include <driver/colorgradient.h>
+
+class CComponentsItem : public CComponents
+{
+	protected:
+		///property: define of item index, all bound items get an index,
+		///default: CC_NO_INDEX as identifer for not embedded item and default index=0 for form as main parent
+		///see also getIndex(), setIndex()
+		int cc_item_index;
+		///property: define of item type, see cc_types.h for possible types
+		int cc_item_type;
+		///property: default enabled
+		bool cc_item_enabled;
+		///property: default not selected
+		bool cc_item_selected;
+		///property: page number, this defines current item page location, means: this item is embedded in a parent container on page number n, see also setPageNumber()
+		///default value is 0 for page one, any value > 0 causes handling for mutilple pages at parent container
+		uint8_t cc_page_number;
+		///specifies that some certain operations especially eg. exec events for that item are possible, see also setFocus(), hasFocus()
+		bool cc_has_focus;
+
+		///Pointer to the form object in which this item is embedded.
+		///Is typically the type CComponentsForm or derived classes, default intialized with NULL
+		CComponentsForm *cc_parent;
+
+		///initialze of basic framebuffer elements with shadow, background and frame.
+		///must be called first in all paint() members before paint any item,
+		///If backround is not required, it's possible to override this with variable paint_bg=false, use doPaintBg(true/false) to set this!
+		///arg do_save_bg=false avoids using of unnecessary pixel memory, eg. if no hide with restore is provided. This is mostly the case  whenever
+		///an item will be hide or overpainted with other methods, or it's embedded  (bound)  in a parent form.
+		void paintInit(bool do_save_bg);
+
+		///add "this" current item to parent
+		void initParent(CComponentsForm* parent);
+
+
+	public:
+		CComponentsItem(CComponentsForm *parent = NULL);
+
+		///sets pointer to the form object in which this item is embedded.
+		virtual void setParent(CComponentsForm *parent){cc_parent = parent;};
+		///returns pointer to the form object in which this item is embedded.
+		virtual CComponentsForm* getParent(){return cc_parent;};
+		///property: returns true if item is added to a form
+		virtual bool isAdded();
+		///indicates wether item has focus
+		virtual bool hasFocus(){return cc_has_focus;}
+		///set or unset focus of item, stand alone items without parent have always set focus to true, inside of a parent form object, always the last added item has focus
+		virtual void setFocus(bool focus);
+
+		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
+		///from CFrameBuffer but with possiblity to define color, default color is 0 (empty background)
+		///NOTE: Items with parent binding use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
+		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, bool ignore_parent = false);
+
+		///get the current item type, see attribute cc_item_type above
+		virtual int getItemType();
+		///syncronizes item colors with current color settings if required, NOTE: overwrites internal values!
+		virtual void syncSysColors();
+		
+		///set select mode, see also col_frame_sel
+		virtual void setSelected(bool selected){cc_item_selected = selected;};
+		///set enable mode, see also cc_item_enabled
+		virtual void setEnable(bool enabled){cc_item_enabled = enabled;};
+		
+		///get select mode, see also setSelected() above
+		virtual bool isSelected(){return cc_item_selected;};
+		///get enable mode, see also setEnable() above
+		virtual bool isEnabled(){return cc_item_enabled;};
+
+		///get current index of item, see also attribut cc_item_index
+		virtual int getIndex(){return cc_item_index;};
+		///set an index to item, see also attribut cc_item_index.
+		///To generate an index, use genIndex()
+		virtual void setIndex(const int& index){cc_item_index = index;};
+
+		///sets page location of current item, parameter as uint8_t, see: cc_page_number
+		virtual void setPageNumber(const uint8_t& on_page_number){cc_page_number = on_page_number;};
+		///returns current number of page location of current item, see: cc_page_number
+		virtual u_int8_t getPageNumber(){return cc_page_number;};
+
+		///set screen x-position, parameter as uint8_t, percent x value related to current width of parent form or screen
+		virtual void setXPosP(const uint8_t& xpos_percent);
+		///set screen y-position, parameter as uint8_t, percent y value related to current height of parent form or screen
+		virtual void setYPosP(const uint8_t& ypos_percent);
+		///set x and y position as percent value related to current parent form or screen dimensions at once
+		virtual void setPosP(const uint8_t& xpos_percent, const uint8_t& ypos_percent);
+
+		///do center item on screen or within a parent form, parameter along_mode assigns direction of centering
+		virtual void setCenterPos(int along_mode = CC_ALONG_X | CC_ALONG_Y);
+
+		///set item height, parameter as uint8_t, as percent value related to current height of parent form or screen
+		virtual void setHeightP(const uint8_t& h_percent);
+		///set item width, parameter as uint8_t, as percent value related to current width of parent form or screen
+		virtual void setWidthP(const uint8_t& w_percent);
+};
+
+#endif
diff --git a/src/gui/components/cc_item_infobox.cpp b/src/gui/components/cc_item_infobox.cpp
index 676a1db..0d75536 100644
--- a/src/gui/components/cc_item_infobox.cpp
+++ b/src/gui/components/cc_item_infobox.cpp
@@ -110,7 +110,7 @@ void CComponentsInfoBox::paintPicture()
 	pic->setColorBody(col_body);
 
 	//set gradient behavior of pic object
-	if (col_body_gradient)
+	if (cc_body_gradient_enable)
 		pic->doPaintBg(false);
 
 	//fit icon into frame
@@ -150,7 +150,7 @@ void CComponentsInfoBox::paint(bool do_save_bg)
 	cctext->doPaintTextBoxBg(ct_paint_textbg);
 	cctext->doPaintBg(false);
 	cctext->setTextColor(ct_col_text);
-	cctext->enableTboxSaveScreen(save_tbox_screen);
+	cctext->enableTboxSaveScreen(cc_txt_save_screen);
 
 	//calculate vars for x-position and dimensions
 	int tx = x_offset + x_text + pic_w;
diff --git a/src/gui/components/cc_item_infobox.h b/src/gui/components/cc_item_infobox.h
index 6a86a6d..610e872 100644
--- a/src/gui/components/cc_item_infobox.h
+++ b/src/gui/components/cc_item_infobox.h
@@ -32,6 +32,7 @@
 
 #include "cc_item_text.h"
 #include "cc_item_picture.h"
+#include "cc_item.h"
 #include <string>
 
 //! Sub class of CComponentsItem. Shows box with text and optional icon on screen.
@@ -78,13 +79,11 @@ class CComponentsInfoBox : public CComponentsText
 		~CComponentsInfoBox();
 
 		///set property: space around fram and beetween picture and textbox
-		inline void setSpaceOffset(const int offset){x_offset = offset;};
+		void setSpaceOffset(const int offset){x_offset = offset;};
 		///set property: path or name of displayed image, parameter as string
 		void setPicture(const std::string& picture_name);
 		///set property: path or name of displayed image, parameter as const char*
 		void setPicture(const char* picture_name);
-		///set property: gradient behavior
-		void enableGradient(bool enable) { col_body_gradient = enable; }
 		///paint item
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 };
diff --git a/src/gui/components/cc_item_picture.cpp b/src/gui/components/cc_item_picture.cpp
index bca05b3..35274bf 100644
--- a/src/gui/components/cc_item_picture.cpp
+++ b/src/gui/components/cc_item_picture.cpp
@@ -75,7 +75,7 @@ void CComponentsPicture::init(	const int &x_pos, const int &y_pos, const int &w,
 	y 		= y_pos;
 	width		= w;
 	height		= h;
-	pic_name 	= image_name;
+	pic_name = pic_name_old = image_name;
 	shadow		= has_shadow;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
@@ -86,6 +86,7 @@ void CComponentsPicture::init(	const int &x_pos, const int &y_pos, const int &w,
 	is_image_painted= false;
 	do_paint	= true;
 	image_transparent = transparent;
+	cc_paint_cache	= false;
 
 	initCCItem();
 	initParent(parent);
@@ -172,6 +173,10 @@ int CComponentsPicture::getHeight()
 
 void CComponentsPicture::paintPicture()
 {
+	struct timeval t1, t2;
+	if (debug)
+		gettimeofday(&t1, NULL);
+
 	is_image_painted = false;
 	//initialize image position
 	int x_pic = x;
@@ -190,6 +195,14 @@ void CComponentsPicture::paintPicture()
 			is_image_painted = frameBuffer->paintIcon(pic_name, x_pic, y_pic, height, 1, do_paint, paint_bg, col_body);
 		frameBuffer->SetTransparentDefault();
 	}
+
+	//benchmark
+	if (debug){
+		gettimeofday(&t2, NULL);
+		uint64_t duration = ((t2.tv_sec * 1000000ULL + t2.tv_usec) - (t1.tv_sec * 1000000ULL + t1.tv_usec)) / 1000ULL;
+		if (duration)
+			fprintf(stderr, "\033[33m[CComponentsPicture] %s: %llu ms to paint image \033[0m\n",	__func__, duration);
+	}
 }
 
 void CComponentsPicture::paint(bool do_save_bg)
@@ -200,12 +213,25 @@ void CComponentsPicture::paint(bool do_save_bg)
 	paintPicture();
 }
 
-void CComponentsPicture::hide(bool no_restore)
+void CComponentsPicture::hide()
 {
-	hideCCItem(no_restore);
+	CComponents::hide();
 	is_image_painted = false;
 }
 
+bool CComponentsPicture::hasChanges()
+{
+	bool ret = false;
+	if (pic_name != pic_name_old){
+		pic_name_old = pic_name;
+		ret = true;
+	}
+	if (CCDraw::hasChanges())
+		ret = true;
+
+	return ret;
+}
+
 
 CComponentsChannelLogo::CComponentsChannelLogo( const int &x_pos, const int &y_pos, const int &w, const int &h,
 						const std::string& channelName,
@@ -280,3 +306,5 @@ void CComponentsChannelLogo::setChannel(const uint64_t& channelId, const std::st
 
 	doPaintBg(false);
 }
+
+
diff --git a/src/gui/components/cc_item_picture.h b/src/gui/components/cc_item_picture.h
index 2f84d0e..5be5ee4 100644
--- a/src/gui/components/cc_item_picture.h
+++ b/src/gui/components/cc_item_picture.h
@@ -32,6 +32,7 @@
 #endif
 
 #include "cc_base.h"
+#include "cc_item.h"
 #include <string>
 #include <driver/pictureviewer/pictureviewer.h>
 
@@ -50,7 +51,7 @@ class CComponentsPicture : public CComponentsItem
 		std::vector<std::string> v_ext;
 
 		///property: name of image (without extensionn) full path to image (with extension), icon names to find in /widget/icons.h, icons will paint never scaled
-		std::string pic_name;
+		std::string pic_name, pic_name_old;
  
 		///indicate that image was sucessful painted
 		bool is_image_painted;
@@ -146,8 +147,10 @@ class CComponentsPicture : public CComponentsItem
 
 		///paint item
 		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
-		///hide item
-		virtual void hide(bool no_restore = false);
+		///hide item, see also CComponents::hide();
+		virtual void hide();
+		
+		virtual bool hasChanges();
 };
 
 class 	CComponentsPictureScalable : public CComponentsPicture
diff --git a/src/gui/components/cc_item_progressbar.cpp b/src/gui/components/cc_item_progressbar.cpp
index 0ddb9ef..3abefb1 100644
--- a/src/gui/components/cc_item_progressbar.cpp
+++ b/src/gui/components/cc_item_progressbar.cpp
@@ -30,7 +30,7 @@
 #include <math.h>
 #include <global.h>
 #include <neutrino.h>
-
+#include <system/debug.h>
 #include "cc_item_progressbar.h"
 #define ITEMW 4
 #define POINT 2
@@ -39,10 +39,18 @@
 #define GREEN  0x00FF00
 #define YELLOW 0xFFFF00
 
-CProgressBar::CProgressBar(	const int x_pos, const int y_pos, const int w, const int h,
-				fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow,
-				const fb_pixel_t active_col, const fb_pixel_t passive_col,
-				const int r, const int g, const int b,
+CProgressBar::CProgressBar(	const int x_pos,
+				const int y_pos,
+				const int w,
+				const int h,
+				fb_pixel_t color_frame,
+				fb_pixel_t color_body,
+				fb_pixel_t color_shadow,
+				const fb_pixel_t active_col,
+				const fb_pixel_t passive_col,
+				const int R,
+				const int G,
+				const int Y,
 				CComponentsForm *parent)
 {
 	//CComponentsItem
@@ -58,9 +66,9 @@ CProgressBar::CProgressBar(	const int x_pos, const int y_pos, const int w, const
 	col_body	= color_body;
 	col_shadow	= color_shadow;
 
-	pb_red 		= r;
-	pb_green 	= g;
-	pb_yellow 	= b;
+	pb_red 		= R;
+	pb_green 	= G;
+	pb_yellow 	= Y;
 	pb_active_col	= active_col;
 	pb_passive_col 	= passive_col;
 
@@ -80,6 +88,7 @@ CProgressBar::CProgressBar(	const int x_pos, const int y_pos, const int w, const
 	pb_height		= 0;
 	pb_start_x_passive 	= 0;
 	pb_passive_width 	= width;
+	cc_paint_cache		= false;
 	initParent(parent);
 }
 
@@ -124,94 +133,122 @@ class CProgressBarCache
 {
 	private:
 		// keys to lookup:
-		int pb_height, pb_width;
-		int pb_active_col, pb_passive_col;
-		int design;
-		bool pb_invert, gradient;
-		int pb_red, pb_yellow, pb_green;
-
+		int pbc_height, pbc_width;
+		int pbc_active_col, pbc_passive_col;
+		int pbc_design;
+		bool pbc_invert, pbc_gradient;
+		int pbc_red, pbc_green, pbc_yellow;
 		int yoff;
 
-		fb_pixel_t *active, *passive;
+		fb_pixel_t *pbc_active, *pbc_passive;
+ ;
 
 		static inline unsigned int make16color(__u32 rgb){return 0xFF000000 | rgb;};
-		void paintBoxRel(fb_pixel_t *b, int x, int y, int dx, int dy, fb_pixel_t col);
-		void applyGradient(fb_pixel_t *buf);
-		void createBitmaps();
 
-		CProgressBarCache(int _height, int _width, int _pb_active_col, int _pb_passive_col, int _design, bool _invert, bool _gradient, int _red, int _yellow, int _green)
-			: pb_height(_height), pb_width(_width), pb_active_col(_pb_active_col), pb_passive_col(_pb_passive_col), design(_design), pb_invert(_invert), gradient(_gradient),
-			  pb_red(_red), pb_yellow(_yellow), pb_green(_green), yoff(0)
+		void pbcPaintBoxRel(int x, int y, int dx, int dy, fb_pixel_t *pixbuf, fb_pixel_t col);
+		void pbcApplyGradient(fb_pixel_t *pixbuf);
+		void pbcCreateBitmaps();
+
+		CProgressBarCache(	int dy,
+					int dx,
+					int active_col,
+					int passive_col,
+					int design,
+					bool enable_invert,
+					bool enable_gradient,
+					int R,
+					int G,
+					int Y)
+						: pbc_height(dy),
+						pbc_width(dx),
+						pbc_active_col(active_col),
+						pbc_passive_col(passive_col),
+						pbc_design(design),
+						pbc_invert(enable_invert),
+						pbc_gradient(enable_gradient),
+						pbc_red(R),
+						pbc_green(G),
+						pbc_yellow(Y),
+						yoff(0)
 		{
 			if (pbCache.size() > 10)
 				clear();
-			createBitmaps();
+			pbcCreateBitmaps();
 		}
 		void clear();
 	public:
-		void paint(int x, int y, int pb_active_width, int pb_passive_width);
-		static CProgressBarCache *lookup(int _height, int _width, int _pb_active_col, int _pb_passive_col, int _design, bool _invert, bool _gradient, int _red, int _yellow, int _green);
+		void pbcPaint(int x, int y, int pbc_active_width, int pbc_passive_width);
+		static CProgressBarCache *lookup(	int dy,
+							int dx,
+							int active_col,
+							int passive_col,
+							int design,
+							bool enable_invert,
+							bool enable_gradient,
+							int R,
+							int G,
+							int Y);
 };
 
 void CProgressBarCache::clear()
 {
 	for (std::vector<CProgressBarCache *>::iterator it = pbCache.begin(); it != pbCache.end(); ++it) {
-		if ((*it)->active)
-			free((*it)->active);
-		if ((*it)->passive)
-			free((*it)->passive);
+		if ((*it)->pbc_active)
+			free((*it)->pbc_active);
+		if ((*it)->pbc_passive)
+			free((*it)->pbc_passive);
 	}
 	pbCache.clear();
 }
 
-CProgressBarCache *CProgressBarCache::lookup(int _height, int _width, int _pb_active_col, int _pb_passive_col, int _design, bool _invert, bool _gradient, int _red, int _yellow, int _green)
+CProgressBarCache *CProgressBarCache::lookup(int dy, int dx, int active_col, int passive_col, int design, bool enable_invert, bool enable_gradient, int R, int G, int Y)
 {
 	// sanitize
-	if (_design == CProgressBar::PB_MONO)
-		_red = _yellow = _green = 0;
+	if (design == CProgressBar::PB_MONO)
+		R = G = Y = 0;
 
 	// lookup
 	std::vector<CProgressBarCache *>::iterator it = pbCache.begin();
-	for (; it != pbCache.end() && ((*it)->pb_height != _height || (*it)->pb_width != _width ||
-				       (*it)->pb_active_col != _pb_active_col || (*it)->pb_passive_col != _pb_passive_col ||
-				       (*it)->design != _design || (*it)->pb_invert != _invert || (*it)->gradient != _gradient ||
-				       (*it)->pb_red != _red || (*it)->pb_yellow != _yellow || (*it)->pb_green != _green); ++it);
+	for (; it != pbCache.end() && ((*it)->pbc_height != dy || (*it)->pbc_width != dx ||
+				       (*it)->pbc_active_col != active_col || (*it)->pbc_passive_col != passive_col ||
+				       (*it)->pbc_design != design || (*it)->pbc_invert != enable_invert || (*it)->pbc_gradient != enable_gradient ||
+				       (*it)->pbc_red != R || (*it)->pbc_yellow != Y || (*it)->pbc_green != G); ++it);
 	if (it != pbCache.end())
 		return *it;
 
-	CProgressBarCache *pbc = new CProgressBarCache(_height, _width, _pb_active_col, _pb_passive_col, _design, _invert, _gradient, _red, _yellow, _green);
+	CProgressBarCache *pbc = new CProgressBarCache(dy, dx, active_col, passive_col, design, enable_invert, enable_gradient, R, G, Y);
 	pbCache.push_back(pbc);
 	return pbc;
 }
 
-void CProgressBarCache::paint(int x, int y, int pb_active_width, int pb_passive_width)
+void CProgressBarCache::pbcPaint(int x, int y, int pbc_active_width, int pbc_passive_width)
 {
 	y += yoff;
 	static CFrameBuffer *frameBuffer = CFrameBuffer::getInstance();
 	unsigned int stride = frameBuffer->getStride() / sizeof(fb_pixel_t);
 	fb_pixel_t *p = frameBuffer->getFrameBufferPointer() + y * stride + x;
-	int off = stride - pb_width;
-	if (pb_active_width > pb_width)
-		pb_active_width = pb_width;
-	if (pb_active_width + pb_passive_width != pb_width)
-		pb_passive_width = pb_width - pb_active_width;
-	fb_pixel_t *ap = active;
-	fb_pixel_t *pp = passive;
-	for (int h = 0; h < pb_height; h++) {
+	int off = stride - pbc_width;
+	if (pbc_active_width > pbc_width)
+		pbc_active_width = pbc_width;
+	if (pbc_active_width + pbc_passive_width != pbc_width)
+		pbc_passive_width = pbc_width - pbc_active_width;
+	fb_pixel_t *ap = pbc_active;
+	fb_pixel_t *pp = pbc_passive;
+	for (int h = 0; h < pbc_height; h++) {
 		int w = 0;
-		for (; w < pb_active_width; w++, p++, ap++)
+		for (; w < pbc_active_width; w++, p++, ap++)
 			if (*ap)
 				*p = *ap;
-		pp += pb_active_width;
-		for (; w < pb_width; w++, p++, pp++)
+		pp += pbc_active_width;
+		for (; w < pbc_width; w++, p++, pp++)
 			if (*pp)
 				*p = *pp;
-		ap += pb_passive_width;
+		ap += pbc_passive_width;
 		p += off;
 	}
 }
 
-void CProgressBarCache::paintBoxRel(fb_pixel_t *b, int x, int y, int dx, int dy, fb_pixel_t col)
+void CProgressBarCache::pbcPaintBoxRel(int x, int y, int dx, int dy, fb_pixel_t *pixbuf, fb_pixel_t col)
 {
 	if (x < 0) {
 		dx -= x;
@@ -221,80 +258,80 @@ void CProgressBarCache::paintBoxRel(fb_pixel_t *b, int x, int y, int dx, int dy,
 		dy -= y;
 		y = 0;
 	}
-	if (x + dx > pb_width)
-		dx = pb_width - x;
-	if (y + dy > pb_height)
-		dy = pb_height - y;
+	if (x + dx > pbc_width)
+		dx = pbc_width - x;
+	if (y + dy > pbc_height)
+		dy = pbc_height - y;
 	if (dx < 1 || dy < 1)
 		return;
-	b += pb_width * y + x;
-	fb_pixel_t *e = b + pb_width * (dy - 1) + dx;
-	int off = pb_width - dx;
-	while (b < e) {
-		fb_pixel_t *ex = b + dx;
-		while (b < ex)
-			*b++ = col;
-		b += off;
+	pixbuf += pbc_width * y + x;
+	fb_pixel_t *e = pixbuf + pbc_width * (dy - 1) + dx;
+	int off = pbc_width - dx;
+	while (pixbuf < e) {
+		fb_pixel_t *ex = pixbuf + dx;
+		while (pixbuf < ex)
+			*pixbuf++ = col;
+		pixbuf += off;
 	}
 }
 
-void CProgressBarCache::createBitmaps()
+void CProgressBarCache::pbcCreateBitmaps()
 {
-	active = (fb_pixel_t *) calloc(1, pb_width * pb_height * sizeof(fb_pixel_t));
-	if (!active)
+	pbc_active = (fb_pixel_t *) calloc(1, pbc_width * pbc_height * sizeof(fb_pixel_t));
+	if (!pbc_active)
 		return;
-	passive = (fb_pixel_t *) calloc(1, pb_width * pb_height * sizeof(fb_pixel_t));
-	if (!passive) {
-		free(active);
+	pbc_passive = (fb_pixel_t *) calloc(1, pbc_width * pbc_height * sizeof(fb_pixel_t));
+	if (!pbc_passive) {
+		free(pbc_active);
 		return;
 	}
 
 	int itemw = ITEMW, itemh = ITEMW, pointx = POINT, pointy = POINT;
-	switch (design){
+	switch (pbc_design){
 		default:
 		case CProgressBar::PB_MONO:	// monochrome
-			paintBoxRel(active,  0, 0, pb_width, pb_height, pb_active_col );
-			paintBoxRel(passive, 0, 0, pb_width, pb_height, pb_passive_col);
-			if (gradient) {
-				applyGradient(active);
-				applyGradient(passive);
+			pbcPaintBoxRel(0, 0, pbc_width, pbc_height, pbc_active, pbc_active_col);
+			pbcPaintBoxRel(0, 0, pbc_width, pbc_height, pbc_passive, pbc_passive_col);
+			if (pbc_gradient) {
+				pbcApplyGradient(pbc_active);
+				pbcApplyGradient(pbc_passive);
 			}
 			return;
 		case CProgressBar::PB_MATRIX: // ::::: matrix
 			break;
 		case CProgressBar::PB_LINES_V: // ||||| vert. lines
-			itemh = pb_height;
-			pointy = pb_height;
+			itemh = pbc_height;
+			pointy = pbc_height;
 			break;
 		case CProgressBar::PB_LINES_H: // ===== horiz. lines
 			itemw = POINT;
 			break;
 		case CProgressBar::PB_COLOR: // filled color
 			itemw = 1;
-			itemh = pb_height;
-			pointy = pb_height;
+			itemh = pbc_height;
+			pointy = pbc_height;
 			break;
 	}
 
 	const int spc = itemh - pointy;			/* space between horizontal lines / points */
-	int hcnt = (pb_height + spc) / itemh;		/* how many POINTs is the bar high */
-	yoff = (pb_height + spc - itemh * hcnt) / 2;
+	int hcnt = (pbc_height + spc) / itemh;		/* how many POINTs is the bar high */
+	yoff = (pbc_height + spc - itemh * hcnt) / 2;
 
 	int i = 0;
 
 	int sh_x = 0;
 	/* red, yellow, green are given in percent */
-	int rd = pb_red    * pb_width / (100 * itemw);	/* how many POINTs red */
-	int yw = pb_yellow * pb_width / (100 * itemw);	/* how many POINTs yellow */
-	int gn = pb_green  * pb_width / (100 * itemw);	/* how many POINTs green */
+	int rd = pbc_red    * pbc_width / (100 * itemw);	/* how many POINTs red */
+	int yw = pbc_yellow * pbc_width / (100 * itemw);	/* how many POINTs yellow */
+	int gn = pbc_green  * pbc_width / (100 * itemw);	/* how many POINTs green */
 
 	// fixup rounding errors
-	while ((rd + yw + gn) * itemw < pb_width) {
+	while ((rd + yw + gn) * itemw < pbc_width) {
 		if (gn)
 			gn++;
-		if (yw && ((rd + yw + gn) * itemw < pb_width))
+		if (yw && ((rd + yw + gn) * itemw < pbc_width))
 			yw++;
-		if (rd && ((rd + yw + gn) * itemw < pb_width))
+		if (rd && ((rd + yw + gn) * itemw < pbc_width))
 			rd++;
 	}
 
@@ -310,7 +347,7 @@ void CProgressBarCache::createBitmaps()
 		fb_pixel_t color = make16color(rgb);
 		int sh_y = 0;
 		for (int j = 0; j < hcnt; j++, sh_y += itemh)
-			paintBoxRel(active, sh_x, sh_y, pointx, pointy, color);
+			pbcPaintBoxRel(sh_x, sh_y, pointx, pointy, pbc_active, color);
 	}
 	step = yw - rd - 1;
 	if (step < 1)
@@ -321,7 +358,7 @@ void CProgressBarCache::createBitmaps()
 		fb_pixel_t color = make16color(rgb);
 		int sh_y = 0;
 		for (int j = 0; j < hcnt; j++, sh_y += itemh)
-			paintBoxRel(active, sh_x, sh_y, pointx, pointy, color);
+			pbcPaintBoxRel(sh_x, sh_y, pointx, pointy, pbc_active, color);
 	}
 	int off = diff;
 	b = 0;
@@ -334,12 +371,12 @@ void CProgressBarCache::createBitmaps()
 		fb_pixel_t color = make16color(rgb);
 		int sh_y = 0;
 		for (int j = 0; j < hcnt; j++, sh_y += itemh)
-			paintBoxRel(active, sh_x, sh_y, pointx, pointy, color);
+			pbcPaintBoxRel(sh_x, sh_y, pointx, pointy, pbc_active, color);
 	}
-	if (pb_invert) {
-		for (int l = 0; l < pb_height; l++) {
-			fb_pixel_t *as = active + l * pb_width;
-			fb_pixel_t *ae = as + pb_width - 1;
+	if (pbc_invert) {
+		for (int l = 0; l < pbc_height; l++) {
+			fb_pixel_t *as = pbc_active + l * pbc_width;
+			fb_pixel_t *ae = as + pbc_width - 1;
 			for (; as < ae; as++, ae--) {
 				fb_pixel_t t = *as;
 				*as = *ae;
@@ -348,11 +385,11 @@ void CProgressBarCache::createBitmaps()
 		}
 	}
 
-	if (gradient)
-		applyGradient(active);
+	if (pbc_gradient)
+		pbcApplyGradient(pbc_active);
 
-	fb_pixel_t *a = active, *p = passive;
-	fb_pixel_t *end = a + pb_width * pb_height;
+	fb_pixel_t *a = pbc_active, *p = pbc_passive;
+	fb_pixel_t *end = a + pbc_width * pbc_height;
 	for (; a < end; a++, p++) {
 		fb_pixel_t q = *a;
 		unsigned int gray = ((q & 0xff) + ((q >> 8) & 0xff) + ((q >> 16) & 0xff)) / 3;
@@ -367,17 +404,17 @@ void CProgressBarCache::createBitmaps()
 	}
 }
 
-void CProgressBarCache::applyGradient(fb_pixel_t *b)
+void CProgressBarCache::pbcApplyGradient(fb_pixel_t *b)
 {
-	for (int y = 0; y < pb_height; y++) {
-		int _o = y * pb_width;
+	for (int y = 0; y < pbc_height; y++) {
+		int _o = y * pbc_width;
 		fb_pixel_t last_old = 0;
 		fb_pixel_t last_new = 0;
-		for (int _x = pb_width - 1; _x > -1; _x--) {
+		for (int _x = pbc_width - 1; _x > -1; _x--) {
 			fb_pixel_t &v = *(b + _o + _x);
 			if (v != last_old) {
 				last_old = v;
-				double s = sin((y + .5) * M_PI / pb_height) * .8 + .2;
+				double s = sin((y + .5) * M_PI / pbc_height) * .8 + .2;
 				float fr = float(((last_old >> 16) & 0xff) * s + 0.5);
 				float fg = float(((last_old >>  8) & 0xff) * s + 0.5);
 				float fb = float(((last_old      ) & 0xff) * s + 0.5);
@@ -393,6 +430,10 @@ void CProgressBarCache::applyGradient(fb_pixel_t *b)
 
 void CProgressBar::paintProgress(bool do_save_bg)
 {
+	struct timeval t1, t2;
+	if (debug)
+		gettimeofday(&t1, NULL);
+
 	if (*pb_design == PB_OFF) {
 		paintInit(false);
 		return;
@@ -426,13 +467,21 @@ void CProgressBar::paintProgress(bool do_save_bg)
 		if (pb_active_width != pb_last_width) {
 			CProgressBarCache *pbc = CProgressBarCache::lookup(pb_height, pb_max_width, pb_active_col, pb_passive_col, *pb_design, pb_invert, *pb_gradient, pb_red, pb_yellow, pb_green);
 			if (pbc)
-				pbc->paint(pb_x, pb_y, pb_active_width, pb_passive_width);
+				pbc->pbcPaint(pb_x, pb_y, pb_active_width, pb_passive_width);
 			is_painted = true;
 		}
 	}
 
 	if (is_painted)
 		pb_last_width = pb_active_width;
+
+	//benchmark
+	if (debug){
+		gettimeofday(&t2, NULL);
+		uint64_t duration = ((t2.tv_sec * 1000000ULL + t2.tv_usec) - (t1.tv_sec * 1000000ULL + t1.tv_usec)) / 1000ULL;
+		if (duration)
+			fprintf(stderr, "\033[33m[CProgressBar] %s: %llu ms to paint progress \033[0m\n",__func__, duration);
+	}
 }
 
 
diff --git a/src/gui/components/cc_item_progressbar.h b/src/gui/components/cc_item_progressbar.h
index 4901f12..c3bcb40 100644
--- a/src/gui/components/cc_item_progressbar.h
+++ b/src/gui/components/cc_item_progressbar.h
@@ -50,7 +50,7 @@
 
 #include "config.h"
 #include "cc_base.h"
-
+#include "cc_item.h"
 #include <string>
 
 class CProgressBar : public CComponentsItem
@@ -91,14 +91,21 @@ class CProgressBar : public CComponentsItem
 		///parameters:
 		///x_pos, y_pos, w, h: position and dimension in pixel
 		///w, h: width / height of bar. Can later be set with paintProgressbar.
-		///r, g, b: percentage of the bar where red/green/yellow is used, only used for colored designs
+		///R, G, Y: percentage of the bar where red/green/yellow is used, only used for colored designs
 		///active_col, passive_col: sets colors for displayed values, activ_col means the the displayed progress
 		///color_frame, color_body, color_shadow: colores of progressbar for frame, body and shadow, Note: color of frame is ineffective on fr_thickness = 0
-		CProgressBar(	const int x_pos = 0, const int y_pos = 0,
-				const int w = -1, const int h = -1,
-				fb_pixel_t color_frame = 0, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
-				const fb_pixel_t active_col = COL_INFOBAR_PLUS_7, const fb_pixel_t passive_col = COL_INFOBAR_PLUS_3,
-				const int r = 40, const int g = 100, const int b =70,
+		CProgressBar(	const int x_pos = 0,
+				const int y_pos = 0,
+				const int w = -1,
+				const int h = -1,
+				fb_pixel_t color_frame = 0,
+				fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
+				fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
+				const fb_pixel_t active_col = COL_INFOBAR_PLUS_7,
+				const fb_pixel_t passive_col = COL_INFOBAR_PLUS_3,
+				const int R = 40,
+				const int G = 100,
+				const int Y = 70,
 				CComponentsForm *parent = NULL);
 
 
diff --git a/src/gui/components/cc_item_shapes.h b/src/gui/components/cc_item_shapes.h
index 7457d88..d0490fc 100644
--- a/src/gui/components/cc_item_shapes.h
+++ b/src/gui/components/cc_item_shapes.h
@@ -31,6 +31,7 @@
 #endif
 
 #include "cc_base.h"
+#include "cc_item.h"
 
 //! Sub class of CComponentsItem. Shows a shape with given dimensions and color on screen.
 /*!
diff --git a/src/gui/components/cc_item_text.cpp b/src/gui/components/cc_item_text.cpp
index c24e255..23ec62b 100644
--- a/src/gui/components/cc_item_text.cpp
+++ b/src/gui/components/cc_item_text.cpp
@@ -147,7 +147,7 @@ void CComponentsText::initCCText()
 	ct_textbox->setTextColor(ct_col_text);
 	ct_textbox->setWindowMaxDimensions(iWidth, iHeight);
 	ct_textbox->setWindowMinDimensions(iWidth, iHeight);
-	ct_textbox->enableSaveScreen(save_tbox_screen);
+	ct_textbox->enableSaveScreen(cc_txt_save_screen);
 
 	//observe behavior of parent form if available
 	bool force_text_paint = ct_force_text_paint;
@@ -261,12 +261,12 @@ void CComponentsText::paint(bool do_save_bg)
 	paintText(do_save_bg);
 }
 
-void CComponentsText::hide(bool no_restore)
+void CComponentsText::hide()
 {
 	if (ct_textbox)
 		ct_textbox->hide();
 	ct_old_text = "";
-	hideCCItem(no_restore);
+	CComponents::hide();
 }
 
 //small helper to remove excessiv linbreaks
diff --git a/src/gui/components/cc_item_text.h b/src/gui/components/cc_item_text.h
index 0b89f2b..c704a2e 100644
--- a/src/gui/components/cc_item_text.h
+++ b/src/gui/components/cc_item_text.h
@@ -27,6 +27,8 @@
 #define __CC_ITEM_TEXT_H__
 
 #include "cc_base.h"
+#include "cc_item.h"
+#include "cc_text_screen.h"
 #include <gui/widget/textbox.h>
 #include <string>
 
@@ -38,7 +40,7 @@ Handling of text parts based up CTextBox attributes and methodes.
 CComponentsText provides a interface to the embedded CTextBox object.
 */
 
-class CComponentsText : public CComponentsItem, public CBox
+class CComponentsText : public CCTextScreen, public CComponentsItem, public CBox
 {
 	protected:
 		///object: CTextBox object
@@ -117,7 +119,7 @@ class CComponentsText : public CComponentsItem, public CBox
 
 		///default members to paint a text box and hide painted text
 		///hide textbox
-		void hide(bool no_restore = false);
+		void hide();
 		///paint text box, parameter do_save_bg: default = true, causes fill of backckrond pixel buffer
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 
@@ -163,10 +165,10 @@ class CComponentsText : public CComponentsItem, public CBox
 
 		///returns count of lines from a text box page
 		virtual int getTextLinesAutoHeight(const int& textMaxHeight, const int& textWidth, const int& mode);
-		// overload function from cc_base CComponents
+		///allows to save bg screen behind text within CTextBox object, see also cc_txt_save_screen
 		void enableTboxSaveScreen(bool mode)
 		{
-			save_tbox_screen = mode;
+			cc_txt_save_screen = mode;
 			if (ct_textbox)
 				ct_textbox->enableSaveScreen(mode);
 		}
diff --git a/src/gui/components/cc_item_tvpic.cpp b/src/gui/components/cc_item_tvpic.cpp
index 4dd375f..6e47e3d 100644
--- a/src/gui/components/cc_item_tvpic.cpp
+++ b/src/gui/components/cc_item_tvpic.cpp
@@ -73,7 +73,7 @@ CComponentsPIP::CComponentsPIP(	const int x_pos, const int y_pos, const int perc
 CComponentsPIP::~CComponentsPIP()
 {
  	hide();
- 	videoDecoder->Pig(-1, -1, -1, -1);
+//  	videoDecoder->Pig(-1, -1, -1, -1);
 }
 
 void CComponentsPIP::paint(bool do_save_bg)
@@ -111,8 +111,8 @@ void CComponentsPIP::paint(bool do_save_bg)
 }
 
 
-void CComponentsPIP::hide(bool no_restore)
+void CComponentsPIP::hide()
 {
 	videoDecoder->Pig(-1, -1, -1, -1);
-	hideCCItem(no_restore);
+	CComponents::hide();
 }
diff --git a/src/gui/components/cc_item_tvpic.h b/src/gui/components/cc_item_tvpic.h
index 280f6cb..d4f3369 100644
--- a/src/gui/components/cc_item_tvpic.h
+++ b/src/gui/components/cc_item_tvpic.h
@@ -31,6 +31,7 @@
 #endif
 
 #include "cc_base.h"
+#include "cc_item.h"
 #include <string>
 
 //! Sub class of CComponentsItem. Shows a mini tv box, similar to a PIP-Feature with current tv-channel.
@@ -66,7 +67,7 @@ class CComponentsPIP : public CComponentsItem
 		///show tv box
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 		///remove tv box from screen
-		void hide(bool no_restore = false);
+		void hide();
 };
 
 #endif
diff --git a/src/gui/components/cc_text_screen.h b/src/gui/components/cc_text_screen.h
new file mode 100644
index 0000000..afdbe90
--- /dev/null
+++ b/src/gui/components/cc_text_screen.h
@@ -0,0 +1,44 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_TXT_SCREEN__
+#define __CC_TXT_SCREEN__
+
+
+//! Sub class for CTextBox using CComponent classes.
+/*!
+This class contains flags or helpers to control CTextBox screen and paint handling and mostly used by
+CComponentsText and its derivatives and should be implemented as heredity.
+At the moment used in classes with text handlers. e.g. buttons, headers, ext text ...
+*/
+class CCTextScreen
+{
+	protected:
+		///allows to save bg screen behind caption within CTextBox object, default = false
+		bool cc_txt_save_screen;
+
+	public:
+		CCTextScreen(){cc_txt_save_screen = false;};
+};
+
+#endif
diff --git a/src/gui/components/cc_timer.cpp b/src/gui/components/cc_timer.cpp
index a2d30ec..f7cbfa4 100644
--- a/src/gui/components/cc_timer.cpp
+++ b/src/gui/components/cc_timer.cpp
@@ -61,8 +61,8 @@ void* CComponentsTimer::initTimerThread(void *arg)
 	while(timer) {
 		timer->mutex.lock();
 		timer->OnTimer();
-		mySleep(timer->tm_interval);
 		timer->mutex.unlock();
+		mySleep(timer->tm_interval);
 	}
 
 	return 0;
@@ -79,36 +79,39 @@ bool CComponentsTimer::startTimer()
 	if(!tm_thread) {
 		int res = pthread_create (&tm_thread, NULL, initTimerThread, ptr) ;
 		if (res != 0){
-			dprintf(DEBUG_NORMAL,"[CComponentsTimer]    [%s]  pthread_create  %s\n", __func__, strerror(errno));
+			dprintf(DEBUG_NORMAL,"\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_create\033[0m\n", __func__, __LINE__);
 			return false;
 		}
-		dprintf(DEBUG_INFO,"[CComponentsTimer]    [%s]  timer thread [%lu] created with interval = %d\n", __func__, tm_thread, tm_interval);
+		if (res == 0){
+			dprintf(DEBUG_INFO,"\033[33m[CComponentsTimer] [%s - %d]  timer thread [%lu] created with interval = %d\033[0m\n", __func__,  __LINE__, pthread_self(), tm_interval);
+			CNeutrinoApp::getInstance()->OnBeforeRestart.connect(sl);
+		}else{
+			dprintf(DEBUG_NORMAL, "\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_create\033[0m\n", __func__, __LINE__);
+		}
 	}
-
-	//ensure kill of thread on any restart of neutrino
-	CNeutrinoApp::getInstance()->OnBeforeRestart.connect(sl);
 	return  true;
 }
 
 //stop ticking timer and kill thread, return true on succses
 bool CComponentsTimer::stopTimer()
 {
-	int thres = 0;
 	if(tm_thread) {
-		thres = pthread_cancel(tm_thread);
-		dprintf(DEBUG_INFO,"[CComponentsTimer]    [%s] waiting for timer thread terminate ...\n", __func__);
+		int thres = pthread_cancel(tm_thread);
 		if (thres != 0)
-			dprintf(DEBUG_NORMAL,"[CComponentsTimer]    [%s] pthread_cancel  %s\n", __func__, strerror(errno));
+			dprintf(DEBUG_NORMAL,"\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_cancel\033[0m\n", __func__, __LINE__);
+
 		thres = pthread_join(tm_thread, NULL);
+
 		if (thres != 0)
-			dprintf(DEBUG_NORMAL, "[CComponentsTimer]    [%s] pthread_join  %s\n", __func__, strerror(errno));
-	}
-	if (thres == 0){
-		tm_thread = 0;
-		//ensure disconnect of unused slot
-		sl.disconnect();
-		return true;
+			dprintf(DEBUG_NORMAL, "\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_join\033[0m\n", __func__, __LINE__);
+
+		if (thres == 0){
+			tm_thread = 0;
+			//ensure disconnect of unused slot
+			sl.disconnect();
+			dprintf(DEBUG_INFO,"\033[33m[CComponentsTimer]    [%s] timer thread terminated ...\033[0m\n", __func__);
+			return true;
+		}
 	}
-
 	return false;
 }
diff --git a/src/gui/components/cc_types.h b/src/gui/components/cc_types.h
index c861309..58234fe 100644
--- a/src/gui/components/cc_types.h
+++ b/src/gui/components/cc_types.h
@@ -38,7 +38,8 @@ class CComponentsScrollBar;
 ///cc item types
 typedef enum
 {
-	CC_ITEMTYPE_BASE,
+	CC_ITEMTYPE_GENERIC,
+	CC_ITEMTYPE_ITEM,
 	CC_ITEMTYPE_PICTURE,
 	CC_ITEMTYPE_TEXT,
 	CC_ITEMTYPE_TEXT_INFOBOX,
@@ -67,7 +68,7 @@ typedef enum
 }CC_ITEMTYPES_T;
 
 //required typedefs
-typedef struct comp_fbdata_t
+typedef struct cc_fbdata_t
 {
 	int fbdata_type;
 	int x;
@@ -76,10 +77,12 @@ typedef struct comp_fbdata_t
 	int dy;
 	fb_pixel_t color;
 	int r;
+	int rtype;
 	int frame_thickness;
 	fb_pixel_t* pixbuf;
+	gradientData_t *gradient_data;
 	void * data;
-} comp_fbdata_struct_t;
+} cc_fbdata_struct_t;
 
 //fb data object types
 typedef enum
@@ -88,20 +91,33 @@ typedef enum
 	CC_FBDATA_TYPE_BOX,
 	CC_FBDATA_TYPE_SHADOW_BOX,
 	CC_FBDATA_TYPE_FRAME,
-	CC_FBDATA_TYPE_LINE,
 	CC_FBDATA_TYPE_BACKGROUND,
 
 	CC_FBDATA_TYPES
 }FBDATA_TYPES;
 
-typedef struct comp_screen_data_t
+//fb color gradient types
+typedef enum
+{
+	CC_COLGRAD_OFF, 		//no gradient
+	CC_COLGRAD_LIGHT_2_DARK,	//normal one color
+	CC_COLGRAD_DARK_2_LIGHT,	//changed
+	CC_COLGRAD_COL_A_2_COL_B,	//gradient from color A to color B
+	CC_COLGRAD_COL_B_2_COL_A,	//gradient from color B to color A
+	CC_COLGRAD_COL_LIGHT_DARK_LIGHT,		//gradient from color A to B to A
+	CC_COLGRAD_COL_DARK_LIGHT_DARK,		//gradient from color B to A to B
+
+	CC_COLGRAD_TYPES
+}COLOR_GRADIENT_TYPES;
+
+typedef struct cc_screen_data_t
 {
 	int x;
 	int y;
 	int dx;
 	int dy;
 	fb_pixel_t* pixbuf;
-} comp_screen_data_struct_t;
+} cc_screen_data_struct_t;
 
 //combination of rc messages with related icon
 typedef struct msg_list_t
@@ -136,7 +152,7 @@ enum
 	CC_ITEMBOX_CLOCK
 };
 
-typedef struct comp_element_data_t
+typedef struct cc_element_data_t
 {
 	int		type;
 	int		align;
@@ -147,22 +163,22 @@ typedef struct comp_element_data_t
 	int		height;
 	void*		handler1;
 	void*		handler2;
-}comp_element_data_struct_t;
+}cc_element_data_struct_t;
 
-//text lebel types
-typedef struct locale_ext_txt_t
+//text label types
+typedef struct cc_locale_ext_txt_t
 {
 	neutrino_locale_t label_text;
 	neutrino_locale_t text;
 	Font* font;
-} locale_ext_txt_struct_t;
+} cc_locale_ext_txt_struct_t;
 
-typedef struct string_ext_txt_t
+typedef struct cc_string_ext_txt_t
 {
 	std::string label_text;
 	std::string text;
 	Font* font;
-} string_ext_txt_struct_t;
+} cc_string_ext_txt_struct_t;
 
 #define CC_WIDTH_MIN		16
 #define CC_HEIGHT_MIN		16
diff --git a/src/gui/eventlist.cpp b/src/gui/eventlist.cpp
index c83a4f4..922c2cd 100644
--- a/src/gui/eventlist.cpp
+++ b/src/gui/eventlist.cpp
@@ -855,7 +855,7 @@ void CEventList::paintHead(t_channel_id _channel_id, std::string _channelname, s
 	int font_lr  = SNeutrinoSettings::FONT_TYPE_EVENTLIST_ITEMLARGE;
 
 	CComponentsFrmChain header(x, y, full_width, theight);
-	header.enableColBodyGradient(g_settings.theme.menu_Head_gradient);
+	header.enableColBodyGradient(g_settings.theme.menu_Hint_gradient, COL_MENUCONTENT_PLUS_0);
 	header.setCorner(RADIUS_LARGE, CORNER_TOP);
 
 	int x_off = 10;
diff --git a/src/gui/infoclock.cpp b/src/gui/infoclock.cpp
index be6cb15..0ab0bab 100644
--- a/src/gui/infoclock.cpp
+++ b/src/gui/infoclock.cpp
@@ -4,7 +4,7 @@
 
 	Info Clock Window
 	based up CComponentsFrmClock
-	Copyright (C) 2013, Thilo Graf 'dbt'
+	Copyright (C) 2013, 2014, Thilo Graf 'dbt'
 	Copyright (C) 2013, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -36,9 +36,9 @@
 
 
 
-CInfoClock::CInfoClock():CComponentsFrmClock( 0, 0, 0, 50, "%H:%M:%S", true, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
+CInfoClock::CInfoClock():CComponentsFrmClock( 0, 0, 0, g_settings.infoClockFontSize, "%H:%M:%S", NULL, false, 1, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
 {
-	initVarInfoClock();
+	initCCLockItems();
 }
 
 CInfoClock* CInfoClock::getInstance()
@@ -49,27 +49,16 @@ CInfoClock* CInfoClock::getInstance()
 	return InfoClock;
 }
 
-void CInfoClock::initVarInfoClock()
-{
-	Init();
-}
-
-void CInfoClock::Init()
+void CInfoClock::initCCLockItems()
 {
-	static int oldSize = 0;
-	if (oldSize != g_settings.infoClockFontSize) {
-		oldSize = g_settings.infoClockFontSize;
-		setClockFontSize(g_settings.infoClockFontSize);
-	}
-
 	//use current theme colors
-	syncSysColors();
+	setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENT_PLUS_0, COL_MENUCONTENTDARK_PLUS_0);
 
 	//set text color
 	if (g_settings.infoClockBackground)
-		setTextColor(COL_MENUCONTENT_TEXT);
+		cl_col_text = COL_MENUCONTENT_TEXT;
 	else
-		setTextColor(COL_INFOCLOCK_TEXT);
+		cl_col_text = COL_INFOCLOCK_TEXT;
 
 	paint_bg = true;
 	if (g_settings.infoClockBackground)
@@ -77,40 +66,36 @@ void CInfoClock::Init()
 	else
 		setColorBody(COL_BACKGROUND_PLUS_0);
 
-	setShadowOnOff(g_settings.infoClockBackground);
-
 	if (g_settings.infoClockSeconds)
 		setClockFormat("%H:%M:%S");
-	else {
-		setClockFormat("%H:%M");
-		setClockBlink("%H %M");
-	}
+	else
+		setClockFormat("%H:%M", "%H %M");
 
-	int x_old = x, y_old = y, width_old = width, height_old = height;
+	int x_old = x, y_old = y, width_old = width;
 	CVolumeHelper::getInstance()->refresh(cl_font);
 	CVolumeHelper::getInstance()->getInfoClockDimensions(&x, &y, &width, &height);
-	if ((x_old != x) || (y_old != y) || (width_old != width) || (height_old != height))
+	if ((x_old != x) || (y_old != y) || (width_old != width))
 		clear();
 
 	// set corner radius depending on clock height
 	corner_rad = (g_settings.rounded_corners) ? std::max(height/10, CORNER_RADIUS_SMALL) : 0;
 
-	initCCLockItems();
+	CComponentsFrmClock::initCCLockItems();
 }
 
 void CInfoClock::ClearDisplay()
 {
 	kill();
-	Init();
+	initCCLockItems();
 }
 
-bool CInfoClock::StartClock()
+bool CInfoClock::StartInfoClock()
 {
-	Init();
+	initCCLockItems();
 	return Start();
 }
 
-bool CInfoClock::StopClock()
+bool CInfoClock::StopInfoClock()
 {
 	bool ret = Stop();
 	kill();
@@ -124,12 +109,21 @@ bool CInfoClock::enableInfoClock(bool enable)
 	if (g_settings.mode_clock) {
 		if (enable) {
 			if (!paintClock)
-				ret = StartClock();
+				ret = StartInfoClock();
 		}
 		else {
 			if (paintClock)
-				ret = StopClock();
+				ret = StopInfoClock();
 		}
 	}
 	return ret;
 }
+
+//switching clock on or off depends of current displayed or not
+void CInfoClock::switchClockOnOff()
+{
+	if(g_settings.mode_clock)
+		g_settings.mode_clock = false;
+	else
+		g_settings.mode_clock = true;
+}
diff --git a/src/gui/infoclock.h b/src/gui/infoclock.h
index 5fb6f31..70d57d0 100644
--- a/src/gui/infoclock.h
+++ b/src/gui/infoclock.h
@@ -34,21 +34,22 @@
 
 class CInfoClock : public CComponentsFrmClock
 {
-	protected:
-		void initVarInfoClock();
 	private:
-		void		Init();
+		void		initCCLockItems();
 	public:
 		CInfoClock();
 	// 	~CInfoClock(); // inherited from CComponentsFrmClock
 		static		CInfoClock* getInstance();
 
-		bool 		StartClock();
-		bool 		StopClock();
-		bool		enableInfoClock(bool enable);
+		bool 		StartInfoClock();
+		bool 		StopInfoClock();
+		bool		enableInfoClock(bool enable = true);
+		bool		disableInfoClock() {return enableInfoClock(false);}
+		void		block() {disableInfoClock();}
 		void		ClearDisplay();
 
 		bool		getStatus(void) { return paintClock; }
+		static void	switchClockOnOff();
 };
 
 #endif
diff --git a/src/gui/infoviewer.cpp b/src/gui/infoviewer.cpp
index b0e30b4..c490cdf 100644
--- a/src/gui/infoviewer.cpp
+++ b/src/gui/infoviewer.cpp
@@ -248,36 +248,33 @@ void CInfoViewer::initClock()
 {
 
 	static int gradient_top = g_settings.theme.infobar_gradient_top;
-	static int gradient_c2c = g_settings.theme.gradient_c2c;
 
-	if ((gradient_top != g_settings.theme.infobar_gradient_top || gradient_c2c != g_settings.theme.gradient_c2c) && clock != NULL) {
+	if ((gradient_top != g_settings.theme.infobar_gradient_top) && clock != NULL) {
 		gradient_top = g_settings.theme.infobar_gradient_top;
-		gradient_c2c = g_settings.theme.gradient_c2c;
-		clock->clearSavedScreen();
+		clock->clearSavedScreen(); //FIXME: statement has no effect
 		delete clock;
 		clock = NULL;
 	}
 
 	if (clock == NULL){
 		clock = new CComponentsFrmClock();
-		clock->setClockBlink("%H.%M");
+		clock->setClockFormat("%H:%M", "%H %M");
 		clock->setClockIntervall(1);
 		clock->doPaintBg(!gradient_top);
-		clock->enableTboxSaveScreen(gradient_top);
+		clock->enableSegmentSaveScreen(gradient_top);
 		if (time_width)
 			clock->setWidth(time_width);
 	}
 
+	InfoClock->getInstance()->disableInfoClock();
+
 	clock->setColorBody(COL_INFOBAR_PLUS_0);
 	clock->setCorner(RADIUS_LARGE, CORNER_TOP_RIGHT);
-	clock->setClockFont(SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME);
-	clock->setClockAlignment(CC_ALIGN_RIGHT | CC_ALIGN_BOTTOM);
+	clock->setClockFont(g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME]);
 	clock->refresh();
-
 	clock->setPos(BoxEndX - 10 - clock->getWidth(), ChanNameY);
 	clock->setTextColor(COL_INFOBAR_TEXT);
-	clock->setClockFormat("%H:%M");
-	clock->setClockBlink("%H %M");
+	clock->setClockFormat("%H:%M", "%H %M");
 }
 
 void CInfoViewer::showRecordIcon (const bool show)
@@ -423,8 +420,7 @@ void CInfoViewer::paintHead()
 	CComponentsShapeSquare header(ChanInfoX, ChanNameY, BoxEndX-ChanInfoX, time_height);
 
 	header.setColorBody(g_settings.theme.infobar_gradient_top ? COL_MENUHEAD_PLUS_0 : COL_INFOBAR_PLUS_0);
-	header.enableColBodyGradient(g_settings.theme.infobar_gradient_top);
-	header.set2ndColor(COL_INFOBAR_PLUS_0);
+	header.enableColBodyGradient(g_settings.theme.infobar_gradient_top, COL_INFOBAR_PLUS_0);
 	header.setCorner(RADIUS_LARGE, CORNER_TOP_RIGHT);
 	clock->setColorBody(header.getColorBody());
 
@@ -1966,6 +1962,7 @@ void CInfoViewer::killTitle()
 		killInfobarText();
 	}
 	showButtonBar = false;
+	InfoClock->getInstance()->enableInfoClock();
 }
 
 #if 0
diff --git a/src/gui/luainstance.cpp b/src/gui/luainstance.cpp
index b09badc..4b43a74 100644
--- a/src/gui/luainstance.cpp
+++ b/src/gui/luainstance.cpp
@@ -1843,7 +1843,7 @@ int CLuaInstance::CWindowHide(lua_State *L)
 			paramBoolDeprecated(L, tmp.c_str());
 		no_restore = (tmp == "true" || tmp == "1" || tmp == "yes");
 	}
-	m->w->hide(no_restore);
+	m->w->hide(); //FIXME: no_restore without effect, remove it or use with kill()?
 	return 0;
 }
 
@@ -2167,7 +2167,7 @@ int CLuaInstance::ComponentsTextHide(lua_State *L)
 		m->ct->setText("", m->mode, g_Font[m->font_text]);
 		m->ct->paint();
 	} else
-		m->ct->hide(no_restore);
+		m->ct->hide(); //FIXME: no_restore without effect, remove or use with kill()
 	return 0;
 }
 
@@ -2340,7 +2340,7 @@ int CLuaInstance::CPictureHide(lua_State *L)
 		m->cp->setPicture("");
 		m->cp->paint();
 	} else
-		m->cp->hide(no_restore);
+		m->cp->hide(); //FIXME: no_restore without effect, remove or use with kill()
 	return 0;
 }
 
diff --git a/src/gui/osd_setup.cpp b/src/gui/osd_setup.cpp
index 5cd3be4..f4a4519 100644
--- a/src/gui/osd_setup.cpp
+++ b/src/gui/osd_setup.cpp
@@ -461,6 +461,18 @@ const CMenuOptionChooser::keyval OPTIONS_COLORED_EVENTS_OPTIONS[OPTIONS_COLORED_
 	{ 2, LOCALE_MISCSETTINGS_COLORED_EVENTS_2 },	//next
 };
 
+#define OPTIONS_COL_GRADIENT_OPTIONS_COUNT CC_COLGRAD_TYPES 	//TODO: add modes for direction and intensity
+const CMenuOptionChooser::keyval OPTIONS_COL_GRADIENT_OPTIONS[OPTIONS_COL_GRADIENT_OPTIONS_COUNT] =
+{
+	{ CC_COLGRAD_OFF			, LOCALE_OPTIONS_OFF },
+	{ CC_COLGRAD_COL_A_2_COL_B		, LOCALE_COLOR_GRADIENT_A2B  }, //color A to color B
+	{ CC_COLGRAD_COL_B_2_COL_A		, LOCALE_COLOR_GRADIENT_B2A  }, //color B to color A
+	{ CC_COLGRAD_LIGHT_2_DARK		, LOCALE_COLOR_GRADIENT_L2D  }, //light to dark
+	{ CC_COLGRAD_DARK_2_LIGHT		, LOCALE_COLOR_GRADIENT_D2L  }, //dark to light
+	{ CC_COLGRAD_COL_LIGHT_DARK_LIGHT	, LOCALE_COLOR_GRADIENT_LDL  }, //light dark light
+	{ CC_COLGRAD_COL_DARK_LIGHT_DARK	, LOCALE_COLOR_GRADIENT_DLD  }, //dark light dark
+};
+
 /* these are more descriptive... */
 #define _LOCALE_PROGRESSBAR_COLOR_MATRIX        LOCALE_MISCSETTINGS_PROGRESSBAR_DESIGN_0
 #define _LOCALE_PROGRESSBAR_COLOR_VERTICAL      LOCALE_MISCSETTINGS_PROGRESSBAR_DESIGN_1
@@ -627,7 +639,7 @@ int COsdSetup::showOsdSetup()
 		CVolumeHelper::getInstance()->refresh();
 
 	if (oldInfoClockSize != g_settings.infoClockFontSize) {
-		CInfoClock::getInstance()->setClockFontSize(g_settings.infoClockFontSize);
+		CInfoClock::getInstance()->setHeight(g_settings.infoClockFontSize);
 		CVolumeHelper::getInstance()->refresh();
 		if (CNeutrinoApp::getInstance()->isMuted()) {
 			CAudioMute::getInstance()->enableMuteIcon(false);
@@ -677,11 +689,13 @@ void COsdSetup::showOsdMenueColorSetup(CMenuWidget *menu_colors)
 	menu_colors->addItem( new CMenuSeparator(CMenuSeparator::LINE | CMenuSeparator::STRING, LOCALE_COLORMENUSETUP_MENUHEAD));
 
 	CMenuOptionChooser *oj;
+#if 0
 	oj = new CMenuOptionChooser(LOCALE_COLOR_GRADIENT_C2C, &g_settings.theme.gradient_c2c, OPTIONS_OFF0_ON1_OPTIONS, OPTIONS_OFF0_ON1_OPTION_COUNT, true );
 	oj->OnAfterChangeOption.connect(slot_repaint);
 	oj->setHint("", LOCALE_MENU_HINT_COLOR_GRADIENT_C2C);
 	menu_colors->addItem(oj);
 	menu_colors->addItem( new CMenuSeparator(CMenuSeparator::LINE));
+#endif
 
 	mf = new CMenuDForwarder(LOCALE_COLORMENU_BACKGROUND, true, NULL, chHeadcolor );
 	mf->setHint("", LOCALE_MENU_HINT_HEAD_BACK);
@@ -692,7 +706,7 @@ void COsdSetup::showOsdMenueColorSetup(CMenuWidget *menu_colors)
 	menu_colors->addItem(mf);
 
 	// head color gradient
-	oj = new CMenuOptionChooser(LOCALE_COLOR_GRADIENT, &g_settings.theme.menu_Head_gradient, OPTIONS_OFF0_ON1_OPTIONS, OPTIONS_OFF0_ON1_OPTION_COUNT, true );
+	oj = new CMenuOptionChooser(LOCALE_COLOR_GRADIENT, &g_settings.theme.menu_Head_gradient, OPTIONS_COL_GRADIENT_OPTIONS, OPTIONS_COL_GRADIENT_OPTIONS_COUNT, true );
 	oj->OnAfterChangeOption.connect(slot_repaint);
 	oj->setHint("", LOCALE_MENU_HINT_COLOR_GRADIENT);
 	menu_colors->addItem(oj);
@@ -726,7 +740,7 @@ void COsdSetup::showOsdMenueColorSetup(CMenuWidget *menu_colors)
 
 	// hintbox color gradient
 	menu_colors->addItem( new CMenuSeparator(CMenuSeparator::LINE | CMenuSeparator::STRING, LOCALE_COLORTHEMEMENU_MENU_HINTS));
-	oj = new CMenuOptionChooser(LOCALE_COLOR_GRADIENT, &t.menu_Hint_gradient, OPTIONS_OFF0_ON1_OPTIONS, OPTIONS_OFF0_ON1_OPTION_COUNT, true);
+	oj = new CMenuOptionChooser(LOCALE_COLOR_GRADIENT, &t.menu_Hint_gradient, OPTIONS_COL_GRADIENT_OPTIONS, OPTIONS_COL_GRADIENT_OPTIONS_COUNT, true);
 	oj->OnAfterChangeOption.connect(slot_repaint);
 	oj->setHint("", LOCALE_MENU_HINT_COLOR_GRADIENT);
 	menu_colors->addItem(oj);
@@ -747,12 +761,12 @@ void COsdSetup::showOsdMenueColorSetup(CMenuWidget *menu_colors)
 	menu_colors->addItem(mf);
 
 	// infoviewer gradient top
-	oj = new CMenuOptionChooser(LOCALE_MISCSETTINGS_INFOBAR_GRADIENT_TOP, &t.infobar_gradient_top, OPTIONS_OFF0_ON1_OPTIONS, OPTIONS_OFF0_ON1_OPTION_COUNT, true);
+	oj = new CMenuOptionChooser(LOCALE_MISCSETTINGS_INFOBAR_GRADIENT_TOP, &t.infobar_gradient_top, OPTIONS_COL_GRADIENT_OPTIONS, OPTIONS_COL_GRADIENT_OPTIONS_COUNT, true);
 	oj->setHint("", LOCALE_MENU_HINT_COLOR_GRADIENT);
 	menu_colors->addItem(oj);
 
 	// infoviewer gradient bottom
-	oj = new CMenuOptionChooser(LOCALE_MISCSETTINGS_INFOBAR_GRADIENT_BOTTOM, &t.infobar_gradient_bottom, OPTIONS_OFF0_ON1_OPTIONS, OPTIONS_OFF0_ON1_OPTION_COUNT, true);
+	oj = new CMenuOptionChooser(LOCALE_MISCSETTINGS_INFOBAR_GRADIENT_BOTTOM, &t.infobar_gradient_bottom, OPTIONS_COL_GRADIENT_OPTIONS, OPTIONS_COL_GRADIENT_OPTIONS_COUNT, true);
 	oj->setHint("", LOCALE_MENU_HINT_COLOR_GRADIENT);
 	menu_colors->addItem(oj);
 
@@ -1223,11 +1237,16 @@ bool COsdSetup::changeNotify(const neutrino_locale_t OptionName, void * data)
 	return false;
 }
 
-int COsdSetup::showContextChanlistMenu()
+int COsdSetup::showContextChanlistMenu(CChannelList *parent_channellist)
 {
 	static int cselected = -1;
 
 	CMenuWidget * menu_chanlist = new CMenuWidget(LOCALE_MAINMENU_SETTINGS, NEUTRINO_ICON_SETTINGS, width);
+
+	//using native callback to ensure stop header clock in parent channellist before paint this menu window
+	if (parent_channellist && g_settings.menu_pos == CMenuWidget::MENU_POS_TOP_RIGHT)
+		menu_chanlist->OnBeforePaint.connect(sigc::mem_fun(parent_channellist->getHeaderObject()->getClockObject(), &CComponentsFrmClock::block));
+
 	menu_chanlist->enableSaveScreen(true);
 	menu_chanlist->enableFade(false);
 	menu_chanlist->setSelected(cselected);
diff --git a/src/gui/osd_setup.h b/src/gui/osd_setup.h
index a461957..ea1335b 100644
--- a/src/gui/osd_setup.h
+++ b/src/gui/osd_setup.h
@@ -99,7 +99,7 @@ class COsdSetup : public CMenuTarget, public CChangeObserver
 		~COsdSetup();
 		int exec(CMenuTarget* parent, const std::string & actionKey);
 		bool changeNotify(const neutrino_locale_t OptionName, void * /*data*/);
-		int showContextChanlistMenu();
+		int showContextChanlistMenu(CChannelList *parent_channellist = NULL);
 };
 
 #endif
diff --git a/src/gui/streaminfo2.cpp b/src/gui/streaminfo2.cpp
index 490c41e..da0a489 100644
--- a/src/gui/streaminfo2.cpp
+++ b/src/gui/streaminfo2.cpp
@@ -247,7 +247,7 @@ int CStreamInfo2::doSignalStrengthLoop ()
 
 void CStreamInfo2::hide ()
 {
-	pip->hide(true);
+	pip->hide();
 	frameBuffer->paintBackgroundBoxRel (0, 0, max_width, max_height);
 }
 
diff --git a/src/gui/test_menu.cpp b/src/gui/test_menu.cpp
index 109155f..8d5d4b1 100644
--- a/src/gui/test_menu.cpp
+++ b/src/gui/test_menu.cpp
@@ -495,9 +495,12 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 			header->addContextButton(NEUTRINO_ICON_BUTTON_RED);
 			header->addContextButton(CComponentsHeader::CC_BTN_HELP | CComponentsHeader::CC_BTN_EXIT | CComponentsHeader::CC_BTN_MENU);
 		}
-		else	//For existing instances it's recommended to remove old button icons before add new buttons,
+		else{	//For existing instances it's recommended to remove old button icons before add new buttons,
 			//otherwise icons will be appended to already existant icons, alternatively use the setContextButton() methode
  			header->removeContextButtons();
+			//enable clock in header with default format
+			header->enableClock(true, "%H:%M", "%H %M", true);
+		}
 
 //		example to manipulate header items
 // 		header->setFrameThickness(5);
@@ -534,10 +537,13 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 // 		header->insertCCItem(1, logo); //replace text with logo
 
 		
-		if (!header->isPainted())
+		if (!header->isPainted()){
 			header->paint();
-		else
+		}
+		else{
 			header->hide();
+		}
+			
 		return res;
 	}
 	else if (actionKey == "footer"){
@@ -672,8 +678,8 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 	}
 	else if (actionKey == "running_clock"){	
 		if (clock_r == NULL){
-			clock_r = new CComponentsFrmClock(100, 50, 0, 50, "%H.%M:%S", true);
-			clock_r->setClockFont(SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME);
+			clock_r = new CComponentsFrmClock(100, 50, 0, 50, "%H.%M:%S", NULL, true);
+			clock_r->setClockFont(g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME]);
 			clock_r->setClockIntervall(1);
 // 			clock_r->doPaintBg(false);
 		}
@@ -684,7 +690,7 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 		}
 		else {
 			if (clock_r->Stop()){
-				clock_r->hide();
+				clock_r->kill();
 				delete clock_r;
 				clock_r = NULL;
 				return menu_return::RETURN_EXIT_ALL;
@@ -693,8 +699,8 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 	}
 	else if (actionKey == "clock"){
 		if (clock == NULL){
-			clock = new CComponentsFrmClock(100, 50, 0, 50, "%H:%M", false);
-			clock->setClockFont(SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME);
+			clock = new CComponentsFrmClock(100, 50, 0, 50, "%d.%m.%Y-%H:%M");
+			clock->setClockFont(g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME]);
 		}
 
 		if (!clock->isPainted())
diff --git a/src/gui/themes.cpp b/src/gui/themes.cpp
index f8e4d58..924d9c8 100644
--- a/src/gui/themes.cpp
+++ b/src/gui/themes.cpp
@@ -243,7 +243,9 @@ void CThemes::setTheme(CConfigFile &configfile)
 	configfile.setInt32( "menu_Head_Text_red", t.menu_Head_Text_red );
 	configfile.setInt32( "menu_Head_Text_green", t.menu_Head_Text_green );
 	configfile.setInt32( "menu_Head_Text_blue", t.menu_Head_Text_blue );
+
 	configfile.setInt32( "menu_Head_gradient" , t.menu_Head_gradient);
+
 	configfile.setInt32( "menu_Content_alpha", t.menu_Content_alpha );
 	configfile.setInt32( "menu_Content_red", t.menu_Content_red );
 	configfile.setInt32( "menu_Content_green", t.menu_Content_green );
@@ -268,17 +270,22 @@ void CThemes::setTheme(CConfigFile &configfile)
 	configfile.setInt32( "menu_Content_inactive_Text_red", t.menu_Content_inactive_Text_red );
 	configfile.setInt32( "menu_Content_inactive_Text_green", t.menu_Content_inactive_Text_green );
 	configfile.setInt32( "menu_Content_inactive_Text_blue", t.menu_Content_inactive_Text_blue );
+
 	configfile.setInt32( "menu_Hint_gradient" , t.menu_Hint_gradient);
+	configfile.setInt32( "menu_ButtonBar_gradient" , t.menu_ButtonBar_gradient);
+
 	configfile.setInt32( "infobar_alpha", t.infobar_alpha );
 	configfile.setInt32( "infobar_red", t.infobar_red );
 	configfile.setInt32( "infobar_green", t.infobar_green );
 	configfile.setInt32( "infobar_blue", t.infobar_blue );
-	configfile.setInt32( "infobar_gradient_top", t.infobar_gradient_top );
-	configfile.setInt32( "infobar_gradient_bottom", t.infobar_gradient_bottom );
 	configfile.setInt32( "infobar_Text_alpha", t.infobar_Text_alpha );
 	configfile.setInt32( "infobar_Text_red", t.infobar_Text_red );
 	configfile.setInt32( "infobar_Text_green", t.infobar_Text_green );
 	configfile.setInt32( "infobar_Text_blue", t.infobar_Text_blue );
+
+	configfile.setInt32( "infobar_gradient_top", t.infobar_gradient_top );
+	configfile.setInt32( "infobar_gradient_bottom", t.infobar_gradient_bottom );
+
 	configfile.setInt32( "colored_events_alpha", t.colored_events_alpha );
 	configfile.setInt32( "colored_events_red", t.colored_events_red );
 	configfile.setInt32( "colored_events_green", t.colored_events_green );
@@ -290,7 +297,6 @@ void CThemes::setTheme(CConfigFile &configfile)
 	configfile.setInt32( "clock_Digit_red", t.clock_Digit_red );
 	configfile.setInt32( "clock_Digit_green", t.clock_Digit_green );
 	configfile.setInt32( "clock_Digit_blue", t.clock_Digit_blue );
-	configfile.setInt32( "gradient_c2c", t.gradient_c2c );
 }
 
 void CThemes::getTheme(CConfigFile &configfile)
@@ -304,7 +310,9 @@ void CThemes::getTheme(CConfigFile &configfile)
 	t.menu_Head_Text_red = configfile.getInt32( "menu_Head_Text_red", 0x5f );
 	t.menu_Head_Text_green = configfile.getInt32( "menu_Head_Text_green", 0x46 );
 	t.menu_Head_Text_blue = configfile.getInt32( "menu_Head_Text_blue", 0x00 );
-	t.menu_Head_gradient = configfile.getInt32( "menu_Head_gradient", 1);
+
+	t.menu_Head_gradient = configfile.getInt32( "menu_Head_gradient", CC_COLGRAD_LIGHT_2_DARK);
+
 	t.menu_Content_alpha = configfile.getInt32( "menu_Content_alpha", 0x14 );
 	t.menu_Content_red = configfile.getInt32( "menu_Content_red", 0x00 );
 	t.menu_Content_green = configfile.getInt32( "menu_Content_green", 0x0f );
@@ -329,28 +337,34 @@ void CThemes::getTheme(CConfigFile &configfile)
 	t.menu_Content_inactive_Text_red = configfile.getInt32( "menu_Content_inactive_Text_red", 55 );
 	t.menu_Content_inactive_Text_green = configfile.getInt32( "menu_Content_inactive_Text_green", 70 );
 	t.menu_Content_inactive_Text_blue = configfile.getInt32( "menu_Content_inactive_Text_blue", 85 );
-	t.menu_Hint_gradient = configfile.getInt32( "menu_Hint_gradient", 0);
+
+	t.menu_Hint_gradient = configfile.getInt32( "menu_Hint_gradient", CC_COLGRAD_OFF);
+	t.menu_ButtonBar_gradient = configfile.getInt32( "menu_ButtonBar_gradient", CC_COLGRAD_OFF);
+
 	t.infobar_alpha = configfile.getInt32( "infobar_alpha", 0x14 );
 	t.infobar_red = configfile.getInt32( "infobar_red", 0x00 );
 	t.infobar_green = configfile.getInt32( "infobar_green", 0x0e );
 	t.infobar_blue = configfile.getInt32( "infobar_blue", 0x23 );
-	t.infobar_gradient_top = configfile.getInt32( "infobar_gradient_top", 0 );
-	t.infobar_gradient_bottom = configfile.getInt32( "infobar_gradient_bottom", 0 );
+
+	t.infobar_gradient_top = configfile.getInt32( "infobar_gradient_top", CC_COLGRAD_OFF );
+	t.infobar_gradient_bottom = configfile.getInt32( "infobar_gradient_bottom", CC_COLGRAD_OFF );
+
 	t.infobar_Text_alpha = configfile.getInt32( "infobar_Text_alpha", 0x00 );
 	t.infobar_Text_red = configfile.getInt32( "infobar_Text_red", 0x64 );
 	t.infobar_Text_green = configfile.getInt32( "infobar_Text_green", 0x64 );
 	t.infobar_Text_blue = configfile.getInt32( "infobar_Text_blue", 0x64 );
+
 	t.colored_events_alpha = configfile.getInt32( "colored_events_alpha", 0x00 );
 	t.colored_events_red = configfile.getInt32( "colored_events_red", 95 );
 	t.colored_events_green = configfile.getInt32( "colored_events_green", 70 );
 	t.colored_events_blue = configfile.getInt32( "colored_events_blue", 0 );
 	t.colored_events_channellist = configfile.getInt32( "colored_events_channellist", 0 );
+
 	t.colored_events_infobar = configfile.getInt32( "colored_events_infobar", 2 );
 	t.clock_Digit_alpha = configfile.getInt32( "clock_Digit_alpha", t.menu_Content_Text_alpha );
 	t.clock_Digit_red = configfile.getInt32( "clock_Digit_red", t.menu_Content_Text_red );
 	t.clock_Digit_green = configfile.getInt32( "clock_Digit_green", t.menu_Content_Text_green );
 	t.clock_Digit_blue = configfile.getInt32( "clock_Digit_blue", t.menu_Content_Text_blue );
-	t.gradient_c2c = configfile.getInt32( "gradient_c2c", 0 );
 }
 
 void CThemes::move_userDir()
diff --git a/src/gui/timeosd.cpp b/src/gui/timeosd.cpp
index 57f136e..d3fcf7c 100644
--- a/src/gui/timeosd.cpp
+++ b/src/gui/timeosd.cpp
@@ -36,7 +36,7 @@
 
 
 
-CTimeOSD::CTimeOSD():CComponentsFrmClock( 0, 0, 0, 50, "%H:%M:%S", false, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
+CTimeOSD::CTimeOSD():CComponentsFrmClock( 0, 0, 0, g_settings.infoClockFontSize, "%H:%M:%S", NULL, false, 1, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
 {
 	Init();
 }
@@ -50,11 +50,11 @@ void CTimeOSD::Init()
 
 	if (oldSize != g_settings.infoClockFontSize) {
 		oldSize = g_settings.infoClockFontSize;
-		setClockFontSize(g_settings.infoClockFontSize);
+		height = g_settings.infoClockFontSize;
 	}
 
 	//use current theme colors
-	syncSysColors();
+	setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENT_PLUS_0, COL_MENUCONTENT_PLUS_6);
 
 	paint_bg = g_settings.infoClockBackground;
 
@@ -85,13 +85,10 @@ CTimeOSD::~CTimeOSD()
 void CTimeOSD::initTimeString()
 {
 	struct tm t;
-	if (m_mode == MODE_DESC) {
-		char tt[20];
-		strftime(tt, sizeof(tt), cl_format_str, gmtime_r(&m_time_show, &t));
-		snprintf(cl_timestr, sizeof(cl_timestr), "-%s", tt);
-	}
-	else
-		strftime(cl_timestr, sizeof(cl_timestr), cl_format_str, gmtime_r(&m_time_show, &t));
+	toggleFormat();
+	if (m_mode == MODE_DESC)
+		cl_format = "-" + cl_format;
+	strftime((char*) &cl_timestr, sizeof(cl_timestr), cl_format.c_str(), gmtime_r(&m_time_show, &t));
 }
 
 void CTimeOSD::show(time_t time_show, bool force)
@@ -101,7 +98,7 @@ void CTimeOSD::show(time_t time_show, bool force)
 		return;
 	m_time_show = time_show;
 
-	syncSysColors();
+	setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENT_PLUS_0, COL_MENUCONTENT_PLUS_6);//use current theme colors
 
 	paint_bg = true;
 	if (g_settings.infoClockBackground)
@@ -124,7 +121,6 @@ void CTimeOSD::updatePos(int position, int duration)
 
 	timescale.setProgress(x, y + height/4, width, height/2, percent, 100);
 	timescale.paint();
-	frameBuffer->blit();
 }
 
 void CTimeOSD::update(int position, int duration)
@@ -157,7 +153,6 @@ void CTimeOSD::switchMode(int position, int duration)
 			break;
 		case MODE_BAR:
 			KillAndResetTimescale();
-			frameBuffer->blit();
 			return;
 		default:
 			m_mode = MODE_ASC;
diff --git a/src/gui/timerlist.cpp b/src/gui/timerlist.cpp
index b655292..9064241 100644
--- a/src/gui/timerlist.cpp
+++ b/src/gui/timerlist.cpp
@@ -870,8 +870,8 @@ void CTimerList::paintItem(int pos)
 
 void CTimerList::paintHead()
 {
-	CComponentsHeaderLocalized header(x, y, width, theight, LOCALE_TIMERLIST_NAME, NEUTRINO_ICON_TIMER);
-	header.setShadowOnOff(CC_SHADOW_ON);
+	CComponentsHeaderLocalized header(x, y, width, theight, LOCALE_TIMERLIST_NAME, NEUTRINO_ICON_TIMER, CComponentsHeader::CC_BTN_EXIT, NULL, CC_SHADOW_ON);
+	header.enableClock(true, "%d.%m.%Y %H:%M");
 	header.paint(CC_SAVE_SCREEN_NO);
 }
 
diff --git a/src/gui/user_menue.cpp b/src/gui/user_menue.cpp
index 96a3338..d2962d9 100644
--- a/src/gui/user_menue.cpp
+++ b/src/gui/user_menue.cpp
@@ -163,15 +163,21 @@ bool CUserMenu::showUserMenu(neutrino_msg_t msg)
 	if (menu == NULL)
 		return true;
 
+	/*
+	using native callback to ensure paint for info clock after hide of this menu window
+	menu->hide() handler comes too early, nice to see if clock is transparent.
+	*/
+	menu->OnAfterHide.connect(sigc::mem_fun(CInfoClock::getInstance(), &CInfoClock::block));
+
 	if (button < COL_BUTTONMAX)	
 		menu->setSelected(user_menu[button].selected);
-	
+
 	//show cancel button if configured
 	if (g_settings.personalize[SNeutrinoSettings::P_UMENU_SHOW_CANCEL])
 		menu->addIntroItems(NONEXISTANT_LOCALE, NONEXISTANT_LOCALE, CMenuWidget::BTN_TYPE_CANCEL);
 	else
 		menu->addItem(GenericMenuSeparator);
-	
+
 	std::string itemstr_last("1");
 
 	std::vector<std::string> items = ::split(g_settings.usermenu[button]->items, ',');
@@ -452,7 +458,6 @@ bool CUserMenu::showUserMenu(neutrino_msg_t msg)
 
 	extern CInfoClock *InfoClock;
 	InfoClock->enableInfoClock(false);
-
 	// show menu if there are more than 2 items only
 	// otherwise, we start the item directly (must be the last one)
 	if (menu_items > 1 )
diff --git a/src/gui/volumebar.cpp b/src/gui/volumebar.cpp
index 66e6a58..98ca91c 100644
--- a/src/gui/volumebar.cpp
+++ b/src/gui/volumebar.cpp
@@ -270,7 +270,7 @@ CVolumeHelper::CVolumeHelper()
 	Init();
 }
 
-void CVolumeHelper::Init(Font** font)
+void CVolumeHelper::Init(Font* font)
 {
 
 	x  = frameBuffer->getScreenX() + h_spacer;
@@ -283,11 +283,11 @@ void CVolumeHelper::Init(Font** font)
 	initInfoClock(font);
 }
 
-void CVolumeHelper::initInfoClock(Font** font)
+void CVolumeHelper::initInfoClock(Font* font)
 {
 	if (clock_font == NULL){
 		if (font == NULL) {
-			clock_font = &g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE];
+			clock_font = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE];
 		}
 		else
 			clock_font = font;
@@ -296,10 +296,10 @@ void CVolumeHelper::initInfoClock(Font** font)
 		if (font != NULL)
 			clock_font = font;
 	}
-	digit_offset = (*clock_font)->getDigitOffset();
-	digit_h      = (*clock_font)->getDigitHeight();
-	int t1       = (*clock_font)->getMaxDigitWidth();
-	int t2       = (*clock_font)->getRenderWidth(":");
+	digit_offset = (clock_font)->getDigitOffset();
+	digit_h      = (clock_font)->getDigitHeight();
+	int t1       = (clock_font)->getMaxDigitWidth();
+	int t2       = (clock_font)->getRenderWidth(":");
 	clock_dy     = digit_h + (int)((float)digit_offset * 1.3);
 	if (g_settings.infoClockSeconds)
 		clock_dx     = t1*7 + t2*2;
@@ -365,7 +365,7 @@ int CVolumeHelper::getInfoClockX()
 		return clock_ax;
 }
 
-void CVolumeHelper::refresh(Font** font)
+void CVolumeHelper::refresh(Font* font)
 {
 	Init(font);
 }
diff --git a/src/gui/volumebar.h b/src/gui/volumebar.h
index 2ec76dd..0c176ec 100644
--- a/src/gui/volumebar.h
+++ b/src/gui/volumebar.h
@@ -106,13 +106,13 @@ class CVolumeHelper
 		int icon_width, icon_height, digit_width;
 		int h_spacer, v_spacer;
 		int vol_ay, vol_height;
-		Font** clock_font;
+		Font* clock_font;
 		CFrameBuffer *frameBuffer;
 
-		void Init(Font** font=NULL);
+		void Init(Font* font=NULL);
 		void initVolBarSize();
 		void initMuteIcon();
-		void initInfoClock(Font** font);
+		void initInfoClock(Font* font);
 
 	public:
 
@@ -130,7 +130,7 @@ class CVolumeHelper
 		void getTimeDimensions(int *_x, int *_y, int *w, int *h) { *_x = time_ax; *_y = clock_ay; *w = time_dx; *h = clock_dy; }
 		void getVolBarDimensions(int *_y, int *_dy) { *_y = vol_ay; *_dy = vol_height; }
 		void setMuteIconCorrY(int corr) { mute_corrY = corr; }
-		void refresh(Font** font=NULL);
+		void refresh(Font* font=NULL);
 };
 
 #endif
diff --git a/src/gui/widget/menue.cpp b/src/gui/widget/menue.cpp
index 17bfdb0..2c2d51c 100644
--- a/src/gui/widget/menue.cpp
+++ b/src/gui/widget/menue.cpp
@@ -37,6 +37,7 @@
 #include <driver/screen_max.h>
 #include <gui/pluginlist.h>
 #include <gui/widget/stringinput.h>
+#include <gui/infoclock.h>
 
 
 #include <driver/fade.h>
@@ -501,7 +502,7 @@ CMenuWidget::CMenuWidget()
 	preselected 	= -1;
 	details_line	= NULL;
 	info_box	= NULL;
-	show_details_line = true;
+
 	nextShortcut	= 1;
 }
 
@@ -527,7 +528,7 @@ void CMenuWidget::Init(const std::string &Icon, const int mwidth, const mn_widge
 	frameBuffer = CFrameBuffer::getInstance();
 	iconfile = Icon;
 	details_line = new CComponentsDetailLine();
-	show_details_line = true;
+	details_line->enableSaveBg();
 	info_box = new CComponentsInfoBox();
 	
 	//handle select values
@@ -586,7 +587,10 @@ void CMenuWidget::move(int xoff, int yoff)
 CMenuWidget::~CMenuWidget()
 {
 	resetWidget(true);
-	delete details_line;
+	if (details_line){
+		details_line->hide();
+		delete details_line;
+	}
 	delete info_box;
 }
 
@@ -1007,6 +1011,7 @@ void CMenuWidget::hide()
 		items[count]->init(-1, 0, 0, 0);
 	hint_painted	= false;
 	washidden = true;
+	OnAfterHide();
 }
 
 void CMenuWidget::checkHints()
@@ -1134,6 +1139,9 @@ void CMenuWidget::calcSize()
 
 void CMenuWidget::paint()
 {
+	OnBeforePaint();
+	if (CInfoClock::getInstance()->isRun())
+		CInfoClock::getInstance()->block();
 	calcSize();
 	CVFD::getInstance()->setMode(CVFD::MODE_MENU_UTF8 /*, nameString.c_str()*/);
 
@@ -1307,21 +1315,17 @@ void CMenuWidget::paintHint(int pos)
 {
 	if (!g_settings.show_menu_hints)
 		return;
-	
+
 	if (pos < 0 && !hint_painted)
 		return;
 
-	info_box->enableGradient(g_settings.theme.menu_Hint_gradient  != 0);
-	info_box->set2ndColor(COL_INFOBAR_SHADOW_PLUS_1); // COL_INFOBAR_SHADOW_PLUS_1 is default footer color
-	info_box->setColorBody(COL_MENUCONTENT_PLUS_0);
-	
 	if (hint_painted) {
 		/* clear detailsline line */
 		if (details_line)
-			savescreen ? details_line->hide() : details_line->kill();
+			details_line->hide();
 		/* clear info box */
 		if ((info_box) && (pos < 0))
-			savescreen ? info_box->hide(true) : info_box->kill();
+			savescreen ? info_box->hide() : info_box->kill();
 		hint_painted = false;
 	}
 	if (pos < 0)
@@ -1331,7 +1335,7 @@ void CMenuWidget::paintHint(int pos)
 	
 	if (!item->hintIcon && item->hint == NONEXISTANT_LOCALE && item->hintText.empty()) {
 		if (info_box) {
-			savescreen ? info_box->hide(false) : info_box->kill();
+			savescreen ? info_box->hide() : info_box->kill();
 			hint_painted = false;
 		}
 		return;
@@ -1371,15 +1375,15 @@ void CMenuWidget::paintHint(int pos)
 		info_box->removeLineBreaks(str);
 		info_box->setText(str, CTextBox::AUTO_WIDTH, g_Font[SNeutrinoSettings::FONT_TYPE_MENU_HINT], COL_MENUCONTENT_TEXT);
 		info_box->setCorner(RADIUS_LARGE);
-		info_box->syncSysColors();
-		info_box->setColorBody(COL_MENUCONTENTDARK_PLUS_0);
+		info_box->setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENTDARK_PLUS_0, COL_MENUCONTENTDARK_PLUS_0);
 		info_box->setShadowOnOff(CC_SHADOW_ON);
 		info_box->setPicture(item->hintIcon ? item->hintIcon : "");
+		info_box->enableColBodyGradient(g_settings.theme.menu_Hint_gradient, COL_INFOBAR_SHADOW_PLUS_1);// COL_INFOBAR_SHADOW_PLUS_1 is default footer color
 	}
-	
+
 	//paint result
-	if (show_details_line)
-		details_line->paint(savescreen);
+
+	details_line->paint();
 	info_box->paint(savescreen);
 	
 	hint_painted = true;
diff --git a/src/gui/widget/menue.h b/src/gui/widget/menue.h
index 670ebbf..cd11074 100644
--- a/src/gui/widget/menue.h
+++ b/src/gui/widget/menue.h
@@ -483,7 +483,7 @@ class CMenuGlobal
 		static CMenuGlobal* getInstance();
 };
 
-class CMenuWidget : public CMenuTarget
+class CMenuWidget : public CMenuTarget, public CComponentsSignals
 {
 	private: 
 		mn_widget_id_t 		widget_index;
@@ -491,7 +491,7 @@ class CMenuWidget : public CMenuTarget
 		CComponentsDetailLine	*details_line;
 		CComponentsInfoBox	*info_box;
 		int			hint_height;
-		bool			show_details_line;
+
 	protected:
 		std::string		nameString;
 		neutrino_locale_t	name;
@@ -594,7 +594,7 @@ class CMenuWidget : public CMenuTarget
 		};
 		void addKey(neutrino_msg_t key, CMenuTarget *menue, const std::string &action);
 		void setFooter(const struct button_label *_fbutton_label, const int _fbutton_count, bool repaint = false);
-		void suppressDetailsLine(bool suppress = true){show_details_line = suppress ? false : true;};
+
 		void setNextShortcut(int sc) { nextShortcut = sc; };
 		int getNextShortcut() { return nextShortcut; };
 };
diff --git a/src/gui/widget/progresswindow.cpp b/src/gui/widget/progresswindow.cpp
index a322b83..839a9de 100644
--- a/src/gui/widget/progresswindow.cpp
+++ b/src/gui/widget/progresswindow.cpp
@@ -177,9 +177,9 @@ unsigned int CProgressWindow::getGlobalStatus(void)
 	return global_progress;
 }
 
-void CProgressWindow::hide(bool no_restore)
+void CProgressWindow::hide()
 {
-	CComponentsWindow::hide(no_restore);
+	CComponentsWindow::hide();
 }
 
 int CProgressWindow::exec(CMenuTarget* parent, const std::string & /*actionKey*/)
diff --git a/src/gui/widget/progresswindow.h b/src/gui/widget/progresswindow.h
index 5bf54a7..736a09f 100644
--- a/src/gui/widget/progresswindow.h
+++ b/src/gui/widget/progresswindow.h
@@ -45,7 +45,7 @@ class CProgressWindow : public CComponentsWindow, public CMenuTarget
 
 		CProgressWindow(CComponentsForm *parent = NULL);
 		void setTitle(const neutrino_locale_t title);
-		virtual void hide(bool no_restore = false);
+		virtual void hide();
 
 		virtual int exec( CMenuTarget* parent, const std::string & actionKey );
 
diff --git a/src/neutrino.cpp b/src/neutrino.cpp
index 4e323f4..a2aa6fa 100644
--- a/src/neutrino.cpp
+++ b/src/neutrino.cpp
@@ -2167,9 +2167,8 @@ void CNeutrinoApp::RealRun(CMenuWidget &mainMenu)
 
 	dprintf(DEBUG_NORMAL, "initialized everything\n");
 
+	//activating infoclock
 	InfoClock = CInfoClock::getInstance();
-	if(g_settings.mode_clock)
-		g_settings.mode_clock = InfoClock->StartClock();
 
 	if(g_settings.power_standby || init_cec_setting)
 		standbyMode(true, true);
@@ -2509,7 +2508,7 @@ int CNeutrinoApp::showChannelList(const neutrino_msg_t _msg, bool from_menu)
 	channelList_painted = true;
 
 	neutrino_msg_t msg = _msg;
-	InfoClock->enableInfoClock(false);
+	InfoClock->enableInfoClock(false);//TODO: use callback in channel list class
 	StopSubtitles();
 
 //_show:
@@ -3781,17 +3780,6 @@ void CNeutrinoApp::switchTvRadioMode(const int prev_mode)
 	}
 }
 
-//switching clock on or off depends of current displayed or not
-void CNeutrinoApp::switchClockOnOff()
-{
-	if(g_settings.mode_clock) {
-		InfoClock->enableInfoClock(false);
-		g_settings.mode_clock = false;
-	} else {
-		g_settings.mode_clock = true;
-		InfoClock->enableInfoClock(true);
-	}
-}
 
 /**************************************************************************************
 *          CNeutrinoApp -  exec, menuitem callback (shutdown)                         *
@@ -3818,7 +3806,7 @@ int CNeutrinoApp::exec(CMenuTarget* parent, const std::string & actionKey)
 	}
 	else if (actionKey=="clock_switch")
 	{
-		switchClockOnOff();
+		InfoClock->switchClockOnOff();
 		returnval = menu_return::RETURN_EXIT_ALL;
 	}
 	else if (actionKey=="tv_radio_switch")//used in mainmenu
diff --git a/src/neutrino.h b/src/neutrino.h
index 424a05d..4583fc5 100644
--- a/src/neutrino.h
+++ b/src/neutrino.h
@@ -192,7 +192,7 @@ public:
 		return lastMode;
 	}
 	void switchTvRadioMode(const int prev_mode = mode_unknown);
-	void switchClockOnOff();
+
 	
 	bool isMuted() {return current_muted; }
 	void setCurrentMuted(int m) { current_muted = m; }
diff --git a/src/system/locals.h b/src/system/locals.h
index da243e5..2f8ff1d 100644
--- a/src/system/locals.h
+++ b/src/system/locals.h
@@ -303,7 +303,12 @@ typedef enum
 	LOCALE_CLOCK_SWITCH_OFF,
 	LOCALE_CLOCK_SWITCH_ON,
 	LOCALE_COLOR_GRADIENT,
-	LOCALE_COLOR_GRADIENT_C2C,
+	LOCALE_COLOR_GRADIENT_A2B,
+	LOCALE_COLOR_GRADIENT_B2A,
+	LOCALE_COLOR_GRADIENT_D2L,
+	LOCALE_COLOR_GRADIENT_DLD,
+	LOCALE_COLOR_GRADIENT_L2D,
+	LOCALE_COLOR_GRADIENT_LDL,
 	LOCALE_COLORCHOOSER_ALPHA,
 	LOCALE_COLORCHOOSER_BLUE,
 	LOCALE_COLORCHOOSER_GREEN,
diff --git a/src/system/locals_intern.h b/src/system/locals_intern.h
index da18621..f6991ce 100644
--- a/src/system/locals_intern.h
+++ b/src/system/locals_intern.h
@@ -303,7 +303,12 @@ const char * locale_real_names[] =
 	"clock_switch_off",
 	"clock_switch_on",
 	"color.gradient",
-	"color.gradient_c2c",
+	"color.gradient_a2b",
+	"color.gradient_b2a",
+	"color.gradient_d2l",
+	"color.gradient_dld",
+	"color.gradient_l2d",
+	"color.gradient_ldl",
 	"colorchooser.alpha",
 	"colorchooser.blue",
 	"colorchooser.green",
diff --git a/src/system/settings.h b/src/system/settings.h
index 8a1a8e6..e778755 100644
--- a/src/system/settings.h
+++ b/src/system/settings.h
@@ -93,6 +93,7 @@ struct SNeutrinoTheme
 	unsigned char menu_Content_inactive_Text_blue;
 
 	int menu_Hint_gradient;
+	int menu_ButtonBar_gradient;
 
 	unsigned char infobar_alpha;
 	unsigned char infobar_red;
@@ -119,7 +120,6 @@ struct SNeutrinoTheme
 	unsigned char clock_Digit_red;
 	unsigned char clock_Digit_green;
 	unsigned char clock_Digit_blue;
-	int gradient_c2c;
 };
 
 struct SNeutrinoSettings
