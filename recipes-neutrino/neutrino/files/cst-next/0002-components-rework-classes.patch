From 4e9b89fc168fdbd0879a33d83ece332da7ed5059 Mon Sep 17 00:00:00 2001
From: Thilo Graf <dbt@novatux.de>
Date: Wed, 18 Nov 2015 18:08:23 +0100
Subject: [PATCH 02/21] components: rework classes

- outsourced some classes cc_item.cpp/h, cc_draw.cpp/h
- added extra methodes for simple use of some basic components extra.cpp/h
- rework clock handling: use timer class, reworked members for
  enable/disable clock with external timer events,
  tryed to fix some display issues related with infoclock and
  time osd clock in moviebrowser, channellist, menuus
- reworked hide/kill handling, removed parameter for hide(), try to use
  cached backgrounds for other constallations, paint cache, image cache (all beta)
- reworked shadow/frame handling, add shadow modes for left/right
  arrangement, TODO: repaint for existant instances required
- reworked color gradient assignment (beta)

... Note: I had a data crash in my local git tree
and i tryed to restore my historie, but most was lost. Therefore here
the commit is large
---
 src/driver/colorgradient.cpp               |  10 +-
 src/driver/framebuffer.cpp                 |  18 +-
 src/driver/framebuffer.h                   |   5 +-
 src/gui/audiomute.cpp                      |  26 +-
 src/gui/bouquetlist.cpp                    |   5 +-
 src/gui/channellist.cpp                    | 146 +++---
 src/gui/channellist.h                      |   6 +-
 src/gui/components/Makefile.am             |   2 +
 src/gui/components/cc.h                    |  10 +-
 src/gui/components/cc_base.cpp             | 305 +------------
 src/gui/components/cc_base.h               | 349 +--------------
 src/gui/components/cc_detailsline.cpp      |  63 +--
 src/gui/components/cc_draw.cpp             | 692 +++++++++++++++++++++++++++++
 src/gui/components/cc_draw.h               | 309 +++++++++++++
 src/gui/components/cc_extra.cpp            | 123 +++++
 src/gui/components/cc_extra.h              | 276 ++++++++++++
 src/gui/components/cc_frm.cpp              |  82 +++-
 src/gui/components/cc_frm.h                |  21 +-
 src/gui/components/cc_frm_button.cpp       |  30 +-
 src/gui/components/cc_frm_button.h         |  45 +-
 src/gui/components/cc_frm_chain.cpp        |   8 +-
 src/gui/components/cc_frm_chain.h          |   4 +-
 src/gui/components/cc_frm_clock.cpp        | 429 ++++++++++--------
 src/gui/components/cc_frm_clock.h          | 134 +++---
 src/gui/components/cc_frm_ext_text.cpp     |  20 +-
 src/gui/components/cc_frm_ext_text.h       |  16 +-
 src/gui/components/cc_frm_footer.cpp       |  12 +-
 src/gui/components/cc_frm_footer.h         |   4 +-
 src/gui/components/cc_frm_header.cpp       | 220 +++++++--
 src/gui/components/cc_frm_header.h         |  49 +-
 src/gui/components/cc_frm_icons.cpp        |   8 +-
 src/gui/components/cc_frm_icons.h          |   4 +-
 src/gui/components/cc_frm_scrollbar.cpp    |   8 +-
 src/gui/components/cc_frm_scrollbar.h      |   2 +-
 src/gui/components/cc_frm_signalbars.cpp   |  17 +-
 src/gui/components/cc_frm_slider.cpp       |  16 +-
 src/gui/components/cc_frm_slider.h         |   2 +-
 src/gui/components/cc_frm_window.cpp       |  22 +-
 src/gui/components/cc_frm_window.h         |  10 +-
 src/gui/components/cc_item.cpp             | 174 +++-----
 src/gui/components/cc_item.h               | 129 ++++++
 src/gui/components/cc_item_infobox.cpp     |   8 +-
 src/gui/components/cc_item_infobox.h       |   7 +-
 src/gui/components/cc_item_picture.cpp     |  89 +++-
 src/gui/components/cc_item_picture.h       |  43 +-
 src/gui/components/cc_item_progressbar.cpp | 263 ++++++-----
 src/gui/components/cc_item_progressbar.h   |  21 +-
 src/gui/components/cc_item_shapes.cpp      |  16 +-
 src/gui/components/cc_item_shapes.h        |   5 +-
 src/gui/components/cc_item_text.cpp        | 134 ++++--
 src/gui/components/cc_item_text.h          |  83 +++-
 src/gui/components/cc_item_tvpic.cpp       |  10 +-
 src/gui/components/cc_item_tvpic.h         |   5 +-
 src/gui/components/cc_text_screen.h        |  44 ++
 src/gui/components/cc_timer.cpp            |  39 +-
 src/gui/components/cc_timer.h              |   2 +-
 src/gui/components/cc_types.h              |  54 ++-
 src/gui/infoclock.cpp                      |  91 ++--
 src/gui/infoclock.h                        |  16 +-
 src/gui/streaminfo2.cpp                    |   2 +-
 src/gui/test_menu.cpp                      |  24 +-
 src/gui/timeosd.cpp                        |  64 +--
 src/gui/timerlist.cpp                      |   4 +-
 src/gui/volumebar.cpp                      |  23 +-
 src/gui/volumebar.h                        |   9 +-
 src/gui/widget/progresswindow.cpp          |   6 +-
 src/gui/widget/progresswindow.h            |   2 +-
 src/system/debug.h                         |   2 +-
 68 files changed, 3201 insertions(+), 1676 deletions(-)
 create mode 100644 src/gui/components/cc_draw.cpp
 create mode 100644 src/gui/components/cc_draw.h
 create mode 100644 src/gui/components/cc_extra.cpp
 create mode 100644 src/gui/components/cc_extra.h
 create mode 100644 src/gui/components/cc_item.h
 create mode 100644 src/gui/components/cc_text_screen.h

diff --git a/src/driver/colorgradient.cpp b/src/driver/colorgradient.cpp
index 50dacdd..e9ed0e9 100644
--- a/src/driver/colorgradient.cpp
+++ b/src/driver/colorgradient.cpp
@@ -185,11 +185,15 @@ fb_pixel_t* CColorGradient::gradientColorToColor(fb_pixel_t start_col,fb_pixel_t
 	int start_box = 0;
 	int end_box = bSize;
 
-	if (mode == gradientDark2Light) {
-		fb_pixel_t temp_col = start_col;
+	fb_pixel_t temp_col = end_col;
+	end_col =  start_col;
+	start_col = temp_col;
+
+	if (mode == gradientDark2Light){
+		temp_col = start_col;
 		start_col = end_col;
 		end_col = temp_col;
-		}
+	}
 
 	uint8_t start_tr = (uint8_t)((start_col & 0xFF000000) >> 24);
 	uint8_t start_r  = (uint8_t)((start_col & 0x00FF0000) >> 16);
diff --git a/src/driver/framebuffer.cpp b/src/driver/framebuffer.cpp
index dc58fcc..66d4b8a 100644
--- a/src/driver/framebuffer.cpp
+++ b/src/driver/framebuffer.cpp
@@ -658,6 +658,7 @@ void CFrameBuffer::paletteSet(struct fb_cmap *map)
 		realcolor[i] = make16color(cmap.red[i], cmap.green[i], cmap.blue[i], cmap.transp[i],
 					   rl, ro, gl, go, bl, bo, tl, to);
 	}
+	OnAfterSetPallette();
 }
 
 void CFrameBuffer::paintHLineRelInternal2Buf(const int& x, const int& dx, const int& y, const int& box_dx, const fb_pixel_t& col, fb_pixel_t* buf)
@@ -673,7 +674,7 @@ fb_pixel_t* CFrameBuffer::paintBoxRel2Buf(const int dx, const int dy, const fb_p
 	if (!getActive())
 		return buf;
 	if (dx == 0 || dy == 0) {
-		dprintf(DEBUG_INFO, "[%s - %d]: radius %d, dx %d dy %d\n", __func__, __LINE__, radius, dx, dy);
+		dprintf(DEBUG_INFO, "[CFrameBuffer] [%s - %d]: radius %d, dx %d dy %d\n", __func__, __LINE__, radius, dx, dy);
 		return buf;
 	}
 
@@ -779,7 +780,7 @@ void CFrameBuffer::paintBoxRel(const int x, const int y, const int dx, const int
 		return;
 
 	if (dx == 0 || dy == 0) {
-		printf("[%s - %d]: radius %d, start x %d y %d end x %d y %d\n", __FUNCTION__, __LINE__, radius, x, y, x+dx, y+dy);
+		dprintf(DEBUG_NORMAL, "[CFrameBuffer] [%s - %d]: radius %d, start x %d y %d end x %d y %d\n", __FUNCTION__, __LINE__, radius, x, y, x+dx, y+dy);
 		return;
 	}
 
@@ -826,11 +827,12 @@ void CFrameBuffer::paintBoxRel(const int x, const int y, const int dx, const int
 			}
 
 			if (dx-ofr-ofl < 1) {
-				if (dx-ofr-ofl == 0)
-					printf("[%s - %d]: radius %d, start x %d y %d end x %d y %d\n", __FUNCTION__, __LINE__, radius, x, y, x+dx-ofr-ofl, y+line);
-				else
-					printf("[%s - %04d]: Calculated width: %d\n                      (radius %d, dx %d, offsetLeft %d, offsetRight %d).\n                      Width can not be less than 0, abort.\n", 
-						__FUNCTION__, __LINE__, dx-ofr-ofl, radius, dx, ofl, ofr);
+				if (dx-ofr-ofl == 0){
+					dprintf(DEBUG_INFO, "[CFrameBuffer] [%s - %d]: radius %d, start x %d y %d end x %d y %d\n", __func__, __LINE__, radius, x, y, x+dx-ofr-ofl, y+line);
+				}else{
+					dprintf(DEBUG_INFO, "[CFrameBuffer] [%s - %04d]: Calculated width: %d\n                      (radius %d, dx %d, offsetLeft %d, offsetRight %d).\n                      Width can not be less than 0, abort.\n",
+						__func__, __LINE__, dx-ofr-ofl, radius, dx, ofl, ofr);
+				}
 				line++;
 				continue;
 			}
@@ -2095,7 +2097,7 @@ bool CFrameBuffer::_checkFbArea(int _x, int _y, int _dx, int _dy, bool prev)
 //					waitForIdle();
 					fb_no_check = true;
 					if (prev)
-						CAudioMute::getInstance()->hide(true);
+						CAudioMute::getInstance()->hide();
 					else
 						CAudioMute::getInstance()->paint();
 					fb_no_check = false;
diff --git a/src/driver/framebuffer.h b/src/driver/framebuffer.h
index 23f7c19..79c7045 100644
--- a/src/driver/framebuffer.h
+++ b/src/driver/framebuffer.h
@@ -35,7 +35,7 @@
 #include <map>
 #include <OpenThreads/Mutex>
 #include <OpenThreads/ScopedLock>
-
+#include <sigc++/signal.h>
 #define fb_pixel_t uint32_t
 
 typedef struct fb_var_screeninfo t_fb_var_screeninfo;
@@ -69,7 +69,7 @@ typedef struct gradientData_t
 #define ConnectLineBox_Width	16 // px
 
 /** Ausfuehrung als Singleton */
-class CFrameBuffer
+class CFrameBuffer : public sigc::trackable
 {
 	private:
 
@@ -323,6 +323,7 @@ class CFrameBuffer
 		void fbNoCheck(bool noCheck) { fb_no_check = noCheck; }
 		void doPaintMuteIcon(bool mode) { do_paint_mute_icon = mode; }
 		void blit(void) {}
+		sigc::signal<void> OnAfterSetPallette;
 };
 
 #endif
diff --git a/src/gui/audiomute.cpp b/src/gui/audiomute.cpp
index a89fd81..2b26a5d 100644
--- a/src/gui/audiomute.cpp
+++ b/src/gui/audiomute.cpp
@@ -5,7 +5,7 @@
 	audioMute - Neutrino-GUI
 	Copyright (C) 2013 M. Liebmann (micha-bbg)
 	CComponents implementation
-	Copyright (C) 2013 Thilo Graf
+	Copyright (C) 2013-2015 Thilo Graf
 
 	License: GPL
 
@@ -71,14 +71,21 @@ void CAudioMute::AudioMute(int newValue, bool isEvent)
 			if (do_paint_mute_icon)
 			{
 				frameBuffer->fbNoCheck(true);
-				this->hide(true);
+				this->hide();
 				frameBuffer->fbNoCheck(false);
 			}
 			frameBuffer->setFbArea(CFrameBuffer::FB_PAINTAREA_MUTEICON1);
 			y_old = y;
 		}
-		if ((g_settings.mode_clock) && (doInit))
+
+		/* Infoclock should be blocked in all windows and clean the clock
+		 * display with ClearDisplay() by itself before paint,
+		 * so we don't do this here.
+		*/
+		if (!CInfoClock::getInstance()->isBlocked()){
 			CInfoClock::getInstance()->ClearDisplay();
+			CInfoClock::getInstance()->paint();//avoids delay
+		}
 
 		frameBuffer->fbNoCheck(true);
 		if (newValue) {
@@ -87,8 +94,13 @@ void CAudioMute::AudioMute(int newValue, bool isEvent)
 			frameBuffer->setFbArea(CFrameBuffer::FB_PAINTAREA_MUTEICON1, x, y, width, height);
 		}
 		else {
-			if (do_paint_mute_icon)
-				this->hide(true);
+			if (!CInfoClock::getInstance()->isBlocked()){
+				CInfoClock::getInstance()->ClearDisplay();
+				this->kill();
+				clearSavedScreen();
+				CInfoClock::getInstance()->paint();//avoids delay
+			}else
+				this->hide();
 			frameBuffer->setFbArea(CFrameBuffer::FB_PAINTAREA_MUTEICON1);
 		}
 		frameBuffer->fbNoCheck(false);
@@ -107,8 +119,8 @@ void CAudioMute::enableMuteIcon(bool enable)
 			this->paint();
 	}
 	else {
-		if (neutrino->isMuted())
-			this->hide(true);
+		if (!neutrino->isMuted())
+			this->kill();
 		frameBuffer->doPaintMuteIcon(false);
 		do_paint_mute_icon = false;
 	}
diff --git a/src/gui/bouquetlist.cpp b/src/gui/bouquetlist.cpp
index 331976f..d46ec06 100644
--- a/src/gui/bouquetlist.cpp
+++ b/src/gui/bouquetlist.cpp
@@ -46,7 +46,7 @@
 #include <gui/widget/buttons.h>
 #include <gui/widget/icons.h>
 #include <gui/widget/messagebox.h>
-
+#include <gui/infoclock.h>
 #include <driver/display.h>
 #include <driver/fontrenderer.h>
 #include <driver/screen_max.h>
@@ -635,6 +635,7 @@ int CBouquetList::show(bool bShowChannelList)
 void CBouquetList::hide()
 {
 	frameBuffer->paintBackgroundBoxRel(x,y, width,height+10);
+	CInfoClock::getInstance()->enableInfoClock(!CInfoClock::getInstance()->isBlocked());
 }
 
 void CBouquetList::paintItem(int pos)
@@ -702,6 +703,8 @@ void CBouquetList::paintHead()
 
 void CBouquetList::paint()
 {
+	//ensure stop info clock before paint this window
+	CInfoClock::getInstance()->disableInfoClock();
 	liststart = (selected/listmaxshow)*listmaxshow;
 	int lastnum =  liststart + listmaxshow;
 	int bsize = Bouquets.empty() ? 1 : Bouquets.size();
diff --git a/src/gui/channellist.cpp b/src/gui/channellist.cpp
index 5336a8a..bd39251 100644
--- a/src/gui/channellist.cpp
+++ b/src/gui/channellist.cpp
@@ -61,7 +61,7 @@
 #include <gui/widget/messagebox.h>
 #include <gui/widget/hintbox.h>
 #include <gui/movieplayer.h>
-
+#include <gui/infoclock.h>
 #include <system/settings.h>
 #include <gui/customcolor.h>
 
@@ -86,11 +86,11 @@ extern CBouquetList   * TVfavList;
 extern CBouquetList   * RADIOfavList;
 
 extern bool autoshift;
-
+static CComponentsPIP	*cc_minitv = NULL;
 extern CBouquetManager *g_bouquetManager;
-
-static CComponentsFrmClock *headerClock = NULL;
-static int headerClockWidth = 0;
+extern int old_b_id;
+static CComponentsChannelLogoScalable* CChannelLogo = NULL;
+static CComponentsHeader *header = NULL;
 extern bool timeset;
 
 CChannelList::CChannelList(const char * const pName, bool phistoryMode, bool _vlist)
@@ -130,24 +130,7 @@ CChannelList::CChannelList(const char * const pName, bool phistoryMode, bool _vl
 
 CChannelList::~CChannelList()
 {
-	if(dline){
-		delete dline;
-		dline = NULL;
-	}
-	if (cc_minitv){
-		delete 	cc_minitv;
-		cc_minitv = NULL;
-	}
-	if (headerClock) {
-		headerClock->clearSavedScreen();
-		delete headerClock;
-		headerClock = NULL;
-	}
-
-	if (CChannelLogo) {
-		delete CChannelLogo;
-		CChannelLogo = NULL;
-	}
+	ResetModules();
 }
 
 void CChannelList::SetChannelList(ZapitChannelList* zlist)
@@ -312,6 +295,18 @@ int CChannelList::doChannelMenu(void)
 	CMenuWidget* menu = new CMenuWidget(LOCALE_CHANNELLIST_EDIT, NEUTRINO_ICON_SETTINGS);
 	menu->enableFade(false);
 	menu->enableSaveScreen(true);
+
+	//ensure stop info clock before paint context menu
+	CInfoClock::getInstance()->block();
+
+	//ensure stop header clock before paint context menu
+	if (g_settings.menu_pos == CMenuWidget::MENU_POS_TOP_RIGHT){
+		//using native callback to ensure stop header clock before paint this menu window
+		menu->OnBeforePaint.connect(sigc::mem_fun(header->getClockObject(), &CComponentsFrmClock::block));
+		//... and start header clock after hide menu window
+		menu->OnAfterHide.connect(sigc::mem_fun(header->getClockObject(), &CComponentsFrmClock::unblock));
+	}
+
 	CMenuSelectorTarget * selector = new CMenuSelectorTarget(&select);
 
 	bool empty = (*chanlist).empty();
@@ -420,7 +415,7 @@ int CChannelList::doChannelMenu(void)
 			{
 				previous_channellist_additional = g_settings.channellist_additional;
 				COsdSetup osd_setup;
-				osd_setup.showContextChanlistMenu();
+				osd_setup.showContextChanlistMenu(this);
 				//FIXME check font/options changed ?
 				hide();
 				calcSize();
@@ -601,7 +596,7 @@ int CChannelList::show()
 
 	COSDFader fader(g_settings.theme.menu_Content_alpha);
 	fader.StartFadeIn();
-
+	CInfoClock::getInstance()->ClearDisplay();
 	paint();
 
 	int oldselected = selected;
@@ -947,8 +942,6 @@ int CChannelList::show()
 		printf("CChannelList:: bouquetList->exec res %d\n", res);
 	}
 
-	if (headerClock)
-		headerClock->Stop();
 
 	if(NeutrinoMessages::mode_ts == CNeutrinoApp::getInstance()->getMode())
 		return -1;
@@ -968,12 +961,17 @@ void CChannelList::hide()
 			delete cc_minitv;
 		cc_minitv = NULL;
 	}
-	if (headerClock) {
-		if (headerClock->Stop())
-			headerClock->hide();
+
+	header->kill();
+	if (CChannelLogo){
+		CChannelLogo->kill();
+		delete CChannelLogo;
+		CChannelLogo = NULL;
 	}
+
 	frameBuffer->paintBackgroundBoxRel(x, y, full_width, height + info_height);
 	clearItem2DetailsLine();
+	CInfoClock::getInstance()->enableInfoClock(!CInfoClock::getInstance()->isBlocked());
 }
 
 bool CChannelList::showInfo(int number, int epgpos)
@@ -1699,6 +1697,7 @@ void CChannelList::showChannelLogo() //TODO: move into an own handler, eg. heade
 			CChannelLogo->setYPos(y + (theight - CChannelLogo->getHeight()) / 2);
 			CChannelLogo->paint();
 		} else {
+			CChannelLogo->hide();
 			delete CChannelLogo;
 			CChannelLogo = NULL;
 		}
@@ -2078,51 +2077,68 @@ void CChannelList::paint()
 
 void CChannelList::paintHead()
 {
-	static int gradient_head = g_settings.theme.menu_Head_gradient;
-	static int gradient_c2c  = g_settings.theme.gradient_c2c;
+	if (header == NULL)
+		header = new CComponentsHeader();
+
+	header->setDimensionsAll(x, y, full_width, theight);
 
-	CComponentsHeader header(x, y, full_width, theight, name /*no header icon*/);
 	if (bouquet && bouquet->zapitBouquet && bouquet->zapitBouquet->bLocked != g_settings.parentallock_defaultlocked)
-		header.setIcon(NEUTRINO_ICON_LOCK);
-	if (edit_state)
-		header.setCaption(std::string(g_Locale->getText(LOCALE_CHANNELLIST_EDIT)) + ": " + name);
+		header->setIcon(NEUTRINO_ICON_LOCK);
+
+	string header_txt 		= !edit_state ? name : string(g_Locale->getText(LOCALE_CHANNELLIST_EDIT)) + ": " + name;
+	fb_pixel_t header_txt_col 	= (edit_state ? COL_RED : COL_MENUHEAD_TEXT);
+	header->setColorBody(COL_MENUHEAD_PLUS_0);
 
-	header.paint(CC_SAVE_SCREEN_NO);
+	header->setCaption(header_txt, CTextBox::NO_AUTO_LINEBREAK, header_txt_col);
 
-	if ((gradient_head != g_settings.theme.menu_Head_gradient || gradient_c2c != g_settings.theme.gradient_c2c) && headerClock != NULL) {
-		gradient_head = g_settings.theme.menu_Head_gradient;
-		gradient_c2c  = g_settings.theme.gradient_c2c;
-		headerClock->clearSavedScreen();
-		delete headerClock;
-		headerClock = NULL;
+	if (header->enableColBodyGradient(g_settings.theme.menu_Head_gradient, COL_MENUCONTENT_PLUS_0)){
+		if (CChannelLogo)
+			CChannelLogo->clearFbData();
 	}
 
 	if (timeset) {
-		if (headerClock == NULL) {
-			headerClock = new CComponentsFrmClock(0, 0, 0, 0, "%H:%M", true);
-			headerClock->setClockBlink("%H %M");
-			headerClock->setClockIntervall(1);
-			headerClock->doPaintBg(!gradient_head);
-			headerClock->enableTboxSaveScreen(gradient_head);
-			headerClock->setCorner(RADIUS_LARGE, CORNER_TOP_RIGHT);
-		}
-		headerClock->setClockFont(SNeutrinoSettings::FONT_TYPE_MENU_TITLE);
-		headerClock->setYPos(y);
-		headerClock->setHeight(theight);
-		headerClock->setTextColor(header.getTextObject()->getTextColor());
-		headerClock->setColorBody(header.getColorBody());
-		headerClock->refresh();
-		headerClockWidth = headerClock->getWidth();
-		headerClock->setXPos(x + full_width - headerClockWidth - 10);
-		headerClockWidth += 6;
-
-		headerClock->Start();
+		if(!edit_state){
+			if (header->getContextBtnObject())
+				if (!header->getContextBtnObject()->empty())
+					header->removeContextButtons();
+			header->enableClock(true, "%H:%M", "%H %M", true);
+			logo_off = header->getClockObject()->getWidth() + 10;
+
+			header->getClockObject()->setCorner(RADIUS_LARGE, CORNER_TOP_RIGHT);
+		}else{
+			if (header->getClockObject()){
+				header->disableClock();
+				header->setContextButton(CComponentsHeader::CC_BTN_EXIT);
+			}
+		}
 	}
 	else
-		headerClockWidth = 0;
+		logo_off = 10;
 
-	logo_off = headerClockWidth + 10;
-	headerNew = true;
+	header->paint(CC_SAVE_SCREEN_NO);
+}
+
+CComponentsHeader* CChannelList::getHeaderObject()
+{
+	return header;
+}
+
+void CChannelList::ResetModules()
+{
+	delete header;
+	header = NULL;
+	if(dline){
+		delete dline;
+		dline = NULL;
+	}
+	if (cc_minitv){
+		delete 	cc_minitv;
+		cc_minitv = NULL;
+	}
+	if (CChannelLogo) {
+		delete CChannelLogo;
+		CChannelLogo = NULL;
+	}
 }
 
 void CChannelList::paintBody()
diff --git a/src/gui/channellist.h b/src/gui/channellist.h
index 580371c..96014b6 100644
--- a/src/gui/channellist.h
+++ b/src/gui/channellist.h
@@ -75,7 +75,7 @@ private:
 	bool edit_state;
 
 	CFrameBuffer		*frameBuffer;
-	CComponentsPIP		*cc_minitv;
+
 	unsigned int		selected, selected_in_new_mode;
 	unsigned int            origPosition;
 	unsigned int            newPosition;
@@ -127,7 +127,7 @@ private:
 
 	int ChannelList_Rec;
 
-	CComponentsChannelLogoScalable* CChannelLogo;
+
 	bool headerNew;
 
 	void paintDetails(int index);
@@ -243,5 +243,7 @@ public:
 	unsigned Size() { return (*chanlist).size(); }
 	ZapitChannelList &getChannels() { return channels; };
 	bool checkLockStatus(neutrino_msg_data_t data, bool pip = false);
+	CComponentsHeader* getHeaderObject();
+	void ResetModules();
 };
 #endif
diff --git a/src/gui/components/Makefile.am b/src/gui/components/Makefile.am
index 7f0a506..7f855cf 100644
--- a/src/gui/components/Makefile.am
+++ b/src/gui/components/Makefile.am
@@ -27,6 +27,8 @@ noinst_LIBRARIES = libneutrino_gui_components.a
 libneutrino_gui_components_a_SOURCES = \
 	cc_base.cpp \
 	cc_detailsline.cpp \
+	cc_draw.cpp \
+	cc_extra.cpp \
 	cc_frm_button.cpp \
 	cc_frm.cpp \
 	cc_frm_chain.cpp \
diff --git a/src/gui/components/cc.h b/src/gui/components/cc.h
index d7f0865..edbadba 100644
--- a/src/gui/components/cc.h
+++ b/src/gui/components/cc.h
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2013, Thilo Graf 'dbt'
+	Copyright (C) 2013-2015, Thilo Graf 'dbt'
 
 	License: GPL
 
@@ -17,10 +17,8 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 /// Basic CComponent class header.
@@ -33,6 +31,7 @@ Basic attributes and member functions for component sub classes
 
 #include "cc_types.h"
 #include "cc_base.h"
+#include "cc_extra.h"
 
 #include "cc_item_infobox.h"
 #include "cc_item_picture.h"
@@ -43,7 +42,6 @@ Basic attributes and member functions for component sub classes
 #include "cc_detailsline.h"
 
 #include "cc_frm_scrollbar.h"
-#include "cc_frm.h"
 #include "cc_frm_chain.h"
 #include "cc_frm_button.h"
 #include "cc_frm_clock.h"
diff --git a/src/gui/components/cc_base.cpp b/src/gui/components/cc_base.cpp
index c5080b8..1820de4 100644
--- a/src/gui/components/cc_base.cpp
+++ b/src/gui/components/cc_base.cpp
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2014, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
 	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -18,10 +18,8 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifdef HAVE_CONFIG_H
@@ -31,304 +29,11 @@
 #include <global.h>
 #include <neutrino.h>
 #include "cc_base.h"
-#include <cs_api.h>
-#include <system/debug.h>
+
 using namespace std;
 
 //abstract basic class CComponents
-CComponents::CComponents() : COSDFader(g_settings.theme.menu_Content_alpha)
+CComponents::CComponents()
 {
-	x = saved_screen.x 	= 0;
-	y = saved_screen.y 	= 0;
-	cc_xr 			= x;
-	cc_yr 			= y;
-	height 			= saved_screen.dy = CC_HEIGHT_MIN;
-	width 			= saved_screen.dx = CC_WIDTH_MIN;
-
-	col_body 		= COL_MENUCONTENT_PLUS_0;
-	col_shadow 		= COL_MENUCONTENTDARK_PLUS_0;
-	col_frame 		= COL_MENUCONTENT_PLUS_6;
-	col_frame_sel 		= COL_MENUCONTENTSELECTED_PLUS_0;
-	corner_type 		= CORNER_ALL;
-	corner_rad		= 0;
 	cc_tag			= NULL;
-	shadow			= CC_SHADOW_OFF;
-	shadow_w		= SHADOW_OFFSET;
-	fr_thickness		= 0;
-	fr_thickness_sel	= 3;
-
-	firstPaint		= true;
-	is_painted		= false;
-	paint_bg		= true;
-	save_tbox_screen	= false;
-	cc_allow_paint		= true;
-	frameBuffer 		= CFrameBuffer::getInstance();
-	v_fbdata.clear();
-	saved_screen.pixbuf 	= NULL;
-	col_body_gradient	= false;
-	cc_body_gradient_c2c	= true;
-	cc_body_gradient_2nd_col= COL_MENUCONTENT_PLUS_0;
-	cc_gradientData.gradientBuf = NULL;
-	cc_gradientData.boxBuf = NULL;
-}
-
-CComponents::~CComponents()
-{
-	hide();
-	clearSavedScreen();
-	clearFbData();
-	if (cc_gradientData.gradientBuf)
-		free(cc_gradientData.gradientBuf);
-	if (cc_gradientData.boxBuf)
-		cs_free_uncached(cc_gradientData.boxBuf);
-}
-
-void CComponents::clearSavedScreen()
-{
-	if (saved_screen.pixbuf)
-		delete[] saved_screen.pixbuf;
-	saved_screen.pixbuf = NULL;
-}
-
-bool CComponents::CheckFbData(const comp_fbdata_t& fbdata, const char* func, const int line)
-{
-	int32_t rows = fbdata.dx / (int32_t)frameBuffer->getScreenWidth(true) - 1 + fbdata.y;
-	int32_t rest = fbdata.dx % (int32_t)frameBuffer->getScreenWidth(true);
-        int32_t end  = rows * (int32_t)frameBuffer->getScreenWidth(true) + rest;
-	if (	(fbdata.x < 0 || fbdata.y < 0) ||
-		(end >= (int32_t)frameBuffer->getScreenWidth(true)*(int32_t)frameBuffer->getScreenHeight(true)) 
-	   ) {
-			dprintf(DEBUG_NORMAL, "[CComponents] ERROR! Position < 0 or > FB end [%s - %d]\n\tx = %d  y = %d\n\tdx = %d  dy = %d\n",
-				func, line,
-				fbdata.x, fbdata.y,
-				fbdata.dx, fbdata.dy);
-			return false;
-		}
-		if (fbdata.dx == 0 || fbdata.dy == 0) {
-			dprintf(DEBUG_DEBUG,"[CComponents] INFO! dx and/or dy = 0 [%s - %d]\n\tx = %d  y = %d\n\tdx = %d  dy = %d\n",
-				func, line,
-				fbdata.x, fbdata.y,
-				fbdata.dx, fbdata.dy);
-			return false;
-		}
-	return true;
-}
-
-//paint framebuffer stuff and fill buffer
-void CComponents::paintFbItems(bool do_save_bg)
-{
-	//save background before first paint, do_save_bg must be true
-	if (firstPaint && do_save_bg){
-		for(size_t i=0; i<v_fbdata.size(); i++){
-			if (!CheckFbData(v_fbdata[i], __func__, __LINE__)){
-				break;
-			}
-
-	dprintf(DEBUG_DEBUG, "[CComponents]\n\t[%s - %d] firstPaint->save screen: %d, fbdata_type: %d\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
-			__func__,
-			__LINE__,
-			firstPaint,
-			v_fbdata[i].fbdata_type,
-			v_fbdata[i].x,
-			v_fbdata[i].y,
-			v_fbdata[i].dx,
-			v_fbdata[i].dy);
-
-		saved_screen.x = v_fbdata[i].x;
-		saved_screen.y = v_fbdata[i].y;
-		saved_screen.dx = v_fbdata[i].dx;
-		saved_screen.dy = v_fbdata[i].dy;
-		clearSavedScreen();
-		saved_screen.pixbuf = getScreen(saved_screen.x, saved_screen.y, saved_screen.dx, saved_screen.dy);
-		firstPaint = false;
-		break;
-		}
-	}
-
-	for(size_t i=0; i< v_fbdata.size(); i++){
-		// Don't paint on dimension or position error dx or dy are 0
-		if (!CheckFbData(v_fbdata[i], __func__, __LINE__)){
-			continue;
-		}
-		int fbtype = v_fbdata[i].fbdata_type;
-
-	dprintf(DEBUG_DEBUG, "[CComponents]\n\t[%s - %d], fbdata_[%d]\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
-			__func__,
-			__LINE__,
-			(int)i,
-			v_fbdata[i].x,
-			v_fbdata[i].y,
-			v_fbdata[i].dx,
-			v_fbdata[i].dy);
-
-		//some elements can be assembled from lines and must be handled as one unit (see details line),
-		//so all individual backgrounds of boxes must be saved and painted in "firstpaint mode"
-#if 0
-		if (firstPaint){
-
-			if (do_save_bg && fbtype == CC_FBDATA_TYPE_LINE)
-				v_fbdata[i].pixbuf = getScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
-
-			//ensure painting of all line fb items with saved screens
-			if (fbtype == CC_FBDATA_TYPE_LINE)
-				firstPaint = true;
-			else
-				firstPaint = false;
-		}
-#endif
-		if (do_save_bg && fbtype == CC_FBDATA_TYPE_LINE)
-			v_fbdata[i].pixbuf = getScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
-
-		//paint all fb relevant basic parts (frame and body) with all specified properties, paint_bg must be true
-		if (fbtype != CC_FBDATA_TYPE_BGSCREEN && paint_bg){
-			if (fbtype == CC_FBDATA_TYPE_FRAME) {
-				if (v_fbdata[i].frame_thickness > 0 && cc_allow_paint)
-					frameBuffer->paintBoxFrame(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].frame_thickness, v_fbdata[i].color, v_fbdata[i].r, corner_type);
-			}
-			else if (fbtype == CC_FBDATA_TYPE_BACKGROUND)
-				frameBuffer->paintBackgroundBoxRel(x, y, v_fbdata[i].dx, v_fbdata[i].dy);
-			else if (fbtype == CC_FBDATA_TYPE_SHADOW_BOX) {
-				if (shadow) {
-					int sw = shadow_w;
-					int sw_cur = sw;
-					int x_sh = v_fbdata[i].x + v_fbdata[i].dx - sw;
-					int y_sh = v_fbdata[i].y + v_fbdata[i].dy - sw;
-					if (corner_type && v_fbdata[i].r) {
-						//calculate positon of shadow areas
-						x_sh += sw - 2*v_fbdata[i].r;
-						y_sh += sw - 2*v_fbdata[i].r;
-						//calculate current shadow width depends of current corner_rad
-						sw_cur = max(2*v_fbdata[i].r, sw);
-					}
-					if (cc_allow_paint && !is_painted){
-						// shadow right
-						frameBuffer->paintBoxRel(x_sh, v_fbdata[i].y, sw_cur, v_fbdata[i].dy-sw_cur, v_fbdata[i].color, v_fbdata[i].r, corner_type & CORNER_TOP_RIGHT);
-						// shadow bottom
-						frameBuffer->paintBoxRel(v_fbdata[i].x, y_sh, v_fbdata[i].dx, sw_cur, v_fbdata[i].color, v_fbdata[i].r, corner_type & CORNER_BOTTOM);
-					}
-				}
-			}
-			else {
-				if(cc_allow_paint) {
-					if  (col_body_gradient && (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BOX) && (v_fbdata[i].data != NULL)) {
-						// color gradient
-						gradientData_t *gradientData = static_cast<gradientData_t*> (v_fbdata[i].data);
-						if (gradientData->boxBuf == NULL)
-							gradientData->boxBuf = frameBuffer->paintBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, 0, gradientData, v_fbdata[i].r, corner_type);
-						else
-//							frameBuffer->blit2FB(gradientData->boxBuf, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].x, v_fbdata[i].y);
-							frameBuffer->blitBox2FB(gradientData->boxBuf, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].x, v_fbdata[i].y);
-					} else
-						frameBuffer->paintBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].color, v_fbdata[i].r, corner_type);
-				}
-			}
-		}
-	}
-
-	is_painted = true;
-}
-
-//screen area save
-inline fb_pixel_t* CComponents::getScreen(int ax, int ay, int dx, int dy)
-{
-	if (dx * dy == 0)
-		return NULL;
-
-	fb_pixel_t* pixbuf = new fb_pixel_t[dx * dy];
-	frameBuffer->waitForIdle("CComponents::getScreen()");
-	frameBuffer->SaveScreen(ax, ay, dx, dy, pixbuf);
-	return pixbuf;
-}
-
-//restore screen from buffer
-inline void CComponents::hide()
-{
-	for(size_t i =0; i< v_fbdata.size() ;i++) {
-		if (v_fbdata[i].pixbuf){
-			frameBuffer->waitForIdle("CComponents::hide()");
-			frameBuffer->RestoreScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].pixbuf);
-		}
-	}
-
-	clearFbData();
-	is_painted = false;
-}
-
-//erase or paint over rendered objects
-void CComponents::kill(const fb_pixel_t& bg_color, const int& corner_radius)
-{
-	for(size_t i =0; i< v_fbdata.size() ;i++){
-#if 0
-		if (bg_color != COL_BACKGROUND_PLUS_0)
-#endif
-			int r =  v_fbdata[i].r;
-			if (corner_radius > -1)
-				r = corner_radius;
-			frameBuffer->paintBoxRel(v_fbdata[i].x,
-						 v_fbdata[i].y,
-						 v_fbdata[i].dx,
-						 v_fbdata[i].dy,
-						 bg_color,
-						 r,
-						 corner_type);
-			if (v_fbdata[i].frame_thickness)
-					frameBuffer->paintBoxFrame(v_fbdata[i].x,
-								   v_fbdata[i].y,
-								   v_fbdata[i].dx,
-								   v_fbdata[i].dy,
-								   v_fbdata[i].frame_thickness,
-								   bg_color,
-								   r,
-								   corner_type);
-
-#if 0
-		else
-			frameBuffer->paintBackgroundBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
-#endif
-	}
-	clearFbData();
-	firstPaint = true;
-	is_painted = false;
-}
-
-//clean old screen buffer
-void CComponents::clearFbData()
-{
-	for(size_t i =0; i< v_fbdata.size() ;i++) {
-		if (v_fbdata[i].pixbuf)
-			delete[] v_fbdata[i].pixbuf;
-
-#if 0
-		if (v_fbdata[i].data && (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BOX)) {
-			gradientData_t *gradientData = static_cast<gradientData_t*> (v_fbdata[i].data);
-			if (gradientData->boxBuf)
-				cs_free_uncached(gradientData->boxBuf);
-		}
-#endif
-	}
-	v_fbdata.clear();
-}
-
-inline void CComponents::setXPos(const int& xpos)
-{
-	x = xpos;
-}
-
-inline void CComponents::setYPos(const int& ypos)
-{
-	y = ypos;
-}
-
-void CComponents::setFrameThickness(const int& thickness, const int& thickness_sel)
-{
-	fr_thickness = thickness;
-
-	if (fr_thickness_sel != thickness_sel)
-		fr_thickness_sel = thickness_sel;
-}
-
-
-void CComponents::enableColBodyGradient(bool do_paint_gradient)
-{
-	col_body_gradient = do_paint_gradient;
 }
diff --git a/src/gui/components/cc_base.h b/src/gui/components/cc_base.h
index 38663ae..b697ded 100644
--- a/src/gui/components/cc_base.h
+++ b/src/gui/components/cc_base.h
@@ -3,7 +3,8 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2014, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
+	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
 
 	License: GPL
 
@@ -17,362 +18,38 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
-#ifndef __COMPONENTS__
-#define __COMPONENTS__
+#ifndef __CC_BASE__
+#define __CC_BASE__
 
 #include "cc_types.h"
 #include "cc_signals.h"
-#include <gui/widget/textbox.h>
-#include <vector>
-#include <string>
-#include <driver/pictureviewer/pictureviewer.h>
-#include <gui/widget/icons.h>
-#include <driver/fade.h>
-#include <driver/colorgradient.h>
+#include "cc_draw.h"
+
 /// Basic component class.
 /*!
 Basic attributes and member functions for component sub classes
 */
 
-class CComponents : public CComponentsSignals, public COSDFader
+class CComponents : public CComponentsSignals, public CCDraw
 {
-	private:
-		///pixel buffer handling, returns pixel buffer depends of given parameters
-		fb_pixel_t* getScreen(int ax, int ay, int dx, int dy);
-
 	protected:
-		///object: framebuffer object, usable in all sub classes
-		CFrameBuffer * frameBuffer;
-		///container: for frambuffer properties and pixel buffer
-		std::vector<comp_fbdata_t> v_fbdata;
-
-		///property: x-position on screen, to alter with setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
-		int x;
-		///property: y-position on screen, to alter setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
-		int y;
-		///property: contains real x-position on screen
-		int cc_xr;
-		///property: contains real y-position on screen
-		int cc_yr;
-		///property: height-dimension on screen, to alter with setHeight() or setDimensionsAll()
-		int height;
-		///property: width-dimension on screen, to alter with setWidth() or setDimensionsAll()
-		int width;
-		///property: has corners with definied type, types are defined in /driver/frambuffer.h, without effect, if corner_radius=0
-		int corner_type;
-		///property: defined radius of corner, without effect, if corner_type=0
-		int corner_rad;
-		///property: tag for component, can contain any value if required, default value is NULL, you can fill with a cast, see also setTag() and getTag() 
+	
+		///property: tag for component, can contains any value if required, default value is NULL, you can fill with a cast, see also setTag() and getTag()
 		void *cc_tag;
-		///property: color of body
-		fb_pixel_t col_body;
-		fb_pixel_t old_gradient_color;
-		int old_gradient_c2c;
-		///property: color of shadow
-		fb_pixel_t col_shadow;
-		///property: color of frame
-		fb_pixel_t col_frame;
-		///property: color of frame if component is selected, Note: fr_thickness_sel must be set
-		fb_pixel_t col_frame_sel;
-
-		///property: contains data for gradiant handling
-		gradientData_t cc_gradientData;
-		///property: true component can paint gradient, see also enableColBodyGradient()
-		bool col_body_gradient;
-		///property: background gradient mode
-		int cc_body_gradient_mode;
-		///property: background gradient intensity
-		int cc_body_gradient_intensity;
-		///property: background gradient intensity value min
-		uint8_t cc_body_gradient_intensity_v_min;
-		///property: background gradient intensity value max
-		uint8_t cc_body_gradient_intensity_v_max;
-		///property: background gradient saturation
-		uint8_t cc_body_gradient_saturation;
-		///property: background gradient direction
-		int cc_body_gradient_direction;
-		///property: background gradient mode
-		bool cc_body_gradient_c2c;
-		///property: background gradient 2nd color
-		fb_pixel_t cc_body_gradient_2nd_col;
-
-		///property: true=component has shadow
-		bool shadow;
-		///property: width of shadow
-		int shadow_w;
-
-		 ///property: frame thickness, see also setFrameThickness()
-		int fr_thickness;
-		///property: frame thickness of selected component, see also setFrameThickness()
-		int fr_thickness_sel;
 
-		///status: true=component was painted for 1st time
-		bool firstPaint;
-		///status: true=component was rendered
-		bool is_painted;
-		///mode: true=activate rendering of basic elements (frame, shadow and body)
-		bool paint_bg;
-		bool save_tbox_screen;
-		///mode:  true=allows painting of item, see also allowPaint()
-		bool cc_allow_paint;
-
-		///rendering of framebuffer elements at once,
-		///elements are contained in v_fbdata, presumes added frambuffer elements with paintInit(),
-		///parameter do_save_bg=true, saves background of element to pixel buffer, this can be restore with hide()
-		void paintFbItems(bool do_save_bg = true);
-
-		///check current fbdtata position and dimensions, parameter fbdata is an element of v_fbdata, returns false on error
-		bool CheckFbData(const comp_fbdata_t& fbdata, const char* func, const int line);
-
-		///clean up old screen buffer saved in v_fbdata
-		virtual void clearFbData();
-
-		///container: contains saved pixel buffer with position and dimensions
-		comp_screen_data_t saved_screen; 	
-		
 	public:
 		///basic component class constructor.
 		CComponents();
-		virtual~CComponents();
-
-		///set screen x-position, parameter as int
-		virtual void setXPos(const int& xpos);
-		///set screen y-position, parameter as int
-		virtual void setYPos(const int& ypos);
-		///set x and y position at once
-		///Note: position of bound components (items) means position related within parent form, not for screen!
-		///to set the real screen position, look at setRealPos()
-		inline virtual void setPos(const int& xpos, const int& ypos){x = xpos; y = ypos;};
-
-		///sets real x position on screen. Use this, if item is added to a parent form
-		virtual void setRealXPos(const int& xr){cc_xr = xr;};
-		///sets real y position on screen. Use this, if item is added to a parent form
-		virtual void setRealYPos(const int& yr){cc_yr = yr;};
-		///sets real x and y position on screen at once. Use this, if item is added to a parent form
-		virtual void setRealPos(const int& xr, const int& yr){cc_xr = xr; cc_yr = yr;};
-		///get real x-position on screen. Use this, if item contains own render methods and item is bound to a form
-		virtual int getRealXPos(){return cc_xr;};
-		///get real y-position on screen. Use this, if item contains own render methods and item is bound to a form
-		virtual int getRealYPos(){return cc_yr;};
-		
-		///set height of component on screen
-		inline virtual void setHeight(const int& h){height = h;};
-		///set width of component on screen
-		inline virtual void setWidth(const int& w){width = w;};
-		///set all positions and dimensions of component at once
-		inline virtual void setDimensionsAll(const int& xpos, const int& ypos, const int& w, const int& h){x = xpos; y = ypos; width = w; height = h;};
-
-		///return screen x-position of component
-		///Note: position of bound components (items) means position related within parent form, not for screen!
-		///to get the real screen position, use getRealXPos(), to find in CComponentsItem sub classes
-		inline virtual int getXPos(){return x;};
-		///return screen y-position of component
-		///Note: position of bound components (items) means position related within parent form, not for screen!
-		///to get the real screen position, use getRealYPos(), to find in CComponentsItem sub classes
-		inline virtual int getYPos(){return y;};
-		///return height of component
-		inline virtual int getHeight(){return height;};
-		///return width of component
-		inline virtual int getWidth(){return width;};
-		///return of frame thickness
-		inline virtual int getFrameThickness(){return fr_thickness;};
-
-		///return/set (pass through) width and height of component
-		inline virtual void getSize(int* w, int* h){*w=width; *h=height;};
-		///return/set (pass through) position and dimensions of component at once
-		inline virtual void getDimensions(int* xpos, int* ypos, int* w, int* h){*xpos=x; *ypos=y; *w=width; *h=height;};
+		virtual~CComponents(){};
 
 		///sets tag as void*, see also cc_tag
 		virtual void setTag(void* tag){cc_tag = tag;};
 		///gets tag as void*, see also cc_tag
-		inline virtual void* getTag(){return cc_tag;};
-
-		///set frame color
-		inline virtual void setColorFrame(fb_pixel_t color){col_frame = color;};
-		///set selected frame color
-		inline virtual void setColorFrameSel(fb_pixel_t color){col_frame_sel = color;};
-		///set body color
-		inline virtual void setColorBody(fb_pixel_t color){col_body = color;};
-		///set shadow color
-		inline virtual void setColorShadow(fb_pixel_t color){col_shadow = color;};
-		///set all basic framebuffer element colors at once
-		///Note: Possible color values are defined in "gui/color.h" and "gui/customcolor.h"
-		inline virtual void setColorAll(fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow){col_frame = color_frame; col_body = color_body; col_shadow = color_shadow;};
-		///set color gradient on/off
-		virtual void enableColBodyGradient(bool do_paint_gradient);
-		///set color gradient properties, possible parameter values for mode and intensity to find in CColorGradient, in driver/framebuffer.h>
-		virtual void setColBodyGradient(const int& mode, const int& direction, const int& intensity = CColorGradient::normal, uint8_t v_min=0x40, uint8_t v_max=0xE0, uint8_t s=0xC0)
-						{ cc_body_gradient_mode = mode;
-						  cc_body_gradient_direction = direction;
-						  cc_body_gradient_intensity=intensity;
-						  cc_body_gradient_intensity_v_min=v_min;
-						  cc_body_gradient_intensity_v_max=v_max;
-						  cc_body_gradient_saturation=s; };
-
-		virtual void set2ndColor(fb_pixel_t col_2nd){ cc_body_gradient_c2c = true; cc_body_gradient_2nd_col = col_2nd;};
-
-		///get frame color
-		inline virtual fb_pixel_t getColorFrame(){return col_frame;};
-		///get body color
-		inline virtual fb_pixel_t getColorBody(){return col_body;};
-		///get shadow color
-		inline virtual fb_pixel_t getColorShadow(){return col_shadow;};
-
-		///set corner types
-		///Possible corner types are defined in CFrameBuffer (see: driver/framebuffer.h)
-		///Note: default values are given from settings
-		inline virtual void setCornerType(const int& type){corner_type = type;};
-		///set corner radius and type
-		inline virtual void setCorner(const int& radius, const int& type = CORNER_ALL){corner_rad = radius; corner_type = type;};
-		///get corner types
-		inline virtual int getCornerType(){return corner_type;};
-		///get corner radius
-		inline virtual int getCornerRadius(){return corner_rad;};
-
-		///set frame thickness
-		virtual void setFrameThickness(const int& thickness, const int& thickness_sel = 3);
-		///switch shadow on/off
-		///Note: it's recommended to use #defines: CC_SHADOW_ON=true or CC_SHADOW_OFF=false as parameter, see also cc_types.h
-		inline virtual void setShadowOnOff(bool has_shadow){shadow = has_shadow;};
-
-		///hide current screen and restore background
-		virtual void hide();
-
-		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
-		///from CFrameBuffer but with possiblity to define color, default color is COL_BACKGROUND_PLUS_0 (empty background)
-		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, const int& corner_radius = -1);
-
-		///returns paint mode, true=item was painted
-		virtual bool isPainted(){return is_painted;}
-		///allows paint of elementary item parts (shadow, frame and body), similar as background, set it usually to false, if item used in a form
-		virtual void doPaintBg(bool do_paint){paint_bg = do_paint;};
-		// enable/disable CTextBox screen saving on paint
-		virtual void enableTboxSaveScreen(bool enable){ save_tbox_screen = enable; };
-
-		///allow/disalows paint of item and its contents, but initialize of other properties are not touched
-		///this can be understood as a counterpart to isPainted(), but before paint and value of is_painted is modified temporarily till next paint of item //TODO: is this sufficiently?
-		void allowPaint(bool allow){cc_allow_paint = allow; is_painted = cc_allow_paint ? false : true;};
-		///returns visibility mode
-		virtual bool paintAllowed(){return cc_allow_paint;};
-
-		///cleans saved pixel buffer
-		virtual void clearSavedScreen();
-};
-
-class CComponentsItem : public CComponents
-{
-	protected:
-		///property: define of item type, see cc_types.h for possible types
-		int cc_item_type;
-		///property: define of item index, all bound items get an index,
-		///default: CC_NO_INDEX as identifer for not embedded item and default index=0 for form as main parent
-		///see also getIndex(), setIndex()
-		int cc_item_index;
-		///property: default enabled
-		bool cc_item_enabled;
-		///property: default not selected
-		bool cc_item_selected;
-		///property: page number, this defines current item page location, means: this item is embedded in a parent container on page number n, see also setPageNumber()
-		///default value is 0 for page one, any value > 0 causes handling for mutilple pages at parent container
-		uint8_t cc_page_number;
-		///specifies that some certain operations especially eg. exec events for that item are possible, see also setFocus(), hasFocus()
-		bool cc_has_focus;
-
-		///Pointer to the form object in which this item is embedded.
-		///Is typically the type CComponentsForm or derived classes, default intialized with NULL
-		CComponentsForm *cc_parent;
-
-		///hides item, arg: no_restore=true causes no restore of background, but clean up pixel buffer if required
-		void hideCCItem(bool no_restore = false);
-		
-		///initialze of basic framebuffer elements with shadow, background and frame.
-		///must be called first in all paint() members before paint any item,
-		///If backround is not required, it's possible to override this with variable paint_bg=false, use doPaintBg(true/false) to set this!
-		///arg do_save_bg=false avoids using of unnecessary pixel memory, eg. if no hide with restore is provided. This is mostly the case  whenever
-		///an item will be hide or overpainted with other methods, or it's embedded  (bound)  in a parent form.
-		void paintInit(bool do_save_bg);
-
-		///add "this" current item to parent
-		void initParent(CComponentsForm* parent);
-
-
-	public:
-		CComponentsItem(CComponentsForm *parent = NULL);
-
-		///sets pointer to the form object in which this item is embedded.
-		virtual void setParent(CComponentsForm *parent){cc_parent = parent;};
-		///returns pointer to the form object in which this item is embedded.
-		virtual CComponentsForm* getParent(){return cc_parent;};
-		///property: returns true if item is added to a form
-		virtual bool isAdded();
-		///indicates wether item has focus
-		virtual bool hasFocus(){return cc_has_focus;}
-		///set or unset focus of item, stand alone items without parent have always set focus to true, inside of a parent form object, always the last added item has focus
-		virtual void setFocus(bool focus);
-
-		///abstract: paint item, arg: do_save_bg see paintInit() above
-		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES) = 0;
-		///hides item, arg: no_restore see hideCCItem() above
-		virtual void hide(bool no_restore = false);
-
-		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
-		///from CFrameBuffer but with possiblity to define color, default color is 0 (empty background)
-		///NOTE: Items with parent binding use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
-		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, bool ignore_parent = false);
-
-		///get the current item type, see attribute cc_item_type above
-		virtual int getItemType();
-		///syncronizes item colors with current color settings if required, NOTE: overwrites internal values!
-		virtual void syncSysColors();
-		
-		///set select mode, see also col_frame_sel
-		virtual void setSelected(bool selected){cc_item_selected = selected;};
-		///set enable mode, see also cc_item_enabled
-		virtual void setEnable(bool enabled){cc_item_enabled = enabled;};
-		
-		///get select mode, see also setSelected() above
-		virtual bool isSelected(){return cc_item_selected;};
-		///get enable mode, see also setEnable() above
-		virtual bool isEnabled(){return cc_item_enabled;};
-
-		///get current index of item, see also attribut cc_item_index
-		virtual int getIndex(){return cc_item_index;};
-		///set an index to item, see also attribut cc_item_index.
-		///To generate an index, use genIndex()
-		virtual void setIndex(const int& index){cc_item_index = index;};
-
-		///sets page location of current item, parameter as uint8_t, see: cc_page_number
-		virtual void setPageNumber(const uint8_t& on_page_number){cc_page_number = on_page_number;};
-		///returns current number of page location of current item, see: cc_page_number
-		virtual u_int8_t getPageNumber(){return cc_page_number;};
-
-		///set screen x-position, parameter as int
-		virtual void setXPos(const int& xpos);
-		///set screen y-position, parameter as int
-		virtual void setYPos(const int& ypos);
-		///set screen x-position, parameter as uint8_t, percent x value related to current width of parent form or screen
-		virtual void setXPosP(const uint8_t& xpos_percent);
-		///set screen y-position, parameter as uint8_t, percent y value related to current height of parent form or screen
-		virtual void setYPosP(const uint8_t& ypos_percent);
-		///set x and y position as percent value related to current parent form or screen dimensions at once
-		virtual void setPosP(const uint8_t& xpos_percent, const uint8_t& ypos_percent);
-
-		///do center item on screen or within a parent form, parameter along_mode assigns direction of centering
-		virtual void setCenterPos(int along_mode = CC_ALONG_X | CC_ALONG_Y);
-
-		///set item height, parameter as uint8_t, as percent value related to current height of parent form or screen
-		virtual void setHeightP(const uint8_t& h_percent);
-		///set item width, parameter as uint8_t, as percent value related to current width of parent form or screen
-		virtual void setWidthP(const uint8_t& w_percent);
-
-		///sub: init body color gradient
-		virtual void initBodyGradient();
+		virtual void* getTag(){return cc_tag;};
 };
 
 #endif
diff --git a/src/gui/components/cc_detailsline.cpp b/src/gui/components/cc_detailsline.cpp
index 6a032d4..843ebdd 100644
--- a/src/gui/components/cc_detailsline.cpp
+++ b/src/gui/components/cc_detailsline.cpp
@@ -31,6 +31,7 @@
 #include <global.h>
 #include <neutrino.h>
 #include "cc_detailsline.h"
+#include "cc_draw.h"
 
 using namespace std;
 
@@ -61,6 +62,7 @@ void CComponentsDetailLine::initVarDline(	const int& x_pos, const int& y_pos_top
 
 	//CComponentsDetailLine
 	thickness 	= 4;
+	cc_body_gradient_enable = false;
 }
 
 CComponentsDetailLine::~CComponentsDetailLine()
@@ -85,41 +87,50 @@ CComponentsDetailLine::~CComponentsDetailLine()
 //paint details line with current parameters
 void CComponentsDetailLine::paint(bool do_save_bg)
 {
-	clearFbData();
+	cc_save_bg = do_save_bg;
 
-	int y_mark_top = y-h_mark_top/2+thickness/2;
-	int y_mark_down = y_down-h_mark_down/2+thickness/2;
+	hide();
+	if (hasChanges())
+		clearFbData();
 
-	int sw = shadow_w;
+	if (v_fbdata.empty()){
 
-	comp_fbdata_t fbdata[] =
-	{
-		/* vertical item mark | */
-		{CC_FBDATA_TYPE_LINE, x+width-thickness-sw, 	y_mark_top, 		thickness, 		h_mark_top, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-sw,		y_mark_top+sw, 		sw, 			h_mark_top-sw, 		col_shadow, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-thickness,	y_mark_top+h_mark_top, 	thickness, 		sw,	 		col_shadow, 	0, 0, NULL, NULL},
+		int y_mark_top = y-h_mark_top/2+thickness/2;
+		int y_mark_down = y_down-h_mark_down/2+thickness/2;
 
-		/* horizontal item line - */
-		{CC_FBDATA_TYPE_LINE, x, 			y,			width-thickness-sw,	thickness, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+thickness,		y+thickness,		width-2*thickness-sw,	sw, 			col_shadow, 	0, 0, NULL, NULL},
+		int sw = shadow_w;
 
-		/* vertical connect line [ */
-		{CC_FBDATA_TYPE_LINE, x,			y+thickness, 		thickness, 		y_down-y-thickness, 	col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+thickness,		y+thickness+sw,		sw, 			y_down-y-thickness-sw,	col_shadow, 	0, 0, NULL, NULL},
+		cc_fbdata_t fbdata[] =
+		{
+			/*buffered bg full width and height */
+			{true, CC_FBDATA_TYPE_BGSCREEN,	x,			y_mark_top, 		width,			y_mark_down-y_mark_top+h_mark_down,	0, 0, 0, 0, NULL, NULL, NULL, false},
 
-		/* horizontal info line - */
-		{CC_FBDATA_TYPE_LINE, x,			y_down, 		width-thickness-sw, 	thickness, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+sw,			y_down+thickness, 	width-thickness-2*sw,	sw, 			col_shadow, 	0, 0, NULL, NULL},
+			/* vertical item mark | */
+			{true, CC_FBDATA_TYPE_BOX, 	x+width-thickness-sw, 	y_mark_top, 		thickness, 		h_mark_top, 		col_body, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+width-sw,		y_mark_top+sw, 		sw, 			h_mark_top-sw, 		col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+width-thickness,	y_mark_top+h_mark_top, 	thickness, 		sw,	 		col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
 
-		/* vertical info mark | */
-		{CC_FBDATA_TYPE_LINE, x+width-thickness-sw,	y_mark_down, 		thickness, 		h_mark_down, 		col_body, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-sw,		y_mark_down+sw,		sw, 			h_mark_down-sw,		col_shadow, 	0, 0, NULL, NULL},
-		{CC_FBDATA_TYPE_LINE, x+width-thickness,	y_mark_down+h_mark_down,thickness, 		sw,	 		col_shadow, 	0, 0, NULL, NULL},
-	};
+			/* horizontal item line - */
+			{true, CC_FBDATA_TYPE_BOX, 	x, 			y,			width-thickness-sw,	thickness, 		col_body, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+thickness,		y+thickness,		width-2*thickness-sw,	sw, 			col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
 
-	for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++)
-		v_fbdata.push_back(fbdata[i]);
+			/* vertical connect line [ */
+			{true, CC_FBDATA_TYPE_BOX, 	x,			y+thickness, 		thickness, 		y_down-y-thickness, 	col_body, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+thickness,		y+thickness+sw,		sw, 			y_down-y-thickness-sw,	col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
 
+			/* horizontal info line - */
+			{true, CC_FBDATA_TYPE_BOX, 	x,			y_down, 		width-thickness-sw, 	thickness, 		col_body, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+sw,			y_down+thickness, 	width-thickness-2*sw,	sw, 			col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
+
+			/* vertical info mark | */
+			{true, CC_FBDATA_TYPE_BOX, 	x+width-thickness-sw,	y_mark_down, 		thickness, 		h_mark_down, 		col_body, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+width-sw,		y_mark_down+sw,		sw, 			h_mark_down-sw,		col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
+			{true, CC_FBDATA_TYPE_BOX, 	x+width-thickness,	y_mark_down+h_mark_down,thickness, 		sw,	 		col_shadow, 	0, 0, 0, NULL, NULL, NULL, false},
+		};
+
+		for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++)
+			v_fbdata.push_back(fbdata[i]);
+	}
 	paintFbItems(do_save_bg);
 }
 
diff --git a/src/gui/components/cc_draw.cpp b/src/gui/components/cc_draw.cpp
new file mode 100644
index 0000000..c857d01
--- /dev/null
+++ b/src/gui/components/cc_draw.cpp
@@ -0,0 +1,692 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <global.h>
+#include <neutrino.h>
+#include "cc_draw.h"
+#include <cs_api.h>
+
+#include <system/debug.h>
+
+CCDraw::CCDraw() : COSDFader(g_settings.theme.menu_Content_alpha)
+{
+	frameBuffer 		= CFrameBuffer::getInstance();
+	x = cc_xr = x_old	= 0;
+	y = cc_yr = y_old	= 0;
+	height	= height_old	= CC_HEIGHT_MIN;
+	width	= width_old	= CC_WIDTH_MIN;
+
+	col_body = col_body_old			= COL_MENUCONTENT_PLUS_0;
+	col_shadow = col_shadow_old 		= COL_MENUCONTENTDARK_PLUS_0;
+	col_frame = col_frame_old 		= COL_MENUCONTENT_PLUS_6;
+	col_frame_sel = col_frame_sel_old 	= COL_MENUCONTENTSELECTED_PLUS_0;
+
+	fr_thickness = fr_thickness_old		= 0;
+	fr_thickness_sel = fr_thickness_sel_old	= 3;
+
+	corner_type = corner_type_old		= CORNER_ALL;
+	corner_rad = corner_rad_old		= 0;
+
+	shadow			= CC_SHADOW_OFF;
+	shadow_w = shadow_w_old	= SHADOW_OFFSET;
+
+	cc_paint_cache		= false;
+	cc_scrdata.pixbuf	= NULL;
+	cc_save_bg		= false;
+	firstPaint		= true;
+	is_painted		= false;
+	paint_bg 		= true;
+	cc_allow_paint		= true;
+	cc_enable_frame		= true;
+
+	cc_body_gradient_enable	= cc_body_gradient_enable_old 	= CC_COLGRAD_OFF;
+	cc_body_gradient_2nd_col = cc_body_gradient_2nd_col_old	= COL_MENUCONTENT_PLUS_0;
+
+	cc_body_gradient_mode 					= CColorGradient::gradientLight2Dark;
+	cc_body_gradient_intensity 				= CColorGradient::light;
+	cc_body_gradient_intensity_v_min 			= 0x40;
+	cc_body_gradient_intensity_v_max 			= 0xE0;
+	cc_body_gradient_saturation 				= 0xC0;
+	cc_body_gradient_direction = cc_body_gradient_direction_old	= CFrameBuffer::gradientVertical;
+
+	v_fbdata.clear();
+}
+
+CCDraw::~CCDraw()
+{
+	hide();
+	clearFbData();
+}
+
+inline bool CCDraw::applyPosChanges()
+{
+	bool ret = false;
+	if (x != x_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], Pos changes x %d != x_old %d...\033[0m\n", __func__, __LINE__, x, x_old);
+		x_old = x;
+		ret = true;
+	}
+	if (y != y_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], Pos changes y %d != y_old %d...\033[0m\n", __func__, __LINE__, y, y_old);
+		y_old = y;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline bool CCDraw::applyDimChanges()
+{
+	bool ret = false;
+	if (height != height_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes height %d != height_old %d...\033[0m\n", __func__, __LINE__, height, height_old);
+		height_old = height;
+		ret = true;
+	}
+	if (width != width_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes width %d != width_old %d...\033[0m\n", __func__, __LINE__, width, width_old);
+		width_old = width;
+		ret = true;
+	}
+	if (fr_thickness != fr_thickness_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes fr_thickness %d != fr_thickness_old %d...\033[0m\n", __func__, __LINE__, fr_thickness, fr_thickness_old);
+		fr_thickness_old = fr_thickness;
+		ret = true;
+	}
+	if (fr_thickness_sel != fr_thickness_sel_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes fr_thickness_sel %d != fr_thickness_sel_old %d...\033[0m\n", __func__, __LINE__, fr_thickness_sel, fr_thickness_sel_old);
+		fr_thickness_old = fr_thickness;
+		ret = true;
+	}
+	if (shadow_w != shadow_w_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes shadow_w_sel %d != shadow_w_old %d...\033[0m\n", __func__, __LINE__, shadow_w, shadow_w_old);
+		shadow_w_old = shadow_w;
+		ret = true;
+	}
+	if (corner_rad != corner_rad_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes corner_rad %d != corner_rad_old %d...\033[0m\n", __func__, __LINE__, corner_rad, corner_rad_old);
+		corner_rad_old = corner_rad;
+		ret = true;
+	}
+	if (corner_type != corner_type_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], dim changes corner_type %d != corner_type_old %d...\033[0m\n", __func__, __LINE__, corner_type, corner_type_old);
+		corner_type_old = corner_type;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline bool CCDraw::applyColChanges()
+{
+	bool ret = false;
+	if (col_body != col_body_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_body %d != col_body_old %d...\033[0m\n", __func__, __LINE__, col_body, col_body_old);
+		col_body_old = col_body;
+		ret = true;
+	}
+	if (col_shadow != col_shadow_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_shadow %d != col_shadow_old %d...\033[0m\n", __func__, __LINE__, col_shadow, col_shadow_old);
+		col_shadow_old = col_shadow;
+		ret = true;
+	}
+	if (col_frame != col_frame_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_frame %d != col_frame_old %d...\033[0m\n", __func__, __LINE__, col_frame, col_frame_old);
+		col_frame_old = col_frame;
+		ret = true;
+	}
+	if (col_frame_sel != col_frame_sel_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes col_frame_sel %d != col_frame_sel_old %d...\033[0m\n", __func__, __LINE__, col_frame_sel, col_frame_sel_old);
+		col_frame_old = col_frame;
+		ret = true;
+	}
+	if (cc_body_gradient_enable != cc_body_gradient_enable_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes cc_body_gradient_enable %d != cc_body_gradient_enable_old %d...\033[0m\n", __func__, __LINE__, cc_body_gradient_enable, cc_body_gradient_enable_old);
+		cc_body_gradient_enable_old = cc_body_gradient_enable;
+		ret = true;
+	}
+	if (cc_body_gradient_2nd_col != cc_body_gradient_2nd_col_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes cc_body_gradient_2nd_col %d != cc_body_gradient_2nd_col_old %d...\033[0m\n", __func__, __LINE__, cc_body_gradient_2nd_col, cc_body_gradient_2nd_col_old);
+		cc_body_gradient_2nd_col_old = cc_body_gradient_2nd_col;
+		ret = true;
+	}
+	if (cc_body_gradient_direction != cc_body_gradient_direction_old){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], col changes cc_body_gradient_direction %d != cc_body_gradient_direction_old %d...\033[0m\n", __func__, __LINE__, cc_body_gradient_direction, cc_body_gradient_direction_old);
+		cc_body_gradient_direction_old = cc_body_gradient_direction;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline bool CCDraw::hasChanges()
+{
+	if (applyPosChanges() || applyDimChanges() || applyColChanges())
+		return true;
+
+	return false;
+}
+
+inline void CCDraw::setXPos(const int& xpos)
+{
+	if (x == xpos)
+		return;
+	x = xpos;
+}
+
+inline void CCDraw::setYPos(const int& ypos)
+{
+	if (y == ypos)
+		return;
+	y = ypos;
+}
+
+inline void CCDraw::setHeight(const int& h)
+{
+	if (height == h)
+		return;
+	height = h;
+}
+
+inline void CCDraw::setWidth(const int& w)
+{
+	if (width == w)
+		return;
+	width = w;
+}
+
+void CCDraw::setFrameThickness(const int& thickness, const int& thickness_sel)
+{
+	fr_thickness = thickness;
+
+	if (fr_thickness_sel != thickness_sel)
+		fr_thickness_sel = thickness_sel;
+}
+
+bool CCDraw::enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color, const int& direction)
+{
+	if (cc_body_gradient_enable == enable_mode && cc_body_gradient_direction == direction)
+		return false;
+	dprintf(DEBUG_DEBUG, "\033[33m[CCDraw]\t[%s - %d], change gradient mode: current=[%d] new=[%d] direction=[%d]\033[0m\n", __func__, __LINE__, cc_body_gradient_enable, enable_mode, direction);
+	bool ret = false;
+	if ((cc_body_gradient_enable != enable_mode) || (cc_body_gradient_enable == CC_COLGRAD_OFF)){
+		clearScreenBuffer();
+		cc_body_gradient_enable = enable_mode;
+		ret = true;
+	}
+	if (cc_body_gradient_enable == CC_COLGRAD_COL_A_2_COL_B || cc_body_gradient_enable == CC_COLGRAD_COL_B_2_COL_A)
+		set2ndColor(sec_color);
+
+	//handle direction
+	if (cc_body_gradient_direction != direction){
+		cc_body_gradient_direction = direction;
+		ret = true;
+	}
+
+	return ret;
+}
+
+inline void CCDraw::setCornerType(const int& type)
+{
+	if (corner_type == type)
+		return;
+	corner_type = type;
+}
+
+inline void CCDraw::setCorner(const int& radius, const int& type)
+{
+	setCornerType(type);
+	if (corner_rad == radius)
+		return;
+	corner_rad = radius;
+}
+
+gradientData_t* CCDraw::getGradientData()
+{
+	if (cc_body_gradient_enable == CC_COLGRAD_OFF)
+		return NULL;
+
+	gradientData_t* gdata 	= new gradientData_t;
+	gdata->gradientBuf 	= NULL;
+	gdata->boxBuf 		= NULL;
+	gdata->direction 	= cc_body_gradient_direction;
+	gdata->mode 		= CFrameBuffer::pbrg_noFree;
+	CColorGradient ccGradient;
+	int gsize = cc_body_gradient_direction == CFrameBuffer::gradientVertical ? height : width;
+	//TODO: add modes for direction and intensity
+	switch (cc_body_gradient_enable){
+		case  CC_COLGRAD_LIGHT_2_DARK:
+			cc_body_gradient_mode = CColorGradient::gradientLight2Dark;
+			break;
+		case  CC_COLGRAD_DARK_2_LIGHT:
+			cc_body_gradient_mode = CColorGradient::gradientDark2Light;
+			break;
+		case  CC_COLGRAD_COL_A_2_COL_B:
+			cc_body_gradient_mode = CColorGradient::gradientLight2Dark;
+			break;
+		case  CC_COLGRAD_COL_B_2_COL_A:
+			cc_body_gradient_mode = CColorGradient::gradientDark2Light;
+			break;
+		case  CC_COLGRAD_COL_LIGHT_DARK_LIGHT:
+			cc_body_gradient_mode = CColorGradient::gradientLight2Dark2Light;
+			break;
+		case  CC_COLGRAD_COL_DARK_LIGHT_DARK:
+			cc_body_gradient_mode = CColorGradient::gradientDark2Light2Dark;
+			break;
+	}
+
+	if (cc_body_gradient_enable == CC_COLGRAD_COL_A_2_COL_B || cc_body_gradient_enable == CC_COLGRAD_COL_B_2_COL_A){
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], init gradient c2c)...\033[0m\n", __func__, __LINE__);
+		gdata->gradientBuf = ccGradient.gradientColorToColor(col_body,
+								cc_body_gradient_2nd_col,
+								NULL,
+								gsize,
+								cc_body_gradient_mode,
+								cc_body_gradient_intensity);
+	}else{
+		dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], init gradient single color)...\033[0m\n", __func__, __LINE__);
+		gdata->gradientBuf = ccGradient.gradientOneColor(col_body,
+							NULL,
+							gsize,
+							cc_body_gradient_mode,
+							cc_body_gradient_intensity,
+							cc_body_gradient_intensity_v_min,
+							cc_body_gradient_intensity_v_max,
+							cc_body_gradient_saturation);
+	}
+
+	return gdata;
+}
+
+bool CCDraw::clearSavedScreen()
+{
+	/* Here we clean only screen buffers from background layers.
+	 * Paint cache and gradient are not touched.
+	*/
+	bool ret = false;
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BGSCREEN){
+			if (v_fbdata[i].pixbuf){
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], cleanup bg...\033[0m\n", __func__, __LINE__);
+				delete[] v_fbdata[i].pixbuf;
+				v_fbdata[i].pixbuf = NULL;
+				ret = true;
+			}
+		}
+	}
+	return ret;
+}
+
+bool CCDraw::clearPaintCache()
+{
+	/* Here we clean only the paint cache from foreground layers.
+	 * BG layer is not touched.
+	*/
+	bool ret = false;
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].fbdata_type != CC_FBDATA_TYPE_BGSCREEN){
+			if (v_fbdata[i].pixbuf){
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], cleanup paint cache layer...\033[0m\n", __func__, __LINE__);
+				delete[] v_fbdata[i].pixbuf;
+				v_fbdata[i].pixbuf = NULL;
+				ret = true;
+			}
+		}
+	}
+	return ret;
+}
+
+//clean old gradient buffer
+bool CCDraw::clearFbGradientData()
+{
+	bool ret = false;
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].gradient_data){
+			if (v_fbdata[i].gradient_data->gradientBuf){
+				free(v_fbdata[i].gradient_data->gradientBuf);
+				v_fbdata[i].gradient_data->gradientBuf = NULL;
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], clean up gradientBuf...\033[0m\n", __func__, __LINE__);
+			}
+			if (v_fbdata[i].gradient_data->boxBuf){
+				cs_free_uncached(v_fbdata[i].gradient_data->boxBuf);
+				v_fbdata[i].gradient_data->boxBuf = NULL;
+				dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], clean up boxBuf...\033[0m\n", __func__, __LINE__);
+			}
+			delete v_fbdata[i].gradient_data;
+			v_fbdata[i].gradient_data = NULL;
+			ret = true;
+		}
+	}
+	return ret;
+}
+
+bool CCDraw::clearScreenBuffer()
+{
+	bool ret = false;
+	if (clearSavedScreen())
+		ret = true;
+	if (clearPaintCache())
+		ret = true;
+	if (clearFbGradientData())
+		ret = true;
+	firstPaint = true;
+	return ret;
+}
+
+void CCDraw::clearFbData()
+{
+	clearScreenBuffer();
+	v_fbdata.clear();
+}
+
+bool CCDraw::CheckFbData(const cc_fbdata_t& fbdata, const char* func, const int line)
+{
+	int32_t rows = fbdata.dx / (int32_t)frameBuffer->getScreenWidth(true) - 1 + fbdata.y;
+	int32_t rest = fbdata.dx % (int32_t)frameBuffer->getScreenWidth(true);
+        int32_t end  = rows * (int32_t)frameBuffer->getScreenWidth(true) + rest;
+	if (	(fbdata.x < 0 || fbdata.y < 0) ||
+		(end >= (int32_t)frameBuffer->getScreenWidth(true)*(int32_t)frameBuffer->getScreenHeight(true)) 
+	   ) {
+			dprintf(DEBUG_NORMAL, "[CCDraw] ERROR! Position < 0 or > FB end [%s - %d]\n\tx = %d  y = %d\n\tdx = %d  dy = %d\n",
+				func, line,
+				fbdata.x, fbdata.y,
+				fbdata.dx, fbdata.dy);
+			return false;
+		}
+		if (fbdata.dx == 0 || fbdata.dy == 0) {
+			dprintf(DEBUG_DEBUG,"[CCDraw]\t[%s - %d], INFO! dx and/or dy = 0, tx = %d,  y = %d, dx = %d,  dy = %d\n",
+				func, line,
+				fbdata.x, fbdata.y,
+				fbdata.dx, fbdata.dy);
+			return false;
+		}
+	return true;
+}
+
+
+
+//screen area save
+fb_pixel_t* CCDraw::getScreen(int ax, int ay, int dx, int dy)
+{
+	if (dx * dy == 0)
+		return NULL;
+
+	dprintf(DEBUG_INFO, "[CCDraw] INFO! [%s - %d], ax = %d, ay = %d, dx = %d, dy = %d\n", __func__, __LINE__, ax, ay, dx, dy);
+	fb_pixel_t* pixbuf = new fb_pixel_t[dx * dy];
+	frameBuffer->waitForIdle("CCDraw::getScreen()");
+	frameBuffer->SaveScreen(ax, ay, dx, dy, pixbuf);
+	return pixbuf;
+}
+
+cc_screen_data_t CCDraw::getScreenData(const int& ax, const int& ay, const int& dx, const int& dy)
+{
+	cc_screen_data_t res;
+	res.pixbuf = getScreen(ax, ay, dx, dy);
+	res.x = ax; res.y = ay; res.dx = dx; res.dy = dy;
+
+	return res;
+}
+
+void CCDraw::enableSaveBg(bool save_bg)
+{
+	if (!cc_save_bg || (cc_save_bg != save_bg))
+		clearSavedScreen();
+	cc_save_bg = save_bg;
+}
+
+void CCDraw::enablePaintCache(bool enable)
+{
+	if (!cc_paint_cache || (cc_paint_cache != enable))
+		clearPaintCache();
+	cc_paint_cache = enable;
+}
+
+//paint framebuffer layers
+void CCDraw::paintFbItems(bool do_save_bg)
+{
+	//first modify background handling
+	enableSaveBg(do_save_bg);
+
+	//save background before first paint, cc_save_bg must be true
+	if (firstPaint && cc_save_bg){
+		/* On first we must ensure that screen buffer is empty.
+		 * Here we clean possible screen buffers in bg layers,
+		 * without paint cache and gradient buffer.
+		*/
+		clearSavedScreen();
+
+		/* On second step we check for
+		 * usable item dimensions and exit here if found any problem
+		*/
+		for(size_t i=0; i<v_fbdata.size(); i++){
+			if (!CheckFbData(v_fbdata[i], __func__, __LINE__)){
+				break;
+			}
+
+			dprintf(DEBUG_DEBUG, "[CCDraw]\n\t[%s - %d] firstPaint->save screen: %d, fbdata_type: %d\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
+			__func__,
+			__LINE__,
+			firstPaint,
+			v_fbdata[i].fbdata_type,
+			v_fbdata[i].x,
+			v_fbdata[i].y,
+			v_fbdata[i].dx,
+			v_fbdata[i].dy);
+
+			/* here we save the background of current box before paint.
+			* Only the reserved fbdata type CC_FBDATA_TYPE_BGSCREEN is here required and is used for this.
+			* This pixel buffer is required for the hide() method that will
+			* call the restore method from framebuffer class to restore
+			* background.
+			*/
+			if (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BGSCREEN){
+				v_fbdata[i].pixbuf = getScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
+				break;
+			}
+		}
+		firstPaint = false;
+	}
+	
+	for(size_t i=0; i< v_fbdata.size(); i++){
+		cc_fbdata_t& fbdata = v_fbdata[i];
+
+		// Don't paint on dimension or position error dx or dy are 0
+		if (!CheckFbData(fbdata, __func__, __LINE__)){
+			continue;
+		}
+		int fbtype = fbdata.fbdata_type;
+
+			dprintf(DEBUG_DEBUG, "[CCDraw]\n\t[%s - %d], fbdata_[%d]\n\tx = %d\n\ty = %d\n\tdx = %d\n\tdy = %d\n",
+			__func__,
+			__LINE__,
+			(int)i,
+			fbdata.x,
+			fbdata.y,
+			fbdata.dx,
+			fbdata.dy);
+
+		/*paint all fb relevant basic parts (shadow, frame and body)
+		 * with all specified properties, paint_bg must be enabled
+		*/
+		if (cc_enable_frame){
+			if (fbtype == CC_FBDATA_TYPE_FRAME) {
+				if (fbdata.frame_thickness > 0 && cc_allow_paint)
+					frameBuffer->paintBoxFrame(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.frame_thickness, fbdata.color, fbdata.r, fbdata.rtype);
+			}
+		}
+		if (paint_bg){
+			if (fbtype == CC_FBDATA_TYPE_BACKGROUND){
+				frameBuffer->paintBackgroundBoxRel(x, y, fbdata.dx, fbdata.dy);
+			}
+			else if (fbtype == CC_FBDATA_TYPE_SHADOW_BOX && !is_painted) { //TODO: is_painted is too global here, shadow will not paint on current instance without called kill/hide
+				if (fbdata.enabled) {
+					/* here we paint the shadow around the body
+					 * on 1st step we check for already cached screen buffer, if true
+					 * then restore this instead to call the paint methode.
+					 * This could be usally, if we use existant instances of "this" object
+					*/
+					if (cc_allow_paint){
+						if (fbdata.pixbuf){
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint shadow from cache...\033[0m\n", __func__, __LINE__);
+							frameBuffer->RestoreScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.pixbuf);
+						}else{
+							frameBuffer->paintBoxRel(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.color, fbdata.r, fbdata.rtype);
+						}
+						//if is paint cache enabled
+						if (cc_paint_cache && fbdata.pixbuf == NULL)
+							fbdata.pixbuf = getScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy);
+					}
+				}
+			}
+			else if (fbtype == CC_FBDATA_TYPE_BOX){
+				if(cc_allow_paint) {
+					/* here we paint the main body of box
+					* on 1st step we check for already cached background buffer, if true
+					* then restore this instead to call the paint methodes and gradient creation
+					* paint cache can be enable/disable with enablePaintCache()
+					*/
+					if (fbdata.pixbuf){
+						dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint body from cache...\033[0m\n", __func__, __LINE__);
+						frameBuffer->RestoreScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.pixbuf);
+					}else{
+						//ensure clean gradient data on disabled gradient
+						if(cc_body_gradient_enable == CC_COLGRAD_OFF && fbdata.gradient_data){
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], gradient mode is disabled but filled\033[0m\n", __func__, __LINE__);
+							clearFbGradientData();
+						}
+						if (cc_body_gradient_enable != CC_COLGRAD_OFF){
+							/* if color gradient enabled we create a gradient_data
+							* instance and add it to the fbdata object
+							* On disabled coloor gradient we do paint only a default box
+							*/
+							if (fbdata.gradient_data == NULL){
+								dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], crate new gradient data)...\033[0m\n", __func__, __LINE__);
+								fbdata.gradient_data = getGradientData();
+							}
+
+							// if found empty gradient buffer, create it, otherwise paint from cache
+							if (fbdata.gradient_data->boxBuf == NULL){
+								dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint new gradient)...\033[0m\n", __func__, __LINE__);
+								fbdata.gradient_data->boxBuf = frameBuffer->paintBoxRel(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, 0, fbdata.gradient_data, fbdata.r, fbdata.rtype);
+								if (cc_paint_cache)
+									fbdata.pixbuf = getScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy);
+							}else{
+								dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint cached gradient)...\033[0m\n", __func__, __LINE__);
+								frameBuffer->blitBox2FB(fbdata.gradient_data->boxBuf, fbdata.dx, fbdata.dy, fbdata.x, fbdata.y);
+							}
+						}else{
+							dprintf(DEBUG_INFO, "\033[33m[CCDraw]\t[%s - %d], paint default box)...\033[0m\n", __func__, __LINE__);
+							frameBuffer->paintBoxRel(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy, fbdata.color, fbdata.r, fbdata.rtype);
+							if (cc_paint_cache)
+								fbdata.pixbuf = getScreen(fbdata.x, fbdata.y, fbdata.dx, fbdata.dy);
+						}
+					}
+					is_painted = true;
+				}
+			}
+		}
+	}
+}
+
+
+
+void CCDraw::hide()
+{
+	bool restored = false;
+
+	//restore saved screen background of item if available
+	for(size_t i =0; i< v_fbdata.size() ;i++) {
+		if (v_fbdata[i].fbdata_type == CC_FBDATA_TYPE_BGSCREEN){
+			if (v_fbdata[i].pixbuf) {
+				//restore screen from backround layer
+				frameBuffer->waitForIdle("CCDraw::hide()");
+				frameBuffer->RestoreScreen(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy, v_fbdata[i].pixbuf);
+				restored = true;
+			}
+		}
+	}
+	//cleanup background layer, but only if restore was required
+	if (restored)
+		clearSavedScreen();
+
+	is_painted = false;
+	firstPaint = true;
+}
+
+//erase or paint over rendered objects
+void CCDraw::kill(const fb_pixel_t& bg_color, const int& corner_radius)
+{
+	for(size_t i =0; i< v_fbdata.size() ;i++){
+#if 0
+		if (bg_color != COL_BACKGROUND_PLUS_0)
+#endif
+			int r =  v_fbdata[i].r;
+			if (corner_radius > -1)
+				r = corner_radius;
+			frameBuffer->paintBoxRel(v_fbdata[i].x,
+						 v_fbdata[i].y,
+						 v_fbdata[i].dx,
+						 v_fbdata[i].dy,
+						 bg_color,
+						 r,
+						 corner_type);
+			if (v_fbdata[i].frame_thickness)
+					frameBuffer->paintBoxFrame(v_fbdata[i].x,
+								   v_fbdata[i].y,
+								   v_fbdata[i].dx,
+								   v_fbdata[i].dy,
+								   v_fbdata[i].frame_thickness,
+								   bg_color,
+								   r,
+								   corner_type);
+
+#if 0
+		else
+			frameBuffer->paintBackgroundBoxRel(v_fbdata[i].x, v_fbdata[i].y, v_fbdata[i].dx, v_fbdata[i].dy);
+#endif
+	}
+
+	firstPaint = true;
+	is_painted = false;
+}
+
+bool CCDraw::doPaintBg(bool do_paint)
+{
+	if (paint_bg == do_paint)
+		return false;
+	
+	paint_bg = do_paint;
+	//clearSavedScreen();
+	return true;
+}
+
+void CCDraw::enableShadow(int mode, const int& shadow_width)
+{
+	if (shadow != mode)
+		shadow = mode;
+	if (shadow != CC_SHADOW_OFF)
+		if (shadow_width != -1)
+			setShadowWidth(shadow_width);
+}
+
diff --git a/src/gui/components/cc_draw.h b/src/gui/components/cc_draw.h
new file mode 100644
index 0000000..989a2ee
--- /dev/null
+++ b/src/gui/components/cc_draw.h
@@ -0,0 +1,309 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_DRAW__
+#define __CC_DRAW__
+
+#include "cc_types.h"
+#include <driver/colorgradient.h>
+#include <driver/fade.h>
+#include <gui/color.h>
+
+/// Basic component class.
+/*!
+Basic paint attributes and member functions for component classes
+*/
+
+class CCDraw : public COSDFader
+{
+	protected:
+		///pixel buffer handling, returns pixel buffer depends of given parameters
+		fb_pixel_t* getScreen(int ax, int ay, int dx, int dy);
+		///returns screen data as screen_data_t
+		cc_screen_data_t getScreenData(const int& ax, const int& ay, const int& dx, const int& dy);
+		cc_screen_data_t cc_scrdata;
+
+		///object: framebuffer object, usable in all sub classes
+		CFrameBuffer * frameBuffer;
+		
+		///property: x-position on screen, to alter with setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
+		int x, x_old;
+		///property: y-position on screen, to alter setPos() or setDimensionsAll(), see also defines CC_APPEND, CC_CENTERED
+		int y, y_old;
+		///property: contains real x-position on screen
+		int cc_xr;
+		///property: contains real y-position on screen
+		int cc_yr;
+		///property: height-dimension on screen, to alter with setHeight() or setDimensionsAll()
+		int height, height_old;
+		///property: width-dimension on screen, to alter with setWidth() or setDimensionsAll()
+		int width, width_old;
+
+		///property: color of body
+		fb_pixel_t col_body, col_body_old;
+		///property: color of shadow
+		fb_pixel_t col_shadow, col_shadow_old;
+		///property: color of frame
+		fb_pixel_t col_frame, col_frame_old;
+		///property: color of frame if component is selected, Note: fr_thickness_sel must be set
+		fb_pixel_t col_frame_sel, col_frame_sel_old;
+
+		 ///property: frame thickness, see also setFrameThickness()
+		int fr_thickness, fr_thickness_old;
+		///property: frame thickness of selected component, see also setFrameThickness()
+		int fr_thickness_sel, fr_thickness_sel_old;
+
+		///property: has corners with definied type, types are defined in /driver/frambuffer.h, without effect, if corner_radius=0
+		int corner_type, corner_type_old;
+		///property: defined radius of corner, without effect, if corner_type=0
+		int corner_rad, corner_rad_old;
+
+		///property: shadow mode 0 = CC_SHADOW_OFF
+		int shadow;
+		///property: width of shadow
+		int shadow_w, shadow_w_old;
+
+		///returns true if internal property was changed
+		virtual bool hasChanges();
+		///apply current position changes and returns true if internal values were changed
+		virtual bool applyPosChanges();
+		///apply current dimension changes and returns true if internal values were changed
+		virtual bool applyDimChanges();
+		///apply current color changes and returns true if internal values were changed
+		virtual bool applyColChanges();
+
+		///paint caching for body and shadow, default init value = true, see also enablePaintCache() NOTE: has no effect if paint_bg = false
+		bool cc_paint_cache;
+		
+		///enable/disable background buffer, default init value = false, see also enableSaveBg()
+		bool cc_save_bg;
+
+		///container: for frambuffer properties and pixel buffer
+		std::vector<cc_fbdata_t> v_fbdata;
+
+		///status: true=component was painted for 1st time
+		bool firstPaint;
+		///status: true=component was rendered
+		bool is_painted;
+		///mode: true=activate rendering of basic elements (frame, shadow and body)
+		bool paint_bg;
+		///mode: true=activate rendering of frame
+		bool cc_enable_frame;
+		///mode:  true=allows painting of item, see also allowPaint()
+		bool cc_allow_paint;
+
+		///property: true component can paint gradient, see also enableColBodyGradient() TODO: if possible, merge all gradient properties into only one variable
+		int cc_body_gradient_enable, cc_body_gradient_enable_old;
+		///property: background gradient mode
+		int cc_body_gradient_mode;
+		///property: background gradient intensity
+		int cc_body_gradient_intensity;
+		///property: background gradient intensity value min
+		uint8_t cc_body_gradient_intensity_v_min;
+		///property: background gradient intensity value max
+		uint8_t cc_body_gradient_intensity_v_max;
+		///property: background gradient saturation
+		uint8_t cc_body_gradient_saturation;
+		///property: background gradient direction
+		int cc_body_gradient_direction, cc_body_gradient_direction_old;
+
+		//TODO: move into layers
+		int old_gradient_color;
+		///property: background gradient 2nd color
+		fb_pixel_t cc_body_gradient_2nd_col, cc_body_gradient_2nd_col_old;
+
+		///check current fbdtata position and dimensions, parameter fbdata is an element of v_fbdata, returns false on error
+		bool CheckFbData(const cc_fbdata_t& fbdata, const char* func, const int line);
+
+		///sub: get gradient data evaluted with current parameters
+		gradientData_t* getGradientData();
+
+		///rendering of framebuffer elements at once,
+		///elements are contained in v_fbdata, presumes added frambuffer elements with paintInit(),
+		///parameter do_save_bg=true, saves background of element to pixel buffer, this can be restore with hide()
+		void paintFbItems(bool do_save_bg = true);
+
+	public:
+		///basic component class constructor.
+		CCDraw();
+		virtual~CCDraw();
+
+		///cleans saved screen buffer, required by hide(), returns true if any buffer was deleted
+		virtual bool clearSavedScreen();
+		///cleanup paint cache, removes saved buffer contents from cached foreground layers, returns true if any buffer was removed
+		virtual bool clearPaintCache();
+		///cleanup old gradient buffers, returns true if any gradient buffer data was removed
+		virtual bool clearFbGradientData();
+
+		///cleans all possible screen buffers, it calls clearSavedScreen(), clearPaintCache() and  clearFbGradientData() at once
+		virtual bool clearScreenBuffer();
+		///does the same like clearScreenBuffer(), additional cleans v_fbdata layers and reset layer properties
+		virtual void clearFbData();
+
+		///set screen x-position, parameter as int
+		virtual void setXPos(const int& xpos);
+		///set screen y-position, parameter as int
+		virtual void setYPos(const int& ypos);
+		///set x and y position at once
+		///Note: position of bound components (items) means position related within parent form, not for screen!
+		///to set the real screen position, look at setRealPos()
+		virtual void setPos(const int& xpos, const int& ypos){setXPos(xpos); setYPos(ypos);}
+
+		///sets real x position on screen. Use this, if item is added to a parent form
+		virtual void setRealXPos(const int& xr){cc_xr = xr;}
+		///sets real y position on screen. Use this, if item is added to a parent form
+		virtual void setRealYPos(const int& yr){cc_yr = yr;}
+		///sets real x and y position on screen at once. Use this, if item is added to a parent form
+		virtual void setRealPos(const int& xr, const int& yr){cc_xr = xr; cc_yr = yr;}
+		///get real x-position on screen. Use this, if item contains own render methods and item is bound to a form
+		virtual int getRealXPos(){return cc_xr;}
+		///get real y-position on screen. Use this, if item contains own render methods and item is bound to a form
+		virtual int getRealYPos(){return cc_yr;}
+		
+		///set height of component on screen
+		virtual void setHeight(const int& h);
+		///set width of component on screen
+		virtual void setWidth(const int& w);
+		///set all positions and dimensions of component at once
+		virtual void setDimensionsAll(const int& xpos, const int& ypos, const int& w, const int& h){setPos(xpos, ypos); setWidth(w); setHeight(h);}
+
+		///return screen x-position of component
+		///Note: position of bound components (items) means position related within parent form, not for screen!
+		///to get the real screen position, use getRealXPos(), to find in CComponentsItem sub classes
+		virtual int getXPos(){return x;};
+		///return screen y-position of component
+		///Note: position of bound components (items) means position related within parent form, not for screen!
+		///to get the real screen position, use getRealYPos(), to find in CComponentsItem sub classes
+		virtual int getYPos(){return y;}
+		///return height of component
+		virtual int getHeight(){return height;}
+		///return width of component
+		virtual int getWidth(){return width;}
+
+		///return/set (pass through) width and height of component
+		virtual void getSize(int* w, int* h){*w=width; *h=height;}
+		///return/set (pass through) position and dimensions of component at once
+		virtual void getDimensions(int* xpos, int* ypos, int* w, int* h){*xpos=x; *ypos=y; *w=width; *h=height;}
+
+		///set frame thickness
+		virtual void setFrameThickness(const int& thickness, const int& thickness_sel = 3);
+		///return of frame thickness
+		virtual int getFrameThickness(){return fr_thickness;}
+		///set frame color
+		virtual void setColorFrame(fb_pixel_t color){col_frame = color;}
+		///set selected frame color
+		virtual void setColorFrameSel(fb_pixel_t color){col_frame_sel = color;}
+		virtual void set2ndColor(fb_pixel_t col_2nd){cc_body_gradient_2nd_col = col_2nd;}
+
+		///get frame color
+		virtual fb_pixel_t getColorFrame(){return col_frame;}
+		///get body color
+		virtual fb_pixel_t getColorBody(){return col_body;}
+		///get shadow color
+		virtual fb_pixel_t getColorShadow(){return col_shadow;}
+
+		///set body color
+		virtual void setColorBody(fb_pixel_t color){col_body = color;}
+		///set shadow color
+		virtual void setColorShadow(fb_pixel_t color){col_shadow = color;}
+		///set all basic framebuffer element colors at once
+		///Note: Possible color values are defined in "gui/color.h" and "gui/customcolor.h"
+		virtual void setColorAll(fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow){col_frame = color_frame; col_body = color_body; col_shadow = color_shadow;};
+
+		///set corner types
+		///Possible corner types are defined in CFrameBuffer (see: driver/framebuffer.h)
+		///Note: default values are given from settings
+		virtual void setCornerType(const int& type);
+		///set corner radius and type
+		virtual void setCorner(const int& radius, const int& type = CORNER_ALL);
+		///get corner types
+		inline virtual int getCornerType(){return corner_type;};
+		///get corner radius
+		inline virtual int getCornerRadius(){return corner_rad;};
+
+		///switch shadow on/off
+		virtual void setShadowWidth(const int& shadow_width){if (shadow_w != shadow_width) shadow_w = shadow_width;}
+		///Note: it's recommended to use #defines: CC_SHADOW_ON=true or CC_SHADOW_OFF=false as parameter, see also cc_types.h
+		virtual void enableShadow(int mode = CC_SHADOW_ON, const int& shadow_width = -1);
+		///switch shadow off
+		virtual void disableShadow(){enableShadow(CC_SHADOW_OFF);}
+
+		///paint caching for body and shadow, see also cc_paint_cache NOTE: has no effect if paint_bg = false
+		virtual void enablePaintCache(bool enable = true);
+		///disable paint caching for body and shadow
+		virtual void disablePaintCache(){enablePaintCache(false);}
+
+		///returns paint mode, true=item was painted
+		virtual bool isPainted(){return is_painted;}
+		///allows paint of elementary item parts (shadow, frame and body), similar as background, set it usually to false, if item used in a form, returns true, if mode has changed, also cleans screnn buffer
+		virtual bool doPaintBg(bool do_paint);
+		///allows paint frame around body, default true , NOTE: ignored if frame width = 0
+		virtual void enableFrame(bool enable = true, const int& frame_width = -1){cc_enable_frame = enable; setFrameThickness(frame_width == -1 ? fr_thickness : frame_width);}
+		///disallow paint frame around body
+		virtual void disableFrame(){enableFrame(false);}
+		///enable/disable background buffering, default action = enable, see also cc_save_bg
+		virtual void enableSaveBg(bool save_bg = true);
+		///disable background buffering, does the same like enableSaveBg(false), NOTE: cleans existant pixbuffer content!
+		virtual void disableSaveBg(){enableSaveBg(false);}
+
+		///allow/disalows paint of item and its contents, but initialize of other properties are not touched
+		///this can be understood as a counterpart to isPainted(), but before paint and value of is_painted is modified temporarily till next paint of item //TODO: is this sufficiently?
+		void allowPaint(bool allow){cc_allow_paint = allow; is_painted = cc_allow_paint ? false : true;}
+		///returns visibility mode
+		virtual bool paintAllowed(){return cc_allow_paint;};
+
+		///set color gradient on/off, returns true if gradient mode was changed
+		virtual bool enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/, const int& direction = 1 /*CFrameBuffer::gradientVertical*/);
+		///disable color gradient, returns true if gradient mode was changed
+		virtual bool disableColBodyGradient(){return enableColBodyGradient(CC_COLGRAD_OFF);}
+		///set color gradient properties, possible parameter values for mode and intensity to find in CColorGradient, in driver/framebuffer.h>
+		virtual void setColBodyGradient(const int& mode, const int& direction  = 1 /*CFrameBuffer::gradientVertical*/, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/, const int& intensity = CColorGradient::normal, uint8_t v_min=0x40, uint8_t v_max=0xE0, uint8_t s=0xC0)
+						{	cc_body_gradient_intensity=intensity;
+							cc_body_gradient_intensity_v_min=v_min;
+							cc_body_gradient_intensity_v_max=v_max;
+							cc_body_gradient_saturation=s;
+							enableColBodyGradient(mode, sec_color, direction);}
+		///gets current color gradient mode
+		virtual int getColBodyGradientMode(){return cc_body_gradient_enable;}
+
+		///abstract: paint item, arg: do_save_bg see paintInit() above
+		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES) = 0;
+		///paint item, same like paint(CC_SAVE_SCREEN_YES) but without any argument
+		virtual void paint1(){paint(CC_SAVE_SCREEN_YES);}
+		///paint item, same like paint(CC_SAVE_SCREEN_NO) but without any argument
+		virtual void paint0(){paint(CC_SAVE_SCREEN_NO);}
+
+		/*!
+		 Removes current item from screen and
+		 restore last displayed background before item was painted and
+		 ensures demage of already existing screen buffers too.
+		*/
+		virtual void hide();
+
+		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
+		///from CFrameBuffer but with possiblity to define color, default color is COL_BACKGROUND_PLUS_0 (empty background)
+		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, const int& corner_radius = -1);
+};
+
+#endif
diff --git a/src/gui/components/cc_extra.cpp b/src/gui/components/cc_extra.cpp
new file mode 100644
index 0000000..00d3a83
--- /dev/null
+++ b/src/gui/components/cc_extra.cpp
@@ -0,0 +1,123 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Extra functions based up GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <global.h>
+#include <neutrino.h>
+#include "cc_extra.h"
+#include <system/debug.h>
+
+using namespace std;
+
+bool paintBoxRel(	const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy,
+			const fb_pixel_t& color_body,
+			const int& radius,
+			const int& corner_type,
+			const int& gradient_mode,
+			const int& gradient_sec_col,
+			const int& gradient_direction,
+			const int& gradient_intensity,
+			const int& w_frame,
+			const fb_pixel_t& color_frame,
+			int shadow_mode,
+			const fb_pixel_t& color_shadow)
+{
+	CComponentsShapeSquare box(x, y, dx, dy, NULL, shadow_mode, color_frame, color_body, color_shadow);
+	box.setColBodyGradient(gradient_mode, gradient_direction, gradient_sec_col, gradient_intensity);
+	box.setCorner(radius, corner_type);
+	box.enableFrame(w_frame, w_frame);
+	box.paint(CC_SAVE_SCREEN_NO);
+	return box.isPainted();
+}
+
+bool paintBoxRel0(	const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy,
+			const fb_pixel_t& color_body,
+			const int& radius,
+			const int& corner_type,
+			const int& w_frame,
+			const fb_pixel_t& color_frame,
+			int shadow_mode,
+			const fb_pixel_t& color_shadow)
+{
+	return paintBoxRel(x, y, dx, dy, color_body, radius, corner_type, w_frame, CC_COLGRAD_OFF, COL_MENUCONTENT_PLUS_0, CFrameBuffer::gradientVertical, CColorGradient::normal, color_frame, shadow_mode, color_shadow);
+}
+
+bool paintTextBoxRel(	const string& text,
+			const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy,
+			Font *font,
+			const int& mode,
+			const int& font_style,
+			const fb_pixel_t& color_text,
+			const fb_pixel_t& color_body,
+			const int& radius,
+			const int& corner_type,
+			const int& gradient_mode,
+			const int& gradient_sec_col,
+			const int& gradient_direction,
+			const int& gradient_intensity,
+			const fb_pixel_t& color_frame,
+			int shadow_mode,
+			const fb_pixel_t& color_shadow)
+{
+	CComponentsText box(x, y, dx, dy, text, mode, font, font_style, NULL, shadow_mode, color_text, color_frame, color_body, color_shadow);
+	box.setColBodyGradient(gradient_mode, gradient_direction, gradient_sec_col, gradient_intensity);
+	box.doPaintBg(color_body !=0);
+	box.enableTboxSaveScreen(false);
+	box.setCorner(radius, corner_type);
+	box.paint(CC_SAVE_SCREEN_NO);
+
+	return box.isPainted();
+}
+
+bool paintImage(	const std::string& image_name,
+			const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy,
+			const int& transparent,
+			const fb_pixel_t& color_body,
+			const int& radius,
+			const int& corner_type,
+			const fb_pixel_t& color_frame,
+			int shadow_mode,
+			const fb_pixel_t& color_shadow)
+{
+	CComponentsPicture box( x, y, dx, dy, image_name, NULL, shadow_mode, color_frame, color_body, color_shadow, transparent);
+	box.doPaintBg(color_body !=0);
+	box.setCorner(radius, corner_type);
+	box.paint(CC_SAVE_SCREEN_NO);
+
+	return box.isPicPainted();
+}
diff --git a/src/gui/components/cc_extra.h b/src/gui/components/cc_extra.h
new file mode 100644
index 0000000..f63b75a
--- /dev/null
+++ b/src/gui/components/cc_extra.h
@@ -0,0 +1,276 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Extra functions based up GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_EXTRA_H__
+#define __CC_EXTRA_H__
+
+#include "cc_item_shapes.h"
+#include "cc_item_text.h"
+
+/** 	Paint a box on screen.
+*	@param[in] x 				position
+*	@param[in] y 				position
+*	@param[in] dx 				witdh
+*	@param[in] dy 				height
+*	@param[in] color_body			color of background, default = COL_MENUCONTENT_PLUS_0
+*	@param[in] radius 			corner radius, default = 0
+*	@param[in] corner_type 			corner type, defined in drivers/framebuffer.h
+*						@li CORNER_NONE (default)
+*						@li CORNER_TOP_LEFT
+*						@li CORNER_TOP_RIGHT
+*						@li CORNER_TOP
+*						@li CORNER_BOTTOM_RIGHT
+*						@li CORNER_RIGHT
+*						@li CORNER_BOTTOM_LEFT
+*						@li CORNER_LEFT
+*						@li CORNER_BOTTOM
+*						@li CORNER_ALL
+*	@param[in] gradient_mode 		mode of color gradient
+*						@li CC_COLGRAD_OFF (default)
+*						@li CC_COLGRAD_LIGHT_2_DARK
+*						@li CC_COLGRAD_DARK_2_LIGHT
+*						@li CC_COLGRAD_COL_A_2_COL_B
+*						@li CC_COLGRAD_COL_B_2_COL_A
+*						@li CC_COLGRAD_COL_LIGHT_DARK_LIGHT
+*						@li CC_COLGRAD_COL_DARK_LIGHT_DARK
+*	@param[in] gradient_sec_col 		secondary gradient color, default = COL_MENUCONTENT_PLUS_0
+*	@param[in] gradient_direction 		mode of color gradient
+*						@li CFrameBuffer::gradientVertical (default)
+*						@li CFrameBuffer::gradientHorizontal
+*	@param[in] gradient_intensity 		gradient intensity
+*						@li ColorGradient::light
+*						@li ColorGradient::normal (default)
+*						@li CFrameBuffer::advanced
+*	@param[in] color_frame 			color of frame around box, default = COL_MENUCONTENT_PLUS_6
+*	@param[in] shadow_mode 			enable/disable shadow behind box, default = CC_SHADOW_OFF
+*	@param[in] color_shadow 		color of shadow, default = COL_MENUCONTENTDARK_PLUS_0
+*
+*	@return
+*		True if painted
+*	@see
+* 		@li CCDraw()
+* 		@li CComponentsShapeSquare()
+*		@li colors.h
+*		@li driver/framebuffer.h
+*		@li driver/colorgradient.h
+*/
+bool paintBoxRel(	const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy,
+			const fb_pixel_t& color_body = COL_MENUCONTENT_PLUS_0,
+			const int& radius = 0,
+			const int& corner_type = CORNER_NONE,
+			const int& gradient_mode = CC_COLGRAD_OFF,
+			const int& gradient_sec_col = COL_MENUCONTENT_PLUS_0,
+			const int& gradient_direction = CFrameBuffer::gradientVertical,
+			const int& gradient_intensity = CColorGradient::normal,
+			const int& w_frame = 0,
+			const fb_pixel_t& color_frame = COL_MENUCONTENT_PLUS_6,
+			int shadow_mode = CC_SHADOW_OFF,
+			const fb_pixel_t& color_shadow = COL_MENUCONTENTDARK_PLUS_0);
+
+/** 	Paint a box on screen.
+*	@param[in] x 				position
+*	@param[in] y 				position
+*	@param[in] dx 				witdh
+*	@param[in] dy 				height
+*	@param[in] color_body			color of background, default = COL_MENUCONTENT_PLUS_0
+*	@param[in] radius 			corner radius, default = 0
+*	@param[in] corner_type 			corner type, defined in drivers/framebuffer.h
+*						@li CORNER_NONE (default)
+*						@li CORNER_TOP_LEFT
+*						@li CORNER_TOP_RIGHT
+*						@li CORNER_TOP
+*						@li CORNER_BOTTOM_RIGHT
+*						@li CORNER_RIGHT
+*						@li CORNER_BOTTOM_LEFT
+*						@li CORNER_LEFT
+*						@li CORNER_BOTTOM
+*						@li CORNER_ALL
+*	@param[in] color_frame 			color of frame around box, default = COL_MENUCONTENT_PLUS_6
+*	@param[in] shadow_mode 			enable/disable shadow behind box, default = CC_SHADOW_OFF
+*	@param[in] color_shadow 		color of shadow, default = COL_MENUCONTENTDARK_PLUS_0
+*
+*	@return
+*		True if painted
+*	@see
+* 		@li CCDraw()
+* 		@li CComponentsShapeSquare()
+*		@li colors.h
+*		@li driver/framebuffer.h
+*		@li driver/colorgradient.h
+*/
+bool paintBoxRel0(	const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy,
+			const fb_pixel_t& color_body,
+			const int& radius = 0,
+			const int& corner_type = CORNER_NONE,
+			const int& w_frame = 0,
+			const fb_pixel_t& color_frame = COL_MENUCONTENT_PLUS_6,
+			int shadow_mode = CC_SHADOW_OFF,
+			const fb_pixel_t& color_shadow = COL_MENUCONTENTDARK_PLUS_0);
+
+/** 	Paint a text box on screen.
+*	@param[in] std::string& 		text
+*	@param[in] x 				position
+*	@param[in] y 				position
+*	@param[in] dx 				witdh
+*	@param[in] dy 				height
+*	@param[in] *font			pointer to font type object, default = NULL, sets g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL] as default font
+*	@param[in] color_body			color of box, default = COL_MENUCONTENT_PLUS_0
+*	@param[in] font_style			font style
+*						@li CComponentsText::FONT_STYLE_REGULAR (default)
+*						@li CComponentsText::FONT_STYLE_BOLD,
+*						@li CComponentsText::FONT_STYLE_ITALIC
+*	@param[in] radius 			corner radius, default = 0
+*	@param[in] corner_type 			corner type, defined in drivers/framebuffer.h
+*						@li CORNER_NONE (default)
+*						@li CORNER_TOP_LEFT
+*						@li CORNER_TOP_RIGHT
+*						@li CORNER_TOP
+*						@li CORNER_BOTTOM_RIGHT
+*						@li CORNER_RIGHT
+*						@li CORNER_BOTTOM_LEFT
+*						@li CORNER_LEFT
+*						@li CORNER_BOTTOM
+*						@li CORNER_ALL
+*	@param[in] gradient_mode 		mode of color gradient
+*						@li CC_COLGRAD_OFF (default)
+*						@li CC_COLGRAD_LIGHT_2_DARK
+*						@li CC_COLGRAD_DARK_2_LIGHT
+*						@li CC_COLGRAD_COL_A_2_COL_B
+*						@li CC_COLGRAD_COL_B_2_COL_A
+*						@li CC_COLGRAD_COL_LIGHT_DARK_LIGHT
+*						@li CC_COLGRAD_COL_DARK_LIGHT_DARK
+*	@param[in] gradient_sec_col 		secondary gradient color, default = COL_MENUCONTENT_PLUS_0
+*	@param[in] gradient_direction 		mode of color gradient
+*						@li CFrameBuffer::gradientVertical (default)
+*						@li CFrameBuffer::gradientHorizontal
+*	@param[in] gradient_intensity 		gradient intensity
+*						@li ColorGradient::light
+*						@li ColorGradient::normal (default)
+*						@li CFrameBuffer::advanced
+*	@param[in] color_frame 			color of frame around box, default = COL_MENUCONTENT_PLUS_6
+*	@param[in] shadow_mode 			enable/disable shadow behind box, default = CC_SHADOW_OFF
+*	@param[in] color_shadow 		color of shadow, default = COL_MENUCONTENTDARK_PLUS_0
+*
+*	@return
+*		True if painted
+*	@see
+*		@li CCDraw()
+*		@li CComponentsText()
+*		@li CComponentsLabel()
+*		@li CTextBox()
+*		@li colors.h
+*		@li driver/framebuffer.h
+*		@li driver/colorgradient.h
+*/
+bool paintTextBoxRel(	const std::string& text,
+			const int& x,
+			const int& y,
+			const int& dx,
+			const int& dy = 0,
+			Font *font = NULL,
+			const int& mode = CTextBox::AUTO_WIDTH,
+			const int& font_style = CComponentsText::FONT_STYLE_REGULAR,
+			const fb_pixel_t& color_text = COL_MENUCONTENT_TEXT,
+			const fb_pixel_t& color_body = COL_MENUCONTENT_PLUS_0,
+			const int& radius = 0,
+			const int& corner_type = CORNER_NONE,
+			const int& gradient_mode = CC_COLGRAD_OFF,
+			const int& gradient_sec_col = COL_MENUCONTENT_PLUS_0,
+			const int& gradient_direction = CFrameBuffer::gradientVertical,
+			const int& gradient_intensity = CColorGradient::normal,
+			const fb_pixel_t& color_frame = COL_MENUCONTENT_PLUS_6,
+			int shadow_mode = CC_SHADOW_OFF,
+			const fb_pixel_t& color_shadow = COL_MENUCONTENTDARK_PLUS_0);
+
+/** 	Paint an image on screen.
+*	@param[in] std::string& 		full path or filename
+*	@param[in] x 				position
+*	@param[in] y 				position
+*	@param[in] dx 				witdh, default = 0 (no scale)
+*	@param[in] dy 				height, default = 0 (no scale)
+*	@param[in] transparent			image transparency mode
+*						@li CFrameBuffer::TM_EMPTY
+						@li CFrameBuffer::TM_NONE (default)
+						@li CFrameBuffer::TM_BLACK
+						@li CFrameBuffer::TM_INI
+*	@param[in] color_body			color of background, default = 0 (no background)
+*	@param[in] radius 			corner radius of background, default = 0
+*	@param[in] corner_type 			corner type of background, defined in drivers/framebuffer.h
+*						@li CORNER_NONE (default)
+*						@li CORNER_TOP_LEFT
+*						@li CORNER_TOP_RIGHT
+*						@li CORNER_TOP
+*						@li CORNER_BOTTOM_RIGHT
+*						@li CORNER_RIGHT
+*						@li CORNER_BOTTOM_LEFT
+*						@li CORNER_LEFT
+*						@li CORNER_BOTTOM
+*						@li CORNER_ALL
+*	@param[in] gradient_mode 		mode of background color gradient
+*						@li CC_COLGRAD_OFF (default)
+*						@li CC_COLGRAD_LIGHT_2_DARK
+*						@li CC_COLGRAD_DARK_2_LIGHT
+*						@li CC_COLGRAD_COL_A_2_COL_B
+*						@li CC_COLGRAD_COL_B_2_COL_A
+*						@li CC_COLGRAD_COL_LIGHT_DARK_LIGHT
+*						@li CC_COLGRAD_COL_DARK_LIGHT_DARK
+*	@param[in] gradient_sec_col 		secondary gradient background color, default = COL_MENUCONTENT_PLUS_0
+*	@param[in] gradient_direction 		background color gradient direction
+*						@li CFrameBuffer::gradientVertical (default)
+*						@li CFrameBuffer::gradientHorizontal
+*	@param[in] gradient_intensity 		background gradient intensity
+*						@li ColorGradient::light
+*						@li ColorGradient::normal (default)
+*						@li CFrameBuffer::advanced
+*	@param[in] color_frame 			color of frame around box, default = COL_MENUCONTENT_PLUS_6
+*	@param[in] shadow_mode 			enable/disable shadow behind box, default = CC_SHADOW_OFF
+*	@param[in] color_shadow 		color of shadow, default = COL_MENUCONTENTDARK_PLUS_0
+*
+*	@return
+*		True if painted
+*	@see
+*		@li icons.h
+*		@li colors.h
+*		@li CComponentsPicture()
+*		@li driver/framebuffer.h
+*		@li driver/colorgradient.h
+*/
+bool paintImage(	const std::string& image_name,
+			const int& x,
+			const int& y,
+			const int& dx = 0,
+			const int& dy = 0,
+			const int& transparent = CFrameBuffer::TM_NONE,
+			const fb_pixel_t& color_body = 0,
+			const int& radius = 0,
+			const int& corner_type = CORNER_NONE,
+			const fb_pixel_t& color_frame = COL_MENUCONTENT_PLUS_6,
+			int shadow_mode = CC_SHADOW_OFF,
+			const fb_pixel_t& color_shadow = COL_MENUCONTENTDARK_PLUS_0);
+#endif
diff --git a/src/gui/components/cc_frm.cpp b/src/gui/components/cc_frm.cpp
index fb4b3c7..e433401 100644
--- a/src/gui/components/cc_frm.cpp
+++ b/src/gui/components/cc_frm.cpp
@@ -39,7 +39,7 @@ using namespace std;
 //sub class CComponentsForm from CComponentsItem
 CComponentsForm::CComponentsForm(	const int x_pos, const int y_pos, const int w, const int h,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow)
@@ -47,18 +47,11 @@ CComponentsForm::CComponentsForm(	const int x_pos, const int y_pos, const int w,
 {
 	cc_item_type 	= CC_ITEMTYPE_FRM;
 
-	x		= x_pos;
-	y 		= y_pos;
-	cc_xr 		= x;
-	cc_yr 		= y;
-	width 		= w;
-	height	 	= h;
-
-	shadow		= has_shadow;
-	col_frame 	= color_frame;
-	col_body	= color_body;
-	col_shadow	= color_shadow;
+	Init(x_pos, y_pos, w, h, color_frame, color_body, color_shadow);
+	cc_xr 	= x;
+	cc_yr 	= y;
 
+	shadow 		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 	corner_rad	= RADIUS_LARGE;
 	corner_type 	= CORNER_ALL;
@@ -80,6 +73,15 @@ CComponentsForm::CComponentsForm(	const int x_pos, const int y_pos, const int w,
 	this->OnExec.connect(sl);
 }
 
+void CComponentsForm::Init(	const int& x_pos, const int& y_pos, const int& w, const int& h,
+				const fb_pixel_t& color_frame,
+				const fb_pixel_t& color_body,
+				const fb_pixel_t& color_shadow)
+{
+	setDimensionsAll(x_pos, y_pos, w, h);
+	setColorAll(color_frame, color_body, color_shadow);
+}
+
 CComponentsForm::~CComponentsForm()
 {
 	clear();
@@ -292,7 +294,7 @@ void CComponentsForm::insertCCItem(const uint& cc_item_id, CComponentsItem* cc_I
 
 	if (v_cc_items.empty()){
 		addCCItem(cc_Item);
-		dprintf(DEBUG_DEBUG, "[CComponentsForm]  %s insert cc_Item not possible, v_cc_items is empty, cc_Item added\n", __func__);
+		dprintf(DEBUG_NORMAL, "[CComponentsForm]  %s insert cc_Item not possible, v_cc_items is empty, cc_Item added\n", __func__);
 	}else{
 		v_cc_items.insert(v_cc_items.begin()+cc_item_id, cc_Item);
 		cc_Item->setParent(this);
@@ -520,23 +522,23 @@ void CComponentsForm::paintCCItems()
 		cc_item->allowPaint(item_visible);
 	}
 }
-
-void CComponentsForm::hide(bool no_restore)
+#if 0
+void CComponentsForm::hide()
 {
 	// hack: ensure hiding of minitv during hide of forms and inherited classes,
 	// because the handling of minitv items are different to other item types
 	// and need an explizit call of hide()
 	for(size_t i=0; i<v_cc_items.size(); i++) {
 		if (v_cc_items[i]->getItemType() == CC_ITEMTYPE_PIP){
-			v_cc_items[i]->hide();
+			v_cc_items[i]->kill();
 			break;
 		}
 	}
 
 	//hide body
-	hideCCItem(no_restore);
+	CComponents::hide();
 }
-
+#endif
 //erase or paint over rendered objects
 void CComponentsForm::killCCItems(const fb_pixel_t& bg_color, bool ignore_parent)
 {
@@ -649,3 +651,47 @@ void CComponentsForm::ScrollPage(int direction, bool do_paint)
 
 	OnAfterScrollPage();
 }
+
+bool CComponentsForm::clearSavedScreen()
+{
+	if (CCDraw::clearSavedScreen()){
+		for(size_t i=0; i<v_cc_items.size(); i++)
+			v_cc_items[i]->clearSavedScreen();
+		return true;
+	}
+
+	return false;
+}
+
+bool CComponentsForm::clearPaintCache()
+{
+	if (CCDraw::clearPaintCache()){
+		for(size_t i=0; i<v_cc_items.size(); i++)
+			v_cc_items[i]->clearPaintCache();
+		return true;
+	}
+
+	return false;
+}
+
+//clean old gradient buffer
+bool CComponentsForm::clearFbGradientData()
+{
+	if (CCDraw::clearFbGradientData()){
+		for(size_t i=0; i<v_cc_items.size(); i++)
+			v_cc_items[i]->clearFbGradientData();
+		return true;
+	}
+
+	return false;
+}
+
+bool CComponentsForm::enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color, const int& direction)
+{
+	if (CCDraw::enableColBodyGradient(enable_mode, sec_color, direction)){
+		for (size_t i= 0; i< v_cc_items.size(); i++)
+			v_cc_items[i]->clearScreenBuffer();
+		return true;
+	}
+	return false;
+}
diff --git a/src/gui/components/cc_frm.h b/src/gui/components/cc_frm.h
index 4736598..52c3d59 100644
--- a/src/gui/components/cc_frm.h
+++ b/src/gui/components/cc_frm.h
@@ -26,7 +26,8 @@
 
 
 #include "config.h"
-#include <gui/components/cc_base.h>
+#include "cc_base.h"
+#include "cc_item.h"
 #include "cc_frm_scrollbar.h"
 
 class CComponentsForm : public CComponentsItem
@@ -55,10 +56,16 @@ class CComponentsForm : public CComponentsItem
 		///enable/disable page scrolling, default enabled with page scroll mode up/down keys, see also enablePageScroll()
 		int page_scroll_mode;
 
+		///initialize basic properties
+		virtual void Init(	const int& x_pos, const int& y_pos, const int& w, const int& h,
+					const fb_pixel_t& color_frame,
+					const fb_pixel_t& color_body,
+					const fb_pixel_t& color_shadow);
+
 	public:
 		CComponentsForm(	const int x_pos = 0, const int y_pos = 0, const int w = 800, const int h = 600,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -66,8 +73,6 @@ class CComponentsForm : public CComponentsItem
 
 		///paints current form on screen, for paint a page use paintPage()
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
-		///hides current form, background will be restored, if parameter = false
-		void hide(bool no_restore = false);
 
 		///same like CComponentsItem::kill(), but erases all embedded items inside of parent at once, this = parent
 		///NOTE: Items always have parent bindings to "this" and use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
@@ -190,6 +195,14 @@ class CComponentsForm : public CComponentsItem
 		};
 		///scroll page and paint current selected page, if parameter2 = true (default)
 		virtual void ScrollPage(int direction = SCROLL_P_DOWN, bool do_paint = true);
+
+		virtual bool enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_colorconst, const int& direction = -1 /*CFrameBuffer::gradientVertical*/);
+		///cleans saved screen buffer include from sub items, required by hide(), returns true if any buffer was deleted
+		virtual bool clearSavedScreen();
+		///cleanup paint cache include from sub items, removes saved buffer contents from cached foreground layers, returns true if any buffer was removed
+		virtual bool clearPaintCache();
+		///cleanup old gradient buffers include from sub items, returns true if any gradient buffer data was removed
+		virtual bool clearFbGradientData();
 };
 
 #endif
diff --git a/src/gui/components/cc_frm_button.cpp b/src/gui/components/cc_frm_button.cpp
index f81450e..ab4b455 100644
--- a/src/gui/components/cc_frm_button.cpp
+++ b/src/gui/components/cc_frm_button.cpp
@@ -40,11 +40,11 @@ CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const
 					CComponentsForm* parent,
 					bool selected,
 					bool enabled,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	cc_btn_capt_locale = NONEXISTANT_LOCALE;
-	initVarButton(x_pos, y_pos, w, h,  caption, icon_name, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow);
+	initVarButton(x_pos, y_pos, w, h,  caption, icon_name, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -52,11 +52,11 @@ CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const
 					CComponentsForm* parent,
 					bool selected,
 					bool enabled,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	cc_btn_capt_locale = caption_locale;
-	initVarButton(x_pos, y_pos, w, h, g_Locale->getText(cc_btn_capt_locale), icon_name, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow);
+	initVarButton(x_pos, y_pos, w, h, g_Locale->getText(cc_btn_capt_locale), icon_name, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -64,11 +64,11 @@ CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const
 					CComponentsForm* parent,
 					bool selected,
 					bool enabled,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	string _icon_name = icon_name == NULL ? "" : string(icon_name);
-	initVarButton(x_pos, y_pos, w, h,  caption, _icon_name, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow);
+	initVarButton(x_pos, y_pos, w, h,  caption, _icon_name, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -76,12 +76,12 @@ CComponentsButton::CComponentsButton( 	const int& x_pos, const int& y_pos, const
 					CComponentsForm* parent,
 					bool selected,
 					bool enabled,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	string _icon_name = icon_name == NULL ? "" : string(icon_name);
 	cc_btn_capt_locale = caption_locale;
-	initVarButton(x_pos, y_pos, w, h,  g_Locale->getText(cc_btn_capt_locale), _icon_name, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow);
+	initVarButton(x_pos, y_pos, w, h,  g_Locale->getText(cc_btn_capt_locale), _icon_name, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 void CComponentsButton::initVarButton(	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -90,7 +90,7 @@ void CComponentsButton::initVarButton(	const int& x_pos, const int& y_pos, const
 					CComponentsForm* parent,
 					bool selected,
 					bool enabled,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	cc_item_type 	= CC_ITEMTYPE_BUTTON;
@@ -99,13 +99,13 @@ void CComponentsButton::initVarButton(	const int& x_pos, const int& y_pos, const
 	y 		= y_pos;
 	width 		= w;
 	height	 	= h;
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 
-	col_body_gradient = false/*g_settings.gradiant*/; //gradient is prepared for use but disabled at the moment till some other parts of gui parts are provide gradient
+	cc_body_gradient_enable = false/*g_settings.gradiant*/; //gradient is prepared for use but disabled at the moment till some other parts of gui parts are provide gradient
 	setColBodyGradient(CColorGradient::gradientLight2Dark, CFrameBuffer::gradientVertical, CColorGradient::light);
 	col_frame 	= color_frame;
-	col_body	= col_body_gradient? COL_DARK_GRAY : color_body;
+	col_body	= cc_body_gradient_enable? COL_DARK_GRAY : color_body;
 	col_shadow	= color_shadow;
 
 	cc_item_enabled  = enabled;
@@ -115,8 +115,8 @@ void CComponentsButton::initVarButton(	const int& x_pos, const int& y_pos, const
 	append_y_offset = 0;
 	corner_rad	= 0;
 	
-	cc_btn_capt_col		= col_body_gradient ? COL_BUTTON_TEXT_ENABLED : COL_INFOBAR_SHADOW_TEXT;
-	cc_btn_capt_disable_col = col_body_gradient ? COL_BUTTON_TEXT_DISABLED : COL_MENUCONTENTINACTIVE_TEXT;
+	cc_btn_capt_col		= cc_body_gradient_enable ? COL_BUTTON_TEXT_ENABLED : COL_INFOBAR_SHADOW_TEXT;
+	cc_btn_capt_disable_col = cc_body_gradient_enable ? COL_BUTTON_TEXT_DISABLED : COL_MENUCONTENTINACTIVE_TEXT;
 	cc_btn_icon_obj	= NULL;
 	cc_btn_capt_obj = NULL;
 	cc_btn_dy_font  = CNeutrinoFonts::getInstance();
@@ -174,7 +174,7 @@ void CComponentsButton::initCaption()
 		if (cc_btn_capt_obj == NULL){
 			cc_btn_capt_obj = new CComponentsLabel();
 			cc_btn_capt_obj->doPaintBg(false);
-			cc_btn_capt_obj->enableTboxSaveScreen(save_tbox_screen);
+			cc_btn_capt_obj->enableTboxSaveScreen(cc_txt_save_screen);
 			addCCItem(cc_btn_capt_obj);
 		}
 	}else{
diff --git a/src/gui/components/cc_frm_button.h b/src/gui/components/cc_frm_button.h
index a60529c..44a688b 100644
--- a/src/gui/components/cc_frm_button.h
+++ b/src/gui/components/cc_frm_button.h
@@ -31,6 +31,7 @@
 #include "cc_frm_chain.h"
 #include "cc_item_picture.h"
 #include "cc_item_text.h"
+#include <gui/widget/icons.h>
 #include <string>
 #include <driver/neutrinofonts.h>
 #include <driver/rcinput.h>
@@ -43,7 +44,7 @@
 /*!
 Shows a button box with caption and optional icon.
 */
-class CComponentsButton : public CComponentsFrmChain
+class CComponentsButton : public CComponentsFrmChain, public CCTextScreen
 {
 	protected:
 		///object: picture object
@@ -58,7 +59,7 @@ class CComponentsButton : public CComponentsFrmChain
 					CComponentsForm* parent,
 					bool selected,
 					bool enabled,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow);
 
 		///property: button text as string, see also setCaption() and getCaptionString()
@@ -101,7 +102,7 @@ class CComponentsButton : public CComponentsFrmChain
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_DARK_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		CComponentsButton(	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -110,7 +111,7 @@ class CComponentsButton : public CComponentsFrmChain
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_DARK_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		CComponentsButton(	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -119,7 +120,7 @@ class CComponentsButton : public CComponentsFrmChain
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_DARK_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		CComponentsButton(	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -128,7 +129,7 @@ class CComponentsButton : public CComponentsFrmChain
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_DARK_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		///set text color
@@ -181,9 +182,9 @@ class CComponentsButtonRed : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_RED, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_RED, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_RED;
 		};
@@ -192,9 +193,9 @@ class CComponentsButtonRed : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_RED, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_RED, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_RED;
 		};
@@ -212,9 +213,9 @@ class CComponentsButtonGreen : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_GREEN, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_GREEN, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_GREEN;
 		};
@@ -223,9 +224,9 @@ class CComponentsButtonGreen : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_GREEN, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_GREEN, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_GREEN;
 		};
@@ -243,9 +244,9 @@ class CComponentsButtonYellow : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_YELLOW, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_YELLOW, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_YELLOW;
 		};
@@ -254,9 +255,9 @@ class CComponentsButtonYellow : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_YELLOW, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_YELLOW, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_YELLOW;
 		};
@@ -274,9 +275,9 @@ class CComponentsButtonBlue : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_BLUE, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption, NEUTRINO_ICON_BUTTON_BLUE, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_BLUE;
 		};
@@ -285,9 +286,9 @@ class CComponentsButtonBlue : public CComponentsButton
 					CComponentsForm *parent = NULL,
 					bool selected = false,
 					bool enabled = true,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_BUTTON_BODY, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_BLUE, parent, selected, enabled, has_shadow, color_frame, color_body, color_shadow)
+					:CComponentsButton(x_pos, y_pos, w, h, caption_locale, NEUTRINO_ICON_BUTTON_BLUE, parent, selected, enabled, shadow_mode, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_BUTTON_BLUE;
 		};
diff --git a/src/gui/components/cc_frm_chain.cpp b/src/gui/components/cc_frm_chain.cpp
index b3f8b98..c6e666f 100644
--- a/src/gui/components/cc_frm_chain.cpp
+++ b/src/gui/components/cc_frm_chain.cpp
@@ -33,12 +33,12 @@ CComponentsFrmChain::CComponentsFrmChain(	const int& x_pos, const int& y_pos, co
 						const std::vector<CComponentsItem*> *v_items,
 						int direction,
 						CComponentsForm* parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t& color_frame,
 						fb_pixel_t& color_body,
 						fb_pixel_t& color_shadow)
 {
-	initVarChain(x_pos, y_pos, w, h, v_items, direction, parent, has_shadow, color_frame, color_body, color_shadow);
+	initVarChain(x_pos, y_pos, w, h, v_items, direction, parent, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 
@@ -46,7 +46,7 @@ void CComponentsFrmChain::initVarChain(	const int& x_pos, const int& y_pos, cons
 					const std::vector<CComponentsItem*> *v_items,
 					int direction,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t& color_frame,
 					fb_pixel_t& color_body,
 					fb_pixel_t& color_shadow)
@@ -59,7 +59,7 @@ void CComponentsFrmChain::initVarChain(	const int& x_pos, const int& y_pos, cons
 	width 		= w;
 	height 		= h;
 
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	col_frame	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
diff --git a/src/gui/components/cc_frm_chain.h b/src/gui/components/cc_frm_chain.h
index 2ce8b7e..2a13a14 100644
--- a/src/gui/components/cc_frm_chain.h
+++ b/src/gui/components/cc_frm_chain.h
@@ -51,7 +51,7 @@ class CComponentsFrmChain : public CComponentsForm
 					const std::vector<CComponentsItem*> *v_items,
 					int direction,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t& color_frame,
 					fb_pixel_t& color_body,
 					fb_pixel_t& color_shadow);
@@ -66,7 +66,7 @@ class CComponentsFrmChain : public CComponentsForm
 					const std::vector<CComponentsItem*> *v_items = NULL,
 					int direction = CC_DIR_X,
 					CComponentsForm* parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t& color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t& color_body = COL_MENUHEAD_PLUS_0,
 					fb_pixel_t& color_shadow = COL_MENUCONTENTDARK_PLUS_0);
diff --git a/src/gui/components/cc_frm_clock.cpp b/src/gui/components/cc_frm_clock.cpp
index 1db2ac0..313b05c 100644
--- a/src/gui/components/cc_frm_clock.cpp
+++ b/src/gui/components/cc_frm_clock.cpp
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Generic GUI-related component.
-	Copyright (C) 2013, 2014 Thilo Graf 'dbt'
+	Copyright (C) 2013-2015 Thilo Graf 'dbt'
 
 	License: GPL
 
@@ -27,69 +27,91 @@
 
 #include <global.h>
 #include <neutrino.h>
-#include <driver/neutrinofonts.h>
 
 #include "cc_frm_clock.h"
 #include <time.h>
-#include <pthread.h>
+
 #include <unistd.h>
 #include <errno.h>
 #include <ctype.h>
 #include <system/helpers.h>
+#include <system/debug.h>
 
 using namespace std;
 
-
-CComponentsFrmClock::CComponentsFrmClock( 	const int& x_pos, const int& y_pos, const int& w, const int& h,
-						const char* format_str,
+CComponentsFrmClock::CComponentsFrmClock( 	const int& x_pos,
+						const int& y_pos,
+						Font * font,
+						const char* prformat_str,
+						const char* secformat_str,
 						bool activ,
+						const int& interval_seconds,
 						CComponentsForm* parent,
-						bool has_shadow,
-						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
+						int shadow_mode,
+						fb_pixel_t color_frame,
+						fb_pixel_t color_body,
+						fb_pixel_t color_shadow,
+						int font_style
+					)
 
 {
+	cc_item_type 	= CC_ITEMTYPE_FRM_CLOCK;
+
 	x 		= x_pos;
 	y 		= y_pos;
-	width 		= w;
-	height	 	= h;
-	shadow		= has_shadow;
+
+	shadow		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
 
-	cc_item_type 		= CC_ITEMTYPE_FRM_CLOCK;
-	corner_rad		= RADIUS_SMALL;
-
-	cl_font_type		= SNeutrinoSettings::FONT_TYPE_INFOBAR_INFO;
-	cl_font 		= &g_Font[cl_font_type];
-	dyn_font_size		= 0;
+	corner_rad	= RADIUS_SMALL;
 
-	cl_col_text		= COL_MENUCONTENT_TEXT;
-	cl_format_str		= format_str;
-	cl_align		= CC_ALIGN_VER_CENTER | CC_ALIGN_HOR_CENTER;
+	//init default format and  text color
+	setClockFormat(prformat_str, secformat_str);
+	cl_col_text	= COL_MENUCONTENT_TEXT;
 
-	cl_thread 		= 0;
-	cl_interval		= 1;
+	//init default font
+	cl_font 	= font;
+	cl_font_style	= font_style;
+	if (cl_font == NULL){
+		int dx = 0;
+		int dy = 30;
+		setClockFont(*CNeutrinoFonts::getInstance()->getDynFont(dx, dy, cl_format_str, cl_font_style));
+	}
 
-	activeClock		= true;
-	cl_blink_str		= format_str;
-	paintClock		= false;
+	//init general clock dimensions
+	height 		= cl_font->getHeight();
+	width 		= cl_font->getRenderWidth(cl_format_str);
 
-	activeClock		= activ;
+	//set default text background behavior
+	cc_txt_save_screen = false;
 
+	//set default running clock properties
+	cl_interval	= interval_seconds;
+	cl_timer 	= NULL;
+	paintClock	= false;
+#if 0
 	may_blit		= true;
+#endif
 
+	//general init
 	initCCLockItems();
 	initParent(parent);
 
-	if (activeClock)
-		startThread();
+	//init slot for running clock
+	cl_sl = sigc::mem_fun0(*this, &CComponentsFrmClock::ShowTime);
+
+	//run clock already if required
+	if (activ)
+		startClock();
 }
 
 CComponentsFrmClock::~CComponentsFrmClock()
 {
-	stopThread();
+	if (cl_timer)
+		delete cl_timer;
 }
 
 
@@ -97,8 +119,34 @@ void CComponentsFrmClock::initTimeString()
 {
 	struct tm t;
 	time_t ltime;
-	ltime=time(NULL);
-	strftime(cl_timestr, sizeof(cl_timestr), getTimeFormat(ltime), localtime_r(&ltime, &t));
+	ltime=time(&ltime);
+
+	toggleFormat();
+
+	strftime(cl_timestr, sizeof(cl_timestr), cl_format.c_str(), localtime_r(&ltime, &t));
+}
+
+//formating time string with possible blink string
+void CComponentsFrmClock::toggleFormat()
+{
+	if (cl_format_str.length() != cl_blink_str.length())
+		kill();
+
+	if (cl_format == cl_blink_str)
+		cl_format = cl_format_str;
+	else
+		cl_format = cl_blink_str;
+}
+
+//set current time format string
+void CComponentsFrmClock::setClockFormat(const char* prformat_str, const char* secformat_str)
+{
+	cl_format_str = prformat_str;
+
+	if (secformat_str == NULL)
+		cl_blink_str = cl_format_str;
+	else
+		cl_blink_str = secformat_str;
 }
 
 // How does it works?
@@ -117,23 +165,20 @@ void CComponentsFrmClock::initTimeString()
 
 void CComponentsFrmClock::initCCLockItems()
 {
+	//prepare and set current time string
 	initTimeString();
 	string s_time = cl_timestr;
-	
-	//get minimal required height, width from raw text
-	int min_text_w = (*getClockFont())->getRenderWidth(s_time);
-	int min_text_h = (*getClockFont())->getHeight();
-	height = max(height, min_text_h);
-	width = max(width, min_text_w);
-
-	int cl_x = 0;
-	int cl_h = min_text_h;
-	int cl_y = 0;
-	int w_lbl_tmp = 0;
-	
-	//create label objects and add to container, ensure count of items = count of chars (one char = one segment)
-	if (v_cc_items.size() != s_time.size()){
-		
+
+	/* create label objects and add to container, ensure that count of items = count of chars (one char = one segment)
+	 * this is required for the case, if any time string format was changed
+	*/
+	if (v_cc_items.empty() || (v_cc_items.size() != s_time.size())){
+		//exit on empty time string
+		if (s_time.empty()){
+			clear();
+			return;
+		}
+
 		//clean up possible old items before add new items
 		clear();
 
@@ -141,10 +186,10 @@ void CComponentsFrmClock::initCCLockItems()
 		for (size_t i = 0; i < s_time.size(); i++){
 			CComponentsLabel * lbl = new CComponentsLabel();
 			addCCItem(lbl);
-			
+
 			//background paint of item is not required
 			lbl->doPaintBg(false);
-			
+
 			//set corner properties of label item
 			lbl->setCorner(corner_rad-fr_thickness, corner_type);
 
@@ -152,14 +197,31 @@ void CComponentsFrmClock::initCCLockItems()
 			lbl->setTextBorderWidth(0,0);
 		}
 	}
-	
-	//calculate minimal separator width, we use char size of some possible chars
+
+	/*calculate minimal separator width, we use char size of some possible chars
+	 * TODO: it's not really generic at the moment
+	*/
 	int minSepWidth = 0;
 	string sep[] ={" ", ".", ":"};
 	for (size_t i = 0; i < sizeof(sep)/sizeof(sep[0]); i++)
-		minSepWidth = max((*getClockFont())->getRenderWidth(sep[i]), minSepWidth);
+		minSepWidth = max(cl_font->getRenderWidth(sep[i]), minSepWidth);
+
+	//get minimal required dimensions for segements from current format string
+	int w_text_min = max(cl_font->getRenderWidth(s_time), width);
+	int h_text_min = max(cl_font->getHeight(), height);
+
+	//init some temporary variables
+	int x_tmp = x;
+	int h_tmp = h_text_min;
+	int y_tmp = y;
 
-	//modify available label items with current segment chars
+	//summary of all segments (labels)
+	int w_segments = 0;
+
+	/* modify available label items with current segment chars
+	 * we are using segments with only one char per segment,
+	 * these chars are predefined via format string
+	*/
 	for (size_t i = 0; i < v_cc_items.size(); i++)
 	{
 		//v_cc_items are only available as CComponent-items here, so we must cast them before
@@ -178,21 +240,26 @@ void CComponentsFrmClock::initCCLockItems()
 		//extract timestring segment (char)
 		string stmp = s_time.substr(i, 1);
 
+		int w_tmp = minSepWidth;
 		//get width of current segment
-		int wtmp = 0;
 		if (isdigit(stmp.at(0)) ) //check for digits, if true, we use digit width
-			wtmp = (*getClockFont())->getMaxDigitWidth();
+			w_tmp = cl_font->getMaxDigitWidth();
 		else //not digit found, we use render width or minimal width
-			wtmp = max((*getClockFont())->getRenderWidth(stmp), minSepWidth);
+			w_tmp = max(cl_font->getRenderWidth(stmp), minSepWidth);
+		//lbl->enablePaintCache();
 
 		//set size, text, color of current item
-		lbl->setDimensionsAll(cl_x, cl_y, wtmp, cl_h);
-		lbl->setTextColor(cl_col_text);
+		lbl->setDimensionsAll(x_tmp, y_tmp, w_tmp, h_tmp);
 		lbl->setColorAll(col_frame, col_body, col_shadow);
-		lbl->setText(stmp, CTextBox::CENTER, *getClockFont());
+		lbl->forceTextPaint(false);
+		lbl->setText(stmp, CTextBox::CENTER, cl_font, cl_col_text, cl_font_style);
 
+		//init background behavior of segment
+		//printf("[CComponentsFrmClock]   [%s - %d] paint_bg: [%d] gradient_mode = [%d], text save screen mode = [%d]\n", __func__, __LINE__, paint_bg, cc_body_gradient_enable, cc_txt_save_screen);
+		lbl->doPaintBg(false);
 		lbl->doPaintTextBoxBg(paint_bg);
-		lbl->enableTboxSaveScreen(save_tbox_screen);
+		bool save_txt_screen = cc_txt_save_screen || (!paint_bg || cc_body_gradient_enable);
+		lbl->enableTboxSaveScreen(save_txt_screen);
 
 		//use matching height for digits for better vertical centerring into form
 		CTextBox* ctb = lbl->getCTextBoxObject();
@@ -203,140 +270,99 @@ void CComponentsFrmClock::initCCLockItems()
 		bool force_txt_and_bg = (lbl->textChanged() || this->paint_bg);
 		lbl->forceTextPaint(force_txt_and_bg);
 #endif
-		//set xpos of item
-		cl_x += wtmp;
-
-		lbl->setWidth(wtmp);
-
-		//set current width for form
-		w_lbl_tmp += wtmp;
+		//set xpos and width of item (segment)
+		lbl->setWidth(w_tmp);
+		x_tmp += w_tmp;
+
+		//sum required width for clock (this)
+		w_segments += w_tmp;
+		h_text_min = max(lbl->getHeight(), height);
+		height = max(lbl->getHeight(), height);
 	}
 
-	//set required width
-	width = max(width, w_lbl_tmp);
-
-	initSegmentAlign(&w_lbl_tmp, &min_text_h);
-}
-
-//handle alignment
-void CComponentsFrmClock::initSegmentAlign(int* segment_width, int* segment_height)
-{	
-	int wadd = 0;
-	int hadd = 0;
-	int* w_lbl_tmp = segment_width;
-	int* min_text_h = segment_height;
+	//set required width for clock (this)
+	width = max(w_text_min, w_segments);
 
 	//use first item as reference and set x and y position to the 1st segement item with definied alignment
-	if (cl_align & CC_ALIGN_RIGHT){
-		wadd = width-*w_lbl_tmp;
-		v_cc_items[0]->setXPos(wadd);
-	}
-	else if (cl_align & CC_ALIGN_LEFT){
-		v_cc_items[0]->setXPos(wadd);
-	}
-	else if  (cl_align & CC_ALIGN_HOR_CENTER){
-		hadd = height/2-*min_text_h/2;
-		v_cc_items[0]->setYPos(hadd);
-	}
+	int x_lbl = width/2-w_segments/2;
+	v_cc_items[0]->setXPos(x_lbl);
 
-	if (cl_align & CC_ALIGN_TOP){
-		v_cc_items[0]->setYPos(hadd);
-	}
-	else if  (cl_align & CC_ALIGN_BOTTOM){
-		hadd = height-*min_text_h;
-		v_cc_items[0]->setYPos(hadd);
-	}
-	else if  (cl_align & CC_ALIGN_VER_CENTER){
-		wadd = width/2-*w_lbl_tmp/2;
-		v_cc_items[0]->setXPos(wadd);
-	}
+	int y_lbl = height/2-h_text_min/2;
+	v_cc_items[0]->setYPos(y_lbl);
 
 	//set all evaluated position values to all other segement items
 	for (size_t i = 1; i < v_cc_items.size(); i++){
-		wadd += v_cc_items[i-1]->getWidth();
-		v_cc_items[i]->setPos(wadd, hadd);
+		x_lbl += v_cc_items[i-1]->getWidth();
+		v_cc_items[i]->setPos(x_lbl, y_lbl);
 	}
 }
 
-//thread handle
-void* CComponentsFrmClock::initClockThread(void *arg)
+
+//this member is provided for slot with timer event "OnTimer"
+void CComponentsFrmClock::ShowTime()
 {
-	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,0);
- 	pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS,0);
-
-	CComponentsFrmClock *clock = static_cast<CComponentsFrmClock*>(arg);
-	//start loop for paint
-	while (true) {
-		clock->mutex.lock();
-		if (clock->paintClock)
-			clock->paint(CC_SAVE_SCREEN_NO);
-		clock->mutex.unlock();
-		int interval = clock->cl_interval;
-		mySleep(interval);
+	if (paintClock) {
+		//paint segements, but wihtout saved backgrounds
+		paint(CC_SAVE_SCREEN_NO);
 	}
-	return 0;
 }
 
-//start up ticking clock with own thread, return true on succses
-bool CComponentsFrmClock::startThread()
+//start up ticking clock controled by timer with signal/slot, return true on succses
+bool CComponentsFrmClock::startClock()
 {
-	void *ptr = static_cast<void*>(this);
-	
-	if(!cl_thread) {
-		int res = pthread_create (&cl_thread, NULL, initClockThread, ptr) ;
-		if (res != 0){
-			printf("[CComponentsFrmClock]    [%s]  pthread_create  %s\n", __func__, strerror(errno));
-			return false;
-		}
-		pthread_detach(cl_thread);
+	if (cl_interval <= 0){
+		dprintf(DEBUG_NORMAL, "[CComponentsFrmClock]    [%s]  clock is set to active, but interval is initialized with value %d ...\n", __func__, cl_interval);
+		return false;
 	}
-	return  true;
+
+	if (cl_timer == NULL){
+		cl_timer = new CComponentsTimer();
+		dprintf(DEBUG_INFO, "[CComponentsFrmClock]    [%s]  init slot...\n", __func__);
+		cl_timer->OnTimer.connect(cl_sl);
+	}
+	cl_timer->setTimerIntervall(cl_interval);
+
+	if (cl_timer->isRun())
+		return true;
+	
+	return  false;
 }
 
-//stop ticking clock and kill thread, return true on succses
-bool CComponentsFrmClock::stopThread()
+//stop ticking clock and internal timer, return true on succses
+bool CComponentsFrmClock::stopClock()
 {
-	if(cl_thread) {
-		int res = pthread_cancel(cl_thread);
-		if (res != 0){
-			printf("[CComponentsFrmClock]    [%s] pthread_cancel  %s\n", __func__, strerror(errno));
-			return false;
-		}
-#if 0
-		res = pthread_join(cl_thread, NULL);
-		if (res != 0){
-			printf("[CComponentsFrmClock]    [%s] pthread_join  %s\n", __func__, strerror(errno));
-			return false;
+	if (cl_timer){
+		if (cl_timer->stopTimer()){
+			dprintf(DEBUG_INFO, "[CComponentsFrmClock]    [%s]  stopping clock...\n", __func__);
+			delete cl_timer;
+			cl_timer = NULL;
+			return true;
 		}
-#endif
+		else
+			dprintf(DEBUG_NORMAL, "[CComponentsFrmClock]    [%s]  stopping timer failed...\n", __func__);
 	}
-	hide();
-	cl_thread = 0;
-	return true;
+	return false;
 }
 
 bool CComponentsFrmClock::Start(bool do_save_bg)
 {
-	if (!activeClock)
-		return false;
-	if (!cl_thread)
-		startThread();
-	if (cl_thread) {
+	if (startClock()) {
 		//ensure paint of segements on first paint
 		paint(do_save_bg);
 		paintClock = true;
+		return true;
 	}
-	return cl_thread == 0 ? false : true;
+	return false;
 }
 
 bool CComponentsFrmClock::Stop()
 {
-	if (!activeClock)
-		return false;
-	mutex.lock();
-	paintClock = false;
-	mutex.unlock();
-	return cl_thread == 0 ? false : true;
+	if (stopClock()){
+		paintClock = false;
+		return true;
+	}
+
+	return false;
 }
 
 void CComponentsFrmClock::paint(bool do_save_bg)
@@ -345,38 +371,85 @@ void CComponentsFrmClock::paint(bool do_save_bg)
 	initCCLockItems();
 
 	//paint form contents
-	paintForm(do_save_bg);
-
+	CComponentsForm::paint(do_save_bg);
+#if 0 //has no effect
 	if (may_blit)
 		frameBuffer->blit();
+#endif
 }
 
-void CComponentsFrmClock::setClockFontSize(int font_size)
+void CComponentsFrmClock::setClockFont(Font *font, const int& style)
 {
-	int tmp_w = 0;
-	dyn_font_size = font_size;
-	cl_font	= CNeutrinoFonts::getInstance()->getDynFont(tmp_w, dyn_font_size, "", CNeutrinoFonts::FONT_STYLE_BOLD, CNeutrinoFonts::FONT_ID_INFOCLOCK);
+	if (cl_font != font)
+		cl_font = font;
+
+	if (style != -1)
+		cl_font_style = style;
+
+// 	setHeight(cl_font->getHeight());
+// 	setWidth(cl_font->getRenderWidth(cl_format_str));
+	initCCLockItems();
 }
 
-void CComponentsFrmClock::setClockFont(int font)
+Font* CComponentsFrmClock::getClockFont()
 {
-	cl_font_type = font;
-	cl_font      = &g_Font[cl_font_type];
+	return cl_font;
 }
 
-Font** CComponentsFrmClock::getClockFont()
+void CComponentsFrmClock::kill(const fb_pixel_t& bg_color, bool ignore_parent)
 {
-	if (dyn_font_size == 0)
-		cl_font = &g_Font[cl_font_type];
-	return cl_font;
+	Stop();
+	CComponentsForm::kill(bg_color, ignore_parent);
+}
+
+void CComponentsFrmClock::enableSegmentSaveScreen(bool mode)
+{
+	if (cc_txt_save_screen == mode || v_cc_items.empty())
+		return;
 
+	cc_txt_save_screen = mode;
+
+	for (size_t i = 0; i < v_cc_items.size(); i++){
+		CComponentsLabel *seg = static_cast <CComponentsLabel*>(v_cc_items[i]);
+		//seg->clearSavedScreen();
+		seg->enableTboxSaveScreen(cc_txt_save_screen);
+	}
 }
 
-void CComponentsFrmClock::setClockActiv(bool activ/* = true*/)
+void CComponentsFrmClock::setHeight(const int& h)
 {
-	activeClock = activ;
-	if (activ && !cl_thread)
-		startThread();
-	if (!activ && cl_thread)
-		stopThread();
+	if (h == height)
+		return;
+
+	int f_height = cl_font->getHeight();
+	if (h != f_height){
+		dprintf(DEBUG_NORMAL, "\033[33m[CComponentsFrmClock]\t[%s - %d], font height is different than current height [%d], using [%d]  ...\033[0m\n", __func__, __LINE__, h, f_height);
+		CCDraw::setHeight(f_height);
+	}else
+		CCDraw::setHeight(h);
+	initCCLockItems();
+}
+
+void CComponentsFrmClock::setWidth(const int& w)
+{
+	if (w == width)
+		return;
+
+	int f_width = cl_font->getRenderWidth(cl_format_str);
+	if (w != f_width){
+		dprintf(DEBUG_NORMAL, "\033[33m[CComponentsFrmClock]\t[%s - %d], font width is different than current width [%d], using [%d]  ...\033[0m\n", __func__, __LINE__, w, f_width);
+		CCDraw::setWidth(f_width);
+	}else
+		CCDraw::setWidth(w);
+	initCCLockItems();
+}
+
+bool CComponentsFrmClock::enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color)
+{
+	if (CCDraw::enableColBodyGradient(enable_mode, sec_color)){
+		for (size_t i = 0; i < v_cc_items.size(); i++)
+			static_cast <CComponentsLabel*>(v_cc_items[i])->getCTextBoxObject()->clearScreenBuffer();
+		return true;
+	}
+	return false;
 }
diff --git a/src/gui/components/cc_frm_clock.h b/src/gui/components/cc_frm_clock.h
index 64e6a63..6b91c83 100644
--- a/src/gui/components/cc_frm_clock.h
+++ b/src/gui/components/cc_frm_clock.h
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012, 2013, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
 
 	License: GPL
 
@@ -31,120 +31,142 @@
 #include <config.h>
 #endif
 
-#include <OpenThreads/ScopedLock>
-#include <OpenThreads/Thread>
-#include <OpenThreads/Condition>
-
+#include <driver/neutrinofonts.h>
 #include "cc_base.h"
 #include "cc_frm.h"
-
-
+#include "cc_timer.h"
+#include "cc_text_screen.h"
 //! Sub class of CComponents. Show clock with digits on screen. 
 /*!
 Usable as simple fixed display or as ticking clock.
 */
 
-class CComponentsFrmClock : public CComponentsForm
+class CComponentsFrmClock : public CComponentsForm, public CCTextScreen
 {
 	private:
-		
-// 		bool cl_force_segment_paint;
+		CComponentsTimer *cl_timer;
+		void ShowTime();
+#if 0
 		bool may_blit;
-	
+#endif
+
 	protected:
-		///thread
-		pthread_t  cl_thread;
+		///slot for timer event, reserved for ShowTime()
+		sigc::slot0<void> cl_sl;
+
 		///refresh interval in seconds
 		int cl_interval;
-		///init function to start clock in own thread
-		static void* initClockThread(void *arg);
 
 		///raw time chars
 		char cl_timestr[20];
 
 		///handle paint clock within thread and is not similar to cc_allow_paint
 		bool paintClock;
-		//TODO: please add comments!
-		bool activeClock;
 
 		///object: font render object
-		Font **cl_font;
-
-		int cl_font_type;
-		int dyn_font_size;
+		Font *cl_font;
+		int cl_font_style;
 
 		///text color
 		int cl_col_text;
-		///time format
-		const char *cl_format_str;
-		///time format for blink
-		const char *cl_blink_str;
-		///time string align, default align is ver and hor centered
-		int cl_align;
+
+		///current time format
+		std::string cl_format;
+		///primary time format
+		std::string cl_format_str;
+		///secondary time format for blink
+		std::string cl_blink_str;
 
 		///initialize clock contents  
 		void initCCLockItems();
 		///initialize timestring, called in initCCLockItems()
 		virtual void initTimeString();
-		///initialize of general alignment of timestring segments within form area
-		void initSegmentAlign(int* segment_width, int* segment_height);
-		//return current time string format
-		const char *getTimeFormat(time_t when) { return (when & 1) ? cl_format_str : cl_blink_str; }
+
+		///start ticking clock, returns true on success, if false causes log output
+		bool startClock();
+		///stop ticking clock, returns true on success, if false causes log output
+		bool stopClock();
+		///switch between primary and secondary format
+		void toggleFormat();
 
 		///return pointer of font object
-		inline Font** getClockFont();
+		Font* getClockFont();
 
 	public:
-		OpenThreads::Mutex mutex;
 
-		CComponentsFrmClock( 	const int& x_pos = 1, const int& y_pos = 1, const int& w = 200, const int& h = 48,
+		CComponentsFrmClock( 	const int& x_pos = 1, const int& y_pos = 1,
+					Font * font = NULL,
 					const char* format_str = "%H:%M",
+					const char* secformat_str = NULL,
 					bool activ=false,
+					const int& interval_seconds = 1,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
-					fb_pixel_t color_frame = COL_LIGHT_GRAY, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
+					int shadow_mode = CC_SHADOW_OFF,
+					fb_pixel_t color_frame = COL_LIGHT_GRAY,
+					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
+					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
+					int font_style = CNeutrinoFonts::FONT_STYLE_BOLD
+				);
 		virtual ~CComponentsFrmClock();
 
-		///set font type or font size for segments
-		virtual void setClockFont(int font);
-		virtual void setClockFontSize(int font_size);
+		/*! Sets font type for clock segments.
+		 * 1st parameter expects a pointer to font type, usually a type from the global g_Font collection, but also possible
+		 * are dynamic font.
+		 * The use of NULL pointer enforces dynamic font.
+		 * 2nd paramter is relevant for dynamic fonts only, you can use the enum types
+		 * - FONT_STYLE_REGULAR
+		 * - FONT_STYLE_BOLD
+		 * - FONT_STYLE_ITALIC
+		 * (see /.src/driver/neutrinofonts.h)
+		*/
+		void setClockFont(Font * font, const int& style = -1);
 
 		///set text color
-		virtual void setTextColor(fb_pixel_t color_text){ cl_col_text = color_text;};
+		virtual void setTextColor(fb_pixel_t color_text){ cl_col_text = color_text;}
 
-		///set alignment of timestring, possible modes see align types in cc_types.h 
-		virtual void setClockAlignment(int align_type){cl_align = align_type;};
+		///set height of clock on screen
+		virtual void setHeight(const int& h);
+		///set width of clock on screen
+		virtual void setWidth(const int& w);
 
 		///use string expession: "%H:%M" = 12:22, "%H:%M:%S" = 12:22:12
-		virtual void setClockFormat(const char* format_str){cl_format_str = format_str;};
-
-		///time format for blink ("%H %M", "%H:%M %S" etc.)
-		virtual void setClockBlink(const char* format_str){cl_blink_str = format_str;};
-
-		///start ticking clock thread, returns true on success, if false causes log output
-		virtual bool startThread();
-		///stop ticking clock thread, returns true on success, if false causes log output
-		virtual bool stopThread();
+		///set current time format string, 1st parameter set the default format, 2nd parameter sets an alternatively format for use as blink effect
+		virtual void setClockFormat(const char* prformat_str, const char* secformat_str = NULL);
 
+		///start and paint ticking clock
 		virtual bool Start(bool do_save_bg = CC_SAVE_SCREEN_NO);
+		///same like Start() but for usage as simple call without return value
+		virtual void unblock(/*bool do_save_bg = CC_SAVE_SCREEN_NO*/){Start(cc_save_bg);}
+		///stop ticking clock, but don't hide, use kill() or hide() to remove from screen
 		virtual bool Stop();
+		///same like Stop() but for usage as simple call without return value
+		virtual void block(){Stop();}
+		///return true on blocked status, blocked means clock can be initalized but would be not paint, to unblock use unblock()
+		virtual bool isBlocked(void) {return !paintClock;}
 
-		///returns true, if clock is running in thread
-		virtual bool isClockRun() const {return cl_thread == 0 ? false:true;};
+		///returns true, if clock is running
+		virtual bool isRun() const {return cl_timer ? true : false;};
 		///set refresh interval in seconds, default value=1 (=1 sec)
 		virtual void setClockIntervall(const int& seconds){cl_interval = seconds;};
 
 		///show clock on screen
 		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
+		///hide clock on screen
+		virtual void hide(){Stop(); CComponentsForm::hide();}
+		///does the same like kill() from base class, but stopping clock before kill
+		void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, bool ignore_parent = false);
 
 		///reinitialize clock contents
 		virtual void refresh() { initCCLockItems(); }
+		///allows to save bg screen behind text within segment objects, see also cl_save_segment_screen
+		void enableSegmentSaveScreen(bool mode);
 
-		///set clock activ/inactiv
-		virtual void setClockActiv(bool activ = true);
-
+		///set color gradient on/off, returns true if gradient mode was changed
+		virtual bool enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/);
+#if 0
 		///enable/disable automatic blitting
 		void setBlit(bool _may_blit = true) { may_blit = _may_blit; }
+#endif
 };
 
 #endif
diff --git a/src/gui/components/cc_frm_ext_text.cpp b/src/gui/components/cc_frm_ext_text.cpp
index 49b0613..5d24e7d 100644
--- a/src/gui/components/cc_frm_ext_text.cpp
+++ b/src/gui/components/cc_frm_ext_text.cpp
@@ -37,32 +37,32 @@ using namespace std;
 CComponentsExtTextForm::CComponentsExtTextForm(	const int& x_pos, const int& y_pos, const int& w, const int& h,
 						const std::string& label_text, const std::string& text,
 						CComponentsForm* parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t label_color,
 						fb_pixel_t text_color,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
-	initVarExtTextForm(x_pos, y_pos, w, h, label_text, text, parent, has_shadow, label_color, text_color, color_frame, color_body, color_shadow);
+	initVarExtTextForm(x_pos, y_pos, w, h, label_text, text, parent, shadow_mode, label_color, text_color, color_frame, color_body, color_shadow);
 	initCCTextItems();
 }
 
 CComponentsExtTextFormLocalized::CComponentsExtTextFormLocalized(const int& x_pos, const int& y_pos, const int& w, const int& h,
 								const neutrino_locale_t& locale_label_text, const neutrino_locale_t& locale_text,
 								CComponentsForm* parent,
-								bool has_shadow,
+								int shadow_mode,
 								fb_pixel_t label_color,
 								fb_pixel_t text_color,
 								fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 								: CComponentsExtTextForm(	x_pos, y_pos, w, h,
 												g_Locale->getText(locale_label_text), g_Locale->getText(locale_text),
 												parent,
-												has_shadow,
+												shadow_mode,
 												label_color, text_color, color_frame, color_body, color_shadow){};
 
 void CComponentsExtTextForm::initVarExtTextForm(const int& x_pos, const int& y_pos, const int& w, const int& h,
 						const std::string& label_text, const std::string& text,
 						CComponentsForm* parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t label_color,
 						fb_pixel_t text_color,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
@@ -82,7 +82,7 @@ void CComponentsExtTextForm::initVarExtTextForm(const int& x_pos, const int& y_p
 	
 	ccx_label_text 	= label_text;
 	ccx_text 	= text;
-	shadow 		= has_shadow;
+	shadow 		= shadow_mode;
 	ccx_label_color	= label_color;
 	ccx_text_color	= text_color;
 	col_frame	= color_frame;
@@ -105,7 +105,7 @@ void CComponentsExtTextForm::initLabel()
 	if (ccx_label_obj == NULL){
 		ccx_label_obj = new CComponentsLabel();
 		ccx_label_obj->doPaintBg(false);
-		ccx_label_obj->enableTboxSaveScreen(save_tbox_screen);
+		ccx_label_obj->enableTboxSaveScreen(cc_txt_save_screen);
 	}	
 
 	//add label object
@@ -128,7 +128,7 @@ void CComponentsExtTextForm::initText()
 	if (ccx_text_obj == NULL){
 		ccx_text_obj = new CComponentsText();
 		ccx_text_obj->doPaintBg(false);
-		ccx_text_obj->enableTboxSaveScreen(save_tbox_screen);
+		ccx_text_obj->enableTboxSaveScreen(cc_txt_save_screen);
 	}
 
 	//add text object
@@ -161,12 +161,12 @@ void CComponentsExtTextForm::setLabelAndText(const neutrino_locale_t& locale_lab
 	setLabelAndText(g_Locale->getText(locale_label_text), g_Locale->getText(locale_text), font_text);
 }
 
-void CComponentsExtTextForm::setLabelAndTexts(const string_ext_txt_t& texts)
+void CComponentsExtTextForm::setLabelAndTexts(const cc_string_ext_txt_t& texts)
 {
 	setLabelAndText(texts.label_text, texts.text, texts.font);
 }
 
-void CComponentsExtTextForm::setLabelAndTexts(const locale_ext_txt_t& locale_texts)
+void CComponentsExtTextForm::setLabelAndTexts(const cc_locale_ext_txt_t& locale_texts)
 {
 	setLabelAndText(g_Locale->getText(locale_texts.label_text), g_Locale->getText(locale_texts.text), locale_texts.font);
 }
diff --git a/src/gui/components/cc_frm_ext_text.h b/src/gui/components/cc_frm_ext_text.h
index 66a2172..007680d 100644
--- a/src/gui/components/cc_frm_ext_text.h
+++ b/src/gui/components/cc_frm_ext_text.h
@@ -28,7 +28,7 @@
 #include "cc_item_text.h"
 
 
-class CComponentsExtTextForm : public CComponentsForm
+class CComponentsExtTextForm : public CComponentsForm, public CCTextScreen
 {
 	private:
 		///property: content of label, see also setLabelAndText()
@@ -69,7 +69,7 @@ class CComponentsExtTextForm : public CComponentsForm
 		void initVarExtTextForm(const int& x_pos, const int& y_pos, const int& w, const int& h,
 					const std::string& label_text, const std::string& text,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t label_color,
 					fb_pixel_t text_color,
 					fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow);
@@ -79,7 +79,7 @@ class CComponentsExtTextForm : public CComponentsForm
 		CComponentsExtTextForm(	const int& x_pos = 1, const int& y_pos = 1, const int& w = 300, const int& h = 48,
 					const std::string& label_text = "", const std::string& text = "",
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t label_color = COL_MENUCONTENTINACTIVE_TEXT,
 					fb_pixel_t text_color = COL_MENUCONTENT_TEXT,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
@@ -94,10 +94,10 @@ class CComponentsExtTextForm : public CComponentsForm
 		///assigns text Font type
 		void setLabelAndTextFont(Font* font);
 
-		///assigns texts for label and text, parameter as struct (locale_ext_txt_t), parameters provide the same properties like setLabelAndText()
-		void setLabelAndTexts(const locale_ext_txt_t& texts);
-		///assigns texts for label and text, parameter as struct (string_ext_txt_t), parameters provide the same properties like setLabelAndText()
-		void setLabelAndTexts(const string_ext_txt_t& locale_texts);
+		///assigns texts for label and text, parameter as struct (cc_locale_ext_txt_t), parameters provide the same properties like setLabelAndText()
+		void setLabelAndTexts(const cc_locale_ext_txt_t& texts);
+		///assigns texts for label and text, parameter as struct (cc_string_ext_txt_t), parameters provide the same properties like setLabelAndText()
+		void setLabelAndTexts(const cc_string_ext_txt_t& locale_texts);
 
 		///assigns colors for text for label text, parameter as fb_pixel_t
 		void setLabelAndTextColor(const fb_pixel_t label_color , const fb_pixel_t text_color);
@@ -124,7 +124,7 @@ class CComponentsExtTextFormLocalized : public CComponentsExtTextForm
 		CComponentsExtTextFormLocalized(const int& x_pos = 1, const int& y_pos = 1, const int& w = 300, const int& h = 48,
 						const neutrino_locale_t& locale_label_text = NONEXISTANT_LOCALE, const neutrino_locale_t& locale_text = NONEXISTANT_LOCALE,
 						CComponentsForm *parent = NULL,
-						bool has_shadow = CC_SHADOW_OFF,
+						int shadow_mode = CC_SHADOW_OFF,
 						fb_pixel_t label_color = COL_MENUCONTENTINACTIVE_TEXT,
 						fb_pixel_t text_color = COL_MENUCONTENT_TEXT,
 						fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
diff --git a/src/gui/components/cc_frm_footer.cpp b/src/gui/components/cc_frm_footer.cpp
index e95e422..7edb213 100644
--- a/src/gui/components/cc_frm_footer.cpp
+++ b/src/gui/components/cc_frm_footer.cpp
@@ -43,19 +43,19 @@ CComponentsFooter::CComponentsFooter(CComponentsForm* parent)
 CComponentsFooter::CComponentsFooter(	const int& x_pos, const int& y_pos, const int& w, const int& h,
 					const int& buttons,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow )
 {
 	//CComponentsFooter
-	initVarFooter(x_pos, y_pos, w, h, buttons, parent, has_shadow, color_frame, color_body, color_shadow);
+	initVarFooter(x_pos, y_pos, w, h, buttons, parent, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 void CComponentsFooter::initVarFooter(	const int& x_pos, const int& y_pos, const int& w, const int& h,
 					const int& buttons,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow )
@@ -72,11 +72,11 @@ void CComponentsFooter::initVarFooter(	const int& x_pos, const int& y_pos, const
 	cch_font 	= g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_SMALL];
 	height 		= max(h, cch_font->getHeight());
 
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	col_frame	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
-	col_body_gradient		= false; /*g_settings.theme.Foot_gradient*/; //TODO: not implemented at the moment
+	cc_body_gradient_enable		= cc_body_gradient_enable_old	= g_settings.theme.menu_ButtonBar_gradient; //TODO: not complete implemented at the moment
 	cc_body_gradient_direction	= CFrameBuffer::gradientVertical;
 	cc_body_gradient_mode		= CColorGradient::gradientDark2Light;
 	btn_auto_frame_col	= false;
@@ -145,6 +145,8 @@ void CComponentsFooter::setButtonLabels(const struct button_label_s * const cont
 		CComponentsButton *btn = new CComponentsButton(0, CC_CENTERED, w_btn_min, height-height/(btn_contour ? 4 : 3), txt, btn_name);
 		btn->setButtonFont(ccf_btn_font);
 		btn->doPaintBg(btn_contour);
+		btn->enableFrame(btn_contour);
+		btn->setButtonTextColor(COL_INFOBAR_SHADOW_TEXT);
 		btn->setButtonEventMsg(content[i].btn_msg);
 		btn->setButtonResult(content[i].btn_result);
 		btn->setButtonAlias(content[i].btn_alias);
diff --git a/src/gui/components/cc_frm_footer.h b/src/gui/components/cc_frm_footer.h
index 0487131..9b30a7b 100644
--- a/src/gui/components/cc_frm_footer.h
+++ b/src/gui/components/cc_frm_footer.h
@@ -62,7 +62,7 @@ class CComponentsFooter : public CComponentsHeader
 		void initVarFooter(	const int& x_pos, const int& y_pos, const int& w, const int& h = 0,
 					const int& buttons = 0,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_INFOBAR_SHADOW_PLUS_1,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -83,7 +83,7 @@ class CComponentsFooter : public CComponentsHeader
 		CComponentsFooter(	const int& x_pos, const int& y_pos, const int& w, const int& h = 0,
 					const int& buttons = 0,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_INFOBAR_SHADOW_PLUS_1,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
diff --git a/src/gui/components/cc_frm_header.cpp b/src/gui/components/cc_frm_header.cpp
index 59359b7..f26bc41 100644
--- a/src/gui/components/cc_frm_header.cpp
+++ b/src/gui/components/cc_frm_header.cpp
@@ -33,6 +33,12 @@
 using namespace std;
 
 //-------------------------------------------------------------------------------------------------------
+
+//	x/y	    width
+//	+---------------------------------------------------------+
+//	||icon |caption                    |clock|context buttons||height
+//	+---------------------------------------------------------+
+
 //sub class CComponentsHeader inherit from CComponentsForm
 CComponentsHeader::CComponentsHeader(CComponentsForm* parent)
 {
@@ -45,12 +51,12 @@ CComponentsHeader::CComponentsHeader(	const int& x_pos, const int& y_pos, const
 					const std::string& icon_name,
 					const int& buttons,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow)
 {
-	initVarHeader(x_pos, y_pos, w, h, caption, icon_name, buttons, parent, has_shadow, color_frame, color_body, color_shadow);
+	initVarHeader(x_pos, y_pos, w, h, caption, icon_name, buttons, parent, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 CComponentsHeaderLocalized::CComponentsHeaderLocalized(	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -58,7 +64,7 @@ CComponentsHeaderLocalized::CComponentsHeaderLocalized(	const int& x_pos, const
 							const std::string& icon_name,
 							const int& buttons,
 							CComponentsForm* parent,
-							bool has_shadow,
+							int shadow_mode,
 							fb_pixel_t color_frame,
 							fb_pixel_t color_body,
 							fb_pixel_t color_shadow)
@@ -66,7 +72,7 @@ CComponentsHeaderLocalized::CComponentsHeaderLocalized(	const int& x_pos, const
 										g_Locale->getText(caption_locale),
 										icon_name, buttons,
 										parent,
-										has_shadow,
+										shadow_mode,
 										color_frame, color_body, color_shadow){};
 
 void CComponentsHeader::initVarHeader(	const int& x_pos, const int& y_pos, const int& w, const int& h,
@@ -74,32 +80,32 @@ void CComponentsHeader::initVarHeader(	const int& x_pos, const int& y_pos, const
 					const std::string& icon_name,
 					const int& buttons,
 					CComponentsForm* parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow)
 {
 	cc_item_type 		= CC_ITEMTYPE_FRM_HEADER;
-	
-	x	= x_pos;
-	y	= y_pos;
+	cc_txt_save_screen	= true;
+	x	= x_old = x_pos;
+	y	= y_old = y_pos;
 
 	//init header width
-	width 	= w == 0 ? frameBuffer->getScreenWidth(true) : w;
+	width 	= width_old = w == 0 ? frameBuffer->getScreenWidth(true) : w;
 
 	//init header default height
-	height 		= max(h, g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight());
+	height 	= height_old = max(h, g_Font[SNeutrinoSettings::FONT_TYPE_MENU]->getHeight());
 
 	cch_size_mode	= CC_HEADER_SIZE_LARGE;
 	initCaptionFont();	//sets cch_font and calculate height if required;
 
-	shadow		= has_shadow;
-	col_frame	= color_frame;
-	col_body	= color_body;
-	col_shadow	= color_shadow;
-	col_body 	= COL_MENUHEAD_PLUS_0;
-	col_body_gradient		= g_settings.theme.menu_Head_gradient;
-	cc_body_gradient_direction	= CFrameBuffer::gradientVertical;
+	shadow		= shadow_mode;
+	col_frame = col_frame_old 	= color_frame;
+	col_body = col_body_old		= color_body;
+	col_shadow = col_shadow_old	= color_shadow;
+	col_body = col_body_old		= COL_MENUHEAD_PLUS_0;
+	cc_body_gradient_enable	 	= cc_body_gradient_enable_old	= g_settings.theme.menu_Head_gradient;
+	cc_body_gradient_direction	= cc_body_gradient_direction_old = g_settings.theme.menu_Head_gradient_direction;
 	cc_body_gradient_mode		= CColorGradient::gradientLight2Dark;
 	cch_text	= caption;
 	cch_icon_name	= icon_name;
@@ -110,15 +116,22 @@ void CComponentsHeader::initVarHeader(	const int& x_pos, const int& y_pos, const
 	cch_icon_obj		= NULL;
 	cch_text_obj		= NULL;
 	cch_btn_obj		= NULL;
+	cch_cl_obj		= NULL;
 	cch_col_text		= COL_MENUHEAD_TEXT;
 	cch_caption_align	= CTextBox::NO_AUTO_LINEBREAK;
 	cch_items_y 		= CC_CENTERED;
 	cch_offset		= 8;
 	cch_icon_x 		= cch_offset;
 	cch_icon_w		= 0;
+	cch_clock_w		= 0;
 	cch_text_x		= cch_offset;
 	cch_buttons_space	= cch_offset;
 
+	cch_cl_enable 		= false;
+	cch_cl_format		= "%H:%M";
+	cch_cl_sec_format 	= cch_cl_format;
+	cch_cl_enable_run	= false;
+
 	addContextButton(buttons);
 	initCCItems();
 	initParent(parent);
@@ -130,16 +143,18 @@ CComponentsHeader::~CComponentsHeader()
 	v_cch_btn.clear();
 }
 
-void CComponentsHeader::setCaption(const std::string& caption, const int& align_mode)
+void CComponentsHeader::setCaption(const std::string& caption, const int& align_mode, const fb_pixel_t& text_color)
 {
 	cch_text		= caption;
 	cch_caption_align 	= align_mode;
+	cch_col_text 		= text_color;
 }
 
-void CComponentsHeader::setCaption(neutrino_locale_t caption_locale, const int& align_mode)
+void CComponentsHeader::setCaption(neutrino_locale_t caption_locale, const int& align_mode, const fb_pixel_t& text_color)
 {
-	cch_text		= g_Locale->getText(caption_locale);
-	cch_caption_align 	= align_mode;
+	if (cch_cl_obj)
+		cch_cl_obj->Stop();
+	setCaption(string(g_Locale->getText(caption_locale)), align_mode, text_color);
 }
 
 void CComponentsHeader::setCaptionFont(Font* font)
@@ -226,7 +241,7 @@ void CComponentsHeader::initIcon()
 		//global adapt height
 		height = max(height, cch_icon_obj->getHeight());
 
-// 		//re-align height of icon object
+//		//re-assign height of icon object, for the case of changed height
 // 		cch_icon_obj->setHeight(height);
 	}
 }
@@ -310,7 +325,7 @@ void CComponentsHeader::initButtons()
 
 	//set button form properties
 	if (cch_btn_obj){
-		cch_btn_obj->setDimensionsAll(0, cch_items_y, 0, 0);
+		cch_btn_obj->setYPos(cch_items_y);
 		cch_btn_obj->doPaintBg(false);
 		cch_btn_obj->setAppendOffset(cch_buttons_space, 0);
 		cch_btn_obj->removeAllIcons();
@@ -336,6 +351,79 @@ void CComponentsHeader::initButtons()
 	}
 }
 
+
+void CComponentsHeader::enableClock(bool enable, const char* format, const char* sec_format_str, bool run)
+{
+	cch_cl_enable	= enable;
+	cch_cl_format 	= format;
+	if (sec_format_str)
+		cch_cl_sec_format = sec_format_str;
+	cch_cl_enable_run 	= run;
+	if (!enable){
+		if (cch_cl_obj){
+			cch_cl_enable_run = false;
+			removeCCItem(cch_cl_obj);
+			cch_cl_obj = NULL;
+		}
+	}
+	initCCItems();
+}
+
+
+void CComponentsHeader::disableClock()
+{
+	enableClock(false, cch_cl_format, cch_cl_sec_format, false);
+}
+
+void CComponentsHeader::initClock()
+{
+	//exit here if clock was disabled
+	if (!cch_cl_enable){
+		if (cch_cl_obj){
+			removeCCItem(cch_cl_obj);
+			cch_cl_obj = NULL;
+		}
+		return;
+	}
+	//create instance for header clock object and add to container
+	if (cch_cl_obj == NULL){
+		dprintf(DEBUG_DEBUG, "[CComponentsHeader]\n    [%s - %d] init clock...\n", __func__, __LINE__);
+		cch_cl_obj = new CComponentsFrmClock(0, cch_items_y, cch_font, cch_cl_format, NULL, false, 1, this);
+		cch_cl_obj->doPaintBg(false);
+	}
+
+	//set clock form properties
+	if (cch_cl_obj){
+		cch_cl_obj->setYPos(cch_items_y);
+		cch_cl_obj->setHeight(height);
+
+		//disallow paint of clock, if disabled and exit method
+		if (!cch_cl_enable){
+			cch_cl_obj->allowPaint(false);
+			cch_cl_obj->Stop();
+			return;
+		}
+
+		//assign time size and format
+		cch_cl_obj->setClockFont(cch_font);
+		cch_cl_obj->setClockFormat(cch_cl_format, cch_cl_sec_format);
+
+		//set corner mode of button item
+		int cc_btn_corner_type = corner_type;
+		if (corner_type == CORNER_TOP_RIGHT || corner_type == CORNER_TOP)
+			cc_btn_corner_type = CORNER_TOP_RIGHT;
+		else
+			cc_btn_corner_type = CORNER_RIGHT;
+		cch_cl_obj->setCorner(corner_rad-fr_thickness, cc_btn_corner_type);
+
+		//global adapt height
+		height = max(height, cch_cl_obj->getHeight());
+
+		//re-assign height of clock object, for the case of changed height
+		cch_cl_obj->setHeight(height);
+	}
+}
+
 void CComponentsHeader::initCaption()
 {
 	//recalc header text position if header icon is defined
@@ -346,42 +434,76 @@ void CComponentsHeader::initCaption()
 
 	//calc width of text object in header
 	cc_text_w = width-cch_text_x-cch_offset;
+
+	//context buttons
 	int buttons_w = 0;
 	if (cch_btn_obj){
 		//get width of buttons object
-		buttons_w = cch_btn_obj->getWidth();
+		buttons_w = cch_btn_obj->empty() ? 0 : cch_btn_obj->getWidth();
+		dprintf(DEBUG_DEBUG, "[CComponentsHeader]\n    [%s - %d] init context buttons...x=%d, y=%d, width=%d, height=%d\n", __func__, __LINE__, cch_btn_obj->getXPos(), cch_btn_obj->getYPos(), cch_btn_obj->getWidth(), cch_btn_obj->getHeight());
 		//set x position of buttons
 		cch_btn_obj->setXPos(width - buttons_w);
+
+		//set required width of caption object
+		cc_text_w -= (buttons_w + cch_offset);
 	}
-	//set required width of caption object
-	cc_text_w -= buttons_w-cch_offset;
+
+	//clock
+	if (cch_cl_obj){
+		//refresh clock properties
+		cch_cl_obj->refresh();
+
+		//get width of clock object
+		int clock_w = cch_cl_enable ? cch_cl_obj->getWidth() : 0;
+
+		//set x position of clock
+		cch_cl_obj->setXPos(width - buttons_w - clock_w - cch_offset);
+
+		//set required width of caption object
+		cc_text_w -= (clock_w + cch_offset);
+
+		//stop clock if disabled or option run is disabled and clock is running
+		if (cch_cl_enable){
+			if (!cch_cl_enable_run  && cch_cl_obj->isRun()){
+				cch_cl_obj->Stop();
+				cch_cl_obj->allowPaint(false);
+			}
+		}
+
+		//clock visible or not visible if run or not
+		cch_cl_obj->allowPaint(cch_cl_enable);
+	}
+
 
 	//create cch_text_obj and add to collection
 	if (cch_text_obj == NULL){
 		dprintf(DEBUG_DEBUG, "[CComponentsHeader]\n    [%s - %d] init header text: %s [ x %d w %d ]\n", __func__, __LINE__, cch_text.c_str(), cch_text_x, cc_text_w);
-		cch_text_obj = new CComponentsText();
+		cch_text_obj = new CComponentsText(this);
+		cch_text_obj->doPaintBg(false);
 	}
 
-	//add text item
-	if (!cch_text_obj->isAdded())
-		addCCItem(cch_text_obj); //text
-
 	//set header text properties
 	if (cch_text_obj){
-			//set alignment of text item in dependency from text alignment
+		//set alignment of text item in dependency from text alignment
 		if (cch_caption_align == CTextBox::CENTER)
 			cch_text_x = CC_CENTERED;
+
+		//assign general properties
 		cch_text_obj->setDimensionsAll(cch_text_x, cch_items_y, cc_text_w, height);
-		cch_text_obj->doPaintBg(false);
-		cch_text_obj->setText(cch_text, cch_caption_align, cch_font);
-		cch_text_obj->forceTextPaint(); //here required
-		cch_text_obj->setTextColor(cch_col_text);
 		cch_text_obj->setColorBody(col_body);
-		cch_text_obj->enableTboxSaveScreen(save_tbox_screen);
+		if (cc_body_gradient_enable != cc_body_gradient_enable_old)
+			cch_text_obj->getCTextBoxObject()->clearScreenBuffer();
+		cch_text_obj->setTextColor(cch_col_text);
+		cch_text_obj->setText(cch_text, cch_caption_align, cch_font);
+		cch_text_obj->enableTboxSaveScreen(cc_body_gradient_enable || cc_txt_save_screen);
 
 		//corner of text item
 		cch_text_obj->setCorner(corner_rad-fr_thickness, corner_type);
 
+		//synchronize clock color with caption color
+		if (cch_cl_obj)
+			cch_cl_obj->setTextColor(cch_col_text);
+
 		/*
 		   global adapt height not needed here again
 		   because this object is initialized at last
@@ -392,6 +514,9 @@ void CComponentsHeader::initCaption()
 
 void CComponentsHeader::initCCItems()
 {
+	//set basic properties
+	Init(x, y, width, height, col_frame, col_body, col_shadow);
+
 	//set size
 	initCaptionFont();
 
@@ -401,6 +526,9 @@ void CComponentsHeader::initCCItems()
 	//init buttons
 	initButtons();
 
+	//init clock
+	initClock();
+
 	//init text
 	initCaption();
 }
@@ -412,4 +540,22 @@ void CComponentsHeader::paint(bool do_save_bg)
 	
 	//paint form contents
 	paintForm(do_save_bg);
+
+	//start clock if enabled
+	if (cch_cl_obj){
+		if (cch_cl_enable && cch_cl_enable_run)
+			cch_cl_obj->Start();
+	}
+}
+
+
+bool CComponentsHeader::enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color, const int& direction)
+{
+	int dir = direction == -1 ? g_settings.theme.menu_Head_gradient_direction : direction; //header mode is pre defined here
+
+	if (cch_text_obj->getCTextBoxObject())
+		cch_text_obj->getCTextBoxObject()->clearScreenBuffer();
+
+	return CComponentsForm::enableColBodyGradient(enable_mode, sec_color, dir);
 }
+
diff --git a/src/gui/components/cc_frm_header.h b/src/gui/components/cc_frm_header.h
index a551546..56eb3e3 100644
--- a/src/gui/components/cc_frm_header.h
+++ b/src/gui/components/cc_frm_header.h
@@ -29,13 +29,14 @@
 #include "cc_item_picture.h"
 #include "cc_item_text.h"
 #include "cc_frm_icons.h"
+#include "cc_frm_clock.h"
 #include <driver/colorgradient.h>
 
 //! Sub class of CComponentsForm. Shows a header with prepared items.
 /*!
 CComponentsHeader provides prepared items like icon, caption and context button icons, mostly for usage in menues or simple windows
 */
-class CComponentsHeader : public CComponentsForm
+class CComponentsHeader : public CComponentsForm, public CCTextScreen
 {
 	private:
 		///member: init genaral variables, parameters for mostly used properties
@@ -44,7 +45,7 @@ class CComponentsHeader : public CComponentsForm
 					const std::string& = "",
 					const int& buttons = 0,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUHEAD_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -56,6 +57,8 @@ class CComponentsHeader : public CComponentsForm
 		CComponentsText * cch_text_obj;
 		///object: context button object, see also addContextButton(), removeContextButtons()
 		CComponentsIconForm * cch_btn_obj;
+		///object: clock object
+		CComponentsFrmClock * cch_cl_obj;
 
 		///property: caption text, see also setCaption()
 		std::string cch_text;
@@ -72,6 +75,8 @@ class CComponentsHeader : public CComponentsForm
 		int cch_icon_x;
 		///property: internal width for icon object
 		int cch_icon_w;
+		///property: internal width for clock object
+		int cch_clock_w;
 		///property: internal x-position for caption object
 		int cch_text_x;
 		///property: internal offset of context button icons within context button object
@@ -84,6 +89,14 @@ class CComponentsHeader : public CComponentsForm
 		int cch_size_mode;
 		///property: alignment of caption within header, see also setCaptionAlignment(), possible values are CTextBox::CENTER, default = CTextBox::NO_AUTO_LINEBREAK (left)
 		int cch_caption_align;
+		///property: enable/disable of clock, see also enableClock()
+		bool cch_cl_enable;
+		///property: clock format
+		const char* cch_cl_format;
+		///property: secondary clock format
+		const char* cch_cl_sec_format;
+		///property: enable running clock
+		bool cch_cl_enable_run;
 
 		///init font object and recalculates height if required
 		void initCaptionFont(Font* font = NULL);
@@ -93,6 +106,8 @@ class CComponentsHeader : public CComponentsForm
 		void initCaption();
 		///sub: init context button object
 		void initButtons();
+		///sub: init clock object
+		void initClock();
 
 	public:
 		enum
@@ -108,7 +123,7 @@ class CComponentsHeader : public CComponentsForm
 					const std::string& = "",
 					const int& buttons = 0,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUHEAD_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -116,9 +131,9 @@ class CComponentsHeader : public CComponentsForm
 		virtual ~CComponentsHeader();
 
 		///set caption text, parameters: string, int align_mode (default left) 
-		virtual void setCaption(const std::string& caption, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK);
+		virtual void setCaption(const std::string& caption, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK, const fb_pixel_t& text_color = COL_MENUHEAD_TEXT);
 		///set caption text, parameters: loacle, int align_mode (default left)
-		virtual void setCaption(neutrino_locale_t caption_locale, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK);
+		virtual void setCaption(neutrino_locale_t caption_locale, const int& align_mode = CTextBox::NO_AUTO_LINEBREAK, const fb_pixel_t& text_color = COL_MENUHEAD_TEXT);
 
 		///set alignment of caption within header, possible paramters are CTextBox::CENTER, CTextBox::NO_AUTO_LINEBREAK
 		virtual void setCaptionAlignment(const int& align_mode){cch_caption_align = align_mode;};
@@ -181,7 +196,7 @@ class CComponentsHeader : public CComponentsForm
 		};
 
 		///set offset between icons within context button object
-		virtual void setButtonsSpace(const int buttons_space){cch_buttons_space = buttons_space;};
+		virtual void setButtonsSpace(const int buttons_space){cch_buttons_space = buttons_space;}
 
 		enum
 		{
@@ -189,15 +204,31 @@ class CComponentsHeader : public CComponentsForm
 			CC_HEADER_SIZE_SMALL 	= 1
 		};
 		///set size of header, possible values are CC_HEADER_SIZE_LARGE, CC_HEADER_SIZE_SMALL
-		virtual void setSizeMode(const int& size_mode){cch_size_mode = size_mode; initCCItems();};
+		virtual void setSizeMode(const int& size_mode){cch_size_mode = size_mode; initCCItems();}
 
 		///init all items within header object
 		virtual void initCCItems();
 		///returns the text object
-		virtual CComponentsText* getTextObject(){return cch_text_obj;};
+		virtual CComponentsText* getTextObject(){return cch_text_obj;}
+
+		///returns the clock object
+		virtual CComponentsFrmClock* getClockObject(){return cch_cl_obj;}
+
+		///enable display of clock, parameter bool enable, const char* format, bool run
+		virtual void enableClock(bool enable = true, const char* format = "%H:%M", const char* sec_format_str = NULL, bool run = false);
+		///disable clock, without parameter
+		virtual void disableClock();
 
 		///paint header
 		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
+
+		///hides item, arg: no_restore see hideCCItem()
+		void hide(){disableClock(); CComponents::hide();}
+		///erase current screen without restore of background, it's similar to paintBackgroundBoxRel() from CFrameBuffer
+		virtual void kill(){disableClock(); CComponentsForm::kill();}
+
+		///set color gradient on/off, returns true if gradient mode was changed
+		virtual bool enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/, const int& direction = -1);
 };
 
 //! Sub class of CComponentsHeader.
@@ -213,7 +244,7 @@ class CComponentsHeaderLocalized : public CComponentsHeader
 						const std::string& = "",
 						const int& buttons = 0,
 						CComponentsForm *parent = NULL,
-						bool has_shadow = CC_SHADOW_OFF,
+						int shadow_mode = CC_SHADOW_OFF,
 						fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 						fb_pixel_t color_body = COL_MENUHEAD_PLUS_0,
 						fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
diff --git a/src/gui/components/cc_frm_icons.cpp b/src/gui/components/cc_frm_icons.cpp
index 6cb020c..e7e47a8 100644
--- a/src/gui/components/cc_frm_icons.cpp
+++ b/src/gui/components/cc_frm_icons.cpp
@@ -41,16 +41,16 @@ CComponentsIconForm::CComponentsIconForm(CComponentsForm* parent)
 CComponentsIconForm::CComponentsIconForm(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 						const std::vector<std::string> &v_icon_names,
 						CComponentsForm* parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
-	initVarIconForm(x_pos, y_pos, w, h, v_icon_names, parent, has_shadow, color_frame, color_body, color_shadow);
+	initVarIconForm(x_pos, y_pos, w, h, v_icon_names, parent, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 void CComponentsIconForm::initVarIconForm(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 						const std::vector<std::string> &v_icon_names,
 						CComponentsForm* parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	cc_item_type 	= CC_ITEMTYPE_FRM_ICONFORM;
@@ -60,7 +60,7 @@ void CComponentsIconForm::initVarIconForm(	const int &x_pos, const int &y_pos, c
 	width 		= w;
 	height 		= h;
 	v_icons		= v_icon_names;
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	col_frame	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
diff --git a/src/gui/components/cc_frm_icons.h b/src/gui/components/cc_frm_icons.h
index 3022948..c48fdd3 100644
--- a/src/gui/components/cc_frm_icons.h
+++ b/src/gui/components/cc_frm_icons.h
@@ -36,7 +36,7 @@ class CComponentsIconForm : public CComponentsFrmChain
 		void initVarIconForm(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 					const std::vector<std::string> &v_icon_names,
 					CComponentsForm* parent,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUHEAD_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -46,7 +46,7 @@ class CComponentsIconForm : public CComponentsFrmChain
 		CComponentsIconForm(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 					const std::vector<std::string> &v_icon_names,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUHEAD_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 // 		~CComponentsIconForm(); //inherited from CComponentsForm
diff --git a/src/gui/components/cc_frm_scrollbar.cpp b/src/gui/components/cc_frm_scrollbar.cpp
index 464c503..51cc885 100644
--- a/src/gui/components/cc_frm_scrollbar.cpp
+++ b/src/gui/components/cc_frm_scrollbar.cpp
@@ -62,9 +62,9 @@ using namespace std;
 CComponentsScrollBar::CComponentsScrollBar(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 						const int& count,
 						CComponentsForm* parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
-						:CComponentsFrmChain(x_pos, y_pos, w, h, NULL, CC_DIR_Y, parent, has_shadow, color_frame, color_body, color_shadow)
+						:CComponentsFrmChain(x_pos, y_pos, w, h, NULL, CC_DIR_Y, parent, shadow_mode, color_frame, color_body, color_shadow)
 {
 	initVarSbForm(count);
 }
@@ -165,12 +165,12 @@ void CComponentsScrollBar::initSegments()
 		//set color for marked id
 		if (sb_mark_id == id){
 			item->setColorBody(COL_MENUCONTENTSELECTED_PLUS_0);
-			item->enableColBodyGradient(true);
+			item->enableColBodyGradient(CC_COLGRAD_COL_A_2_COL_B);
 			item->setColBodyGradient(CColorGradient::gradientDark2Light2Dark, CFrameBuffer::gradientHorizontal);
 		}
 		else{
 			item->setColorBody(COL_MENUCONTENT_PLUS_1);
-			item->enableColBodyGradient(false);
+			item->disableColBodyGradient();
 		}
 	}
 
diff --git a/src/gui/components/cc_frm_scrollbar.h b/src/gui/components/cc_frm_scrollbar.h
index 55b93fa..fdf26a3 100644
--- a/src/gui/components/cc_frm_scrollbar.h
+++ b/src/gui/components/cc_frm_scrollbar.h
@@ -63,7 +63,7 @@ class CComponentsScrollBar : public CComponentsFrmChain
 		CComponentsScrollBar(	const int &x_pos, const int &y_pos, const int &w = 15, const int &h = 40,
 					const int& count = 1,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_3,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 // 		~CComponentsScrollBar(); //inherited from CComponentsForm
diff --git a/src/gui/components/cc_frm_signalbars.cpp b/src/gui/components/cc_frm_signalbars.cpp
index 8af1782..d361216 100644
--- a/src/gui/components/cc_frm_signalbars.cpp
+++ b/src/gui/components/cc_frm_signalbars.cpp
@@ -143,6 +143,8 @@ void CSignalBar::initSBarValue()
 	if (sb_vlbl == NULL){
 		sb_vlbl = new CComponentsLabel();
 		sb_vlbl->doPaintBg(false);
+		sb_vlbl->doPaintTextBoxBg(false);
+		sb_vlbl->enableTboxSaveScreen(true);
 		sb_vlbl->setText("  0%", sb_val_mode, sb_font);
 	}
 
@@ -150,7 +152,7 @@ void CSignalBar::initSBarValue()
 	int vlbl_x = sb_scale->getXPos() + sb_scale_width + append_y_offset;
 	int vlbl_h = sb_scale->getHeight();
 	int vlbl_y = sb_item_height/2 + sb_item_top - vlbl_h/2 - append_x_offset;
-	sb_vlbl->setDimensionsAll(vlbl_x, vlbl_y, sb_vlbl_width, vlbl_h);
+	sb_vlbl->setDimensionsAll(vlbl_x, vlbl_y, sb_vlbl_width - append_x_offset, vlbl_h);
 
 	//set current text and body color color
 	sb_vlbl->setTextColor(sb_caption_color);
@@ -167,21 +169,22 @@ void CSignalBar::initSBarName()
 	if (sb_lbl == NULL){
 		sb_lbl = new CComponentsLabel();
 		sb_lbl->doPaintBg(false);
+		sb_lbl->doPaintTextBoxBg(false);
+		sb_lbl->enableTboxSaveScreen(true);
 		sb_lbl->setText(sb_name, CTextBox::NO_AUTO_LINEBREAK | CTextBox::RIGHT, sb_font);
-		sb_lbl->forceTextPaint();
-		sb_lbl->doPaintTextBoxBg(true);
 	}
 
 	//move and set dimensions
 	int lbl_x = sb_vlbl->getXPos()+ sb_vlbl->getWidth();
 	int lbl_h = sb_vlbl->getHeight();
 	int lbl_y = sb_item_height/2 + sb_item_top - lbl_h/2 - append_x_offset;
-	sb_lbl->setDimensionsAll(lbl_x, lbl_y, sb_lbl_width, lbl_h);
+	sb_lbl->setDimensionsAll(lbl_x, lbl_y, sb_lbl_width- append_x_offset, lbl_h);
 
 	//set current text and body color
 	sb_lbl->setTextColor(sb_caption_color);
 	sb_lbl->setColorBody(col_body);
 
+
 	//add name label object to container
 	if (!sb_lbl->isAdded())
 		addCCItem(sb_lbl);
@@ -218,12 +221,6 @@ void CSignalBar::paintScale()
 		percent += "%";
 		sb_vlbl->setText(percent, sb_val_mode, sb_font);
 
-		//we must force paint backround, because of changing values
-		sb_vlbl->doPaintBg(true);
-		sb_vlbl->forceTextPaint();
-		sb_vlbl->doPaintTextBoxBg(true);
-		sb_vlbl->setColorBody(col_body);
-
 		//repaint labels
 		for(size_t i=0; i<this->v_cc_items.size(); i++)
 			v_cc_items[i]->paint(false);
diff --git a/src/gui/components/cc_frm_slider.cpp b/src/gui/components/cc_frm_slider.cpp
index e96d83c..e697f24 100644
--- a/src/gui/components/cc_frm_slider.cpp
+++ b/src/gui/components/cc_frm_slider.cpp
@@ -34,7 +34,7 @@ CComponentsSlider::CComponentsSlider(	const int& x_pos, const int& y_pos, const
 					const int& min_value,
 					const int& max_value,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t& color_frame,
 					fb_pixel_t& color_body,
 					fb_pixel_t& color_shadow)
@@ -51,7 +51,7 @@ CComponentsSlider::CComponentsSlider(	const int& x_pos, const int& y_pos, const
 	csl_min_value 		= min_value;
 	csl_max_value 		= max_value;
 
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	col_frame	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
@@ -88,8 +88,9 @@ void CComponentsSlider::initCCSlBody()
 {
 	if (!csl_body_icon.empty()){
 		if (csl_body_obj == NULL){
-			csl_body_obj = new CComponentsPicture(0, 0, 0, 0, csl_body_icon);
-			csl_body_obj->doPaintBg(false);
+			csl_body_obj = new CComponentsPicture(0, 0, width-2*fr_thickness, 16, csl_body_icon);
+			csl_body_obj->setColorBody(this->col_body); //FIXME: Background handling during current instance of slider object
+			csl_body_obj->doPaintBg(true);
 			addCCItem(csl_body_obj);
 		}
 		else
@@ -118,8 +119,9 @@ void CComponentsSlider::initCCSlSlider()
 {
 	if (!csl_slider_icon.empty()){
 		if (csl_slider_obj == NULL){
-			csl_slider_obj = new CComponentsPicture(0, 0, 0, 0, csl_slider_icon);
-			csl_slider_obj->doPaintBg(false);
+			csl_slider_obj = new CComponentsPicture(0, 0, csl_slider_icon);
+			csl_slider_obj->setColorBody(this->col_body); //FIXME: Background handling during current instance of slider object
+			csl_slider_obj->doPaintBg(true);
 			addCCItem(csl_slider_obj);
 		}
 		else
@@ -135,7 +137,7 @@ void CComponentsSlider::initCCSlSlider()
 	int slider_h = csl_slider_obj->getHeight();
 
 	//position of slider icon
-	int slider_x = csl_body_obj->getXPos() - slider_w/2 + csl_body_obj->getWidth() * (abs(csl_min_value) + csl_current_value) / (abs(csl_min_value) + abs(csl_max_value));
+	int slider_x = csl_body_obj->getXPos() + (csl_body_obj->getWidth()-slider_w) * (abs(csl_min_value) + csl_current_value) / (abs(csl_min_value) + abs(csl_max_value));
 	int slider_y = height/2-slider_h/2;
 
 	if (csl_slider_obj)
diff --git a/src/gui/components/cc_frm_slider.h b/src/gui/components/cc_frm_slider.h
index 08395d7..97e5d7e 100644
--- a/src/gui/components/cc_frm_slider.h
+++ b/src/gui/components/cc_frm_slider.h
@@ -66,7 +66,7 @@ class CComponentsSlider : public CComponentsForm
 					const int& min_value = 0,
 					const int& max_value = 100,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t& color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t& color_body = COL_MENUHEAD_PLUS_0,
 					fb_pixel_t& color_shadow = COL_MENUCONTENTDARK_PLUS_0);
diff --git a/src/gui/components/cc_frm_window.cpp b/src/gui/components/cc_frm_window.cpp
index 07f2b67..4be33a4 100644
--- a/src/gui/components/cc_frm_window.cpp
+++ b/src/gui/components/cc_frm_window.cpp
@@ -66,53 +66,53 @@ CComponentsWindow::CComponentsWindow(	const int& x_pos, const int& y_pos, const
 					neutrino_locale_t locale_caption,
 					const string& iconname,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow)
 {
 	string s_caption = locale_caption != NONEXISTANT_LOCALE ? g_Locale->getText(locale_caption) : "";
-	initVarWindow(x_pos, y_pos, w, h, s_caption, iconname, parent, has_shadow, color_frame, color_body, color_shadow);
+	initVarWindow(x_pos, y_pos, w, h, s_caption, iconname, parent, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 CComponentsWindow::CComponentsWindow(	const int& x_pos, const int& y_pos, const int& w, const int& h,
 					const string& caption,
 					const string& iconname,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow)
 {
-	initVarWindow(x_pos, y_pos, w, h, caption, iconname, parent, has_shadow, color_frame, color_body, color_shadow);
+	initVarWindow(x_pos, y_pos, w, h, caption, iconname, parent, shadow_mode, color_frame, color_body, color_shadow);
 }
 
 CComponentsWindowMax::CComponentsWindowMax(	const string& caption,
 						const string& iconname,
 						CComponentsForm *parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame,
 						fb_pixel_t color_body,
 						fb_pixel_t color_shadow)
 						:CComponentsWindow(0, 0, 0, 0, caption,
-						iconname, parent, has_shadow, color_frame, color_body, color_shadow){};
+						iconname, parent, shadow_mode, color_frame, color_body, color_shadow){};
 
 CComponentsWindowMax::CComponentsWindowMax(	neutrino_locale_t locale_caption,
 						const string& iconname,
 						CComponentsForm *parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame,
 						fb_pixel_t color_body,
 						fb_pixel_t color_shadow)
 						:CComponentsWindow(0, 0, 0, 0,
 						locale_caption != NONEXISTANT_LOCALE ? g_Locale->getText(locale_caption) : "",
-						iconname, parent, has_shadow, color_frame, color_body, color_shadow){};
+						iconname, parent, shadow_mode, color_frame, color_body, color_shadow){};
 
 void CComponentsWindow::initVarWindow(	const int& x_pos, const int& y_pos, const int& w, const int& h,
 					const string& caption,
 					const string& iconname,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
 					fb_pixel_t color_shadow)
@@ -134,7 +134,7 @@ void CComponentsWindow::initVarWindow(	const int& x_pos, const int& y_pos, const
 
 	dprintf(DEBUG_DEBUG, "[CComponentsWindow]   [%s - %d] icon name = %s\n", __func__, __LINE__, ccw_icon_name.c_str());
 
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	col_frame	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
@@ -212,7 +212,7 @@ void CComponentsWindow::initFooter()
 	if (ccw_footer){
 		ccw_footer->setPos(0, CC_APPEND);
 		ccw_footer->setWidth(width-2*fr_thickness);
-		ccw_footer->setShadowOnOff(shadow);
+		ccw_footer->enableShadow(shadow);
 		ccw_footer->setCorner(corner_rad, CORNER_BOTTOM);
 	}
 }
diff --git a/src/gui/components/cc_frm_window.h b/src/gui/components/cc_frm_window.h
index 79b0c94..2ef5351 100644
--- a/src/gui/components/cc_frm_window.h
+++ b/src/gui/components/cc_frm_window.h
@@ -101,7 +101,7 @@ class CComponentsWindow : public CComponentsForm
 					const std::string& caption = "",
 					const std::string& iconname = "",
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -126,7 +126,7 @@ class CComponentsWindow : public CComponentsForm
 					const std::string& caption = "",
 					const std::string& iconname = "",
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -136,7 +136,7 @@ class CComponentsWindow : public CComponentsForm
 					neutrino_locale_t locale_text = NONEXISTANT_LOCALE,
 					const std::string& iconname = "",
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -214,7 +214,7 @@ class CComponentsWindowMax : public CComponentsWindow
 		///simple constructor for CComponentsWindow, provides parameters for caption as string and icon, this shows a centered window based up current screen settings
 		CComponentsWindowMax(	const std::string& caption, const std::string& iconname = "",
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
@@ -222,7 +222,7 @@ class CComponentsWindowMax : public CComponentsWindow
 		///simple constructor for CComponentsWindow, provides parameters for caption from locales and icon, this shows a centered window based up current screen settings
 		CComponentsWindowMax(	neutrino_locale_t locale_caption, const std::string& iconname = "",
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
diff --git a/src/gui/components/cc_item.cpp b/src/gui/components/cc_item.cpp
index 2c2b158..4f9b242 100644
--- a/src/gui/components/cc_item.cpp
+++ b/src/gui/components/cc_item.cpp
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2014, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
 	Copyright (C) 2012, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -18,10 +18,8 @@
 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 	General Public License for more details.
 
-	You should have received a copy of the GNU General Public
-	License along with this program; if not, write to the
-	Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-	Boston, MA  02110-1301, USA.
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifdef HAVE_CONFIG_H
@@ -30,7 +28,7 @@
 
 #include <global.h>
 #include <neutrino.h>
-#include "cc_base.h"
+#include "cc_item.h"
 #include <driver/screen_max.h>
 #include <system/debug.h>
 #include <cs_api.h>
@@ -46,19 +44,12 @@ using namespace std;
 //abstract sub class CComponentsItem from CComponents
 CComponentsItem::CComponentsItem(CComponentsForm* parent)
 {
-	cc_item_type 		= CC_ITEMTYPE_BASE;
+	cc_item_type 		= CC_ITEMTYPE_GENERIC;
 	cc_item_index 		= CC_NO_INDEX;
 	cc_item_enabled 	= true;
 	cc_item_selected 	= false;
 	cc_page_number		= 0;
 	cc_has_focus		= true;
-	cc_gradientData.gradientBuf = NULL;
-	cc_body_gradient_mode 	= CColorGradient::gradientLight2Dark;
-	cc_body_gradient_intensity = CColorGradient::light;
-	cc_body_gradient_intensity_v_min = 0x40;
-	cc_body_gradient_intensity_v_max = 0xE0;
-	cc_body_gradient_saturation = 0xC0;
-	cc_body_gradient_direction = CFrameBuffer::gradientVertical;
 	initParent(parent);
 }
 
@@ -69,84 +60,68 @@ void CComponentsItem::initParent(CComponentsForm* parent)
 		cc_parent->addCCItem(this);
 }
 
-// Paint container background in cc-items with shadow, background and frame.
+// init container properties in cc-items for shadow, background and frame.
 // This member must be called first in all paint() members before paint other items into the container.
 // If backround is not required, it's possible to override this with variable paint_bg=false, use doPaintBg(true/false) to set this!
 void CComponentsItem::paintInit(bool do_save_bg)
 {
-	//init color gradient
-	if (col_body_gradient)
-		initBodyGradient();
+	if (hasChanges())
+		clearFbData();
 
-	clearFbData();
+	if (v_fbdata.empty()){
+		int th = fr_thickness;
+		fb_pixel_t col_frame_cur = col_frame;
 
-	int th = fr_thickness;
-	fb_pixel_t col_frame_cur = col_frame;
+		//calculate current needed frame thickeness and color, if item selected or not
+		if (cc_item_selected){
+			col_frame_cur = col_frame_sel;
+			th = max(fr_thickness_sel, fr_thickness);
+		}
 
-	//calculate current needed frame thickeness and color, if item selected or not
-	if (cc_item_selected){
-		col_frame_cur = col_frame_sel;
-		th = max(fr_thickness_sel, fr_thickness);
-	}
+		//calculate current needed corner radius for body box, depends of frame thickness
+		int rad = (corner_rad>th) ? corner_rad-th : corner_rad;
+		int sw = (shadow) ? shadow_w : 0;
 
-	//calculate current needed corner radius for body box, depends of frame thickness
-	int rad = (corner_rad>th) ? corner_rad-th : corner_rad;
-	int sw = (shadow) ? shadow_w : 0;
+		//evaluate shadow mode
+		bool sh_r = (shadow & CC_SHADOW_ON) || (shadow & CC_SHADOW_RIGHT);
+		bool sh_b = (shadow & CC_SHADOW_ON) || (shadow & CC_SHADOW_BOTTOM);
 
-	//if item is bound on a parent form, we must use real x/y values and from parent form as reference
-	int ix = x, iy = y;
-	if (cc_parent){
-		ix = cc_xr;
-		iy = cc_yr;
-	}
-
-	cc_gradientData.mode = CFrameBuffer::pbrg_noFree;
-	void* gradientData = (cc_gradientData.gradientBuf == NULL) ? NULL : &cc_gradientData;
-	comp_fbdata_t fbdata[] =
-	{
-		{CC_FBDATA_TYPE_BGSCREEN,	ix,	iy, 	width+sw, 	height+sw, 	0, 		0, 		0, 	NULL,	NULL},
-		{CC_FBDATA_TYPE_SHADOW_BOX, 	ix+sw,	iy+sw, 	width, 		height, 	col_shadow, 	corner_rad, 	0, 	NULL,	NULL},//shadow
-		{CC_FBDATA_TYPE_FRAME,		ix,	iy, 	width, 		height, 	col_frame_cur, 	corner_rad, 	th, 	NULL,	NULL},//frame
-		{CC_FBDATA_TYPE_BOX,		ix+th,  iy+th,  width-2*th,     height-2*th,    col_body,       rad, 		0, 	NULL, 	gradientData},//body
-	};
-
-	for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++) {
-		if (((fbdata[i].fbdata_type == CC_FBDATA_TYPE_SHADOW_BOX) && !shadow) ||
-		    ((fbdata[i].fbdata_type == CC_FBDATA_TYPE_FRAME) && !fr_thickness))
-			continue;
-		v_fbdata.push_back(fbdata[i]);
-	}
-
-	dprintf(DEBUG_DEBUG, "[CComponentsItem] %s:\ncc_item_type: %d\ncc_item_index = %d\nheight = %d\nwidth = %d\n", __func__, cc_item_type,  cc_item_index, height, width);
+		//if item is bound on a parent form, we must use real x/y values and from parent form as reference
+		int ix = x, iy = y;
+		if (cc_parent){
+			ix = cc_xr;
+			iy = cc_yr;
+		}
 
-	paintFbItems(do_save_bg);
-}
+		//handle shadow width
+		if (width <= sw || height <= sw){ //don't use shadow, if item dimensions too small
+			dprintf(DEBUG_NORMAL, "\033[33m[CComponentsItem]\t[%s - %d] shadow dimensions too small sw=%d, shadow is disabled set dimension to 0\033[0m\n",__func__, __LINE__, sw);
+			shadow = CC_SHADOW_OFF;
+			sw = 0;
+		}
+		int isw = sw*2;
+		int ixsr = ix + width - isw/2;
+		int iysb = iy + height - isw/2;
+
+		//init paint layers
+		cc_fbdata_t fbdata[] =
+		{
+			{true, CC_FBDATA_TYPE_BGSCREEN,		ix,		iy, 		width+isw/2, 	height+isw/2, 	0, 		0, 		0,				0, 	NULL, NULL, NULL, false}, //buffered bg
+			{sh_r, CC_FBDATA_TYPE_SHADOW_BOX, 	ixsr,		iy+isw/2,	isw, 		height, 	col_shadow, 	corner_rad,	corner_type & CORNER_RIGHT,	0, 	NULL, NULL, NULL, false}, //shadow right
+			{sh_b, CC_FBDATA_TYPE_SHADOW_BOX, 	ix+isw/2,	iysb, 		width, 		isw, 		col_shadow, 	corner_rad,	corner_type & CORNER_BOTTOM,	0, 	NULL, NULL, NULL, false}, //shadow bottom
+			{true, CC_FBDATA_TYPE_FRAME,		ix,		iy, 		width, 		height, 	col_frame_cur, 	corner_rad,	corner_type,			th, 	NULL, NULL, NULL, false}, //frame
+			{true, CC_FBDATA_TYPE_BOX,		ix+th,  	iy+th,  	width-2*th,     height-2*th,    col_body,       rad,		corner_type,			0, 	NULL, NULL, NULL, false}, //body
+		};
+
+		for(size_t i =0; i< (sizeof(fbdata) / sizeof(fbdata[0])) ;i++) {
+			if ((fbdata[i].fbdata_type == CC_FBDATA_TYPE_FRAME) && !fr_thickness)
+				continue;
+			v_fbdata.push_back(fbdata[i]);
+		}
 
-//restore last saved screen behind form box,
-//Do use parameter 'no restore' to override the restore funtionality.
-//For embedded items is it mostly not required to restore saved screens, so no_resore=true also is default parameter
-//for such items.
-//This member ensures demage of already existing screen buffer too, if parameter no_restore was changed while runtime.
-void CComponentsItem::hideCCItem(bool no_restore)
-{
-	//restore saved screen if available
-	if (saved_screen.pixbuf) {
-		frameBuffer->waitForIdle("CComponentsItem::hideCCItem()");
-		frameBuffer->RestoreScreen(saved_screen.x, saved_screen.y, saved_screen.dx, saved_screen.dy, saved_screen.pixbuf);
-
-		if (no_restore) { //on parameter no restore=true delete saved screen if available
-				delete[] saved_screen.pixbuf;
-				saved_screen.pixbuf = NULL;
-				firstPaint = true;
-			}
+		dprintf(DEBUG_DEBUG, "[CComponentsItem] %s:\ncc_item_type: %d\ncc_item_index = %d\nheight = %d\nwidth = %d\n", __func__, cc_item_type,  cc_item_index, height, width);
 	}
-
-	is_painted = false;
-}
-
-void CComponentsItem::hide(bool no_restore)
-{
-	hideCCItem(no_restore);
+	paintFbItems(do_save_bg);
 }
 
 //erase or paint over rendered objects
@@ -194,20 +169,6 @@ bool CComponentsItem::isAdded()
 	return false;
 }
 
-inline void CComponentsItem::setXPos(const int& xpos)
-{
-	x = xpos;
-	if (cc_parent)
-		setRealXPos(cc_parent->getRealXPos() + x);
-}
-
-inline void CComponentsItem::setYPos(const int& ypos)
-{
-	y = ypos;
-	if (cc_parent)
-		setRealYPos(cc_parent->getRealYPos() + y);
-}
-
 void CComponentsItem::setXPosP(const uint8_t& xpos_percent)
 {
 	int x_tmp  = cc_parent ? xpos_percent*cc_parent->getWidth() : xpos_percent*frameBuffer->getScreenWidth();
@@ -254,28 +215,3 @@ void CComponentsItem::setFocus(bool focus)
 	}
 	cc_has_focus = focus;
 }
-
-void CComponentsItem::initBodyGradient()
-{
-	if (col_body_gradient && cc_gradientData.gradientBuf && (old_gradient_color != col_body || old_gradient_c2c != g_settings.theme.gradient_c2c)) {
-		free(cc_gradientData.gradientBuf);
-		cc_gradientData.gradientBuf = NULL;
-		if (cc_gradientData.boxBuf) {
-			cs_free_uncached(cc_gradientData.boxBuf);
-			cc_gradientData.boxBuf = NULL;
-		}
-	}
-	if (cc_gradientData.gradientBuf == NULL) {
-		CColorGradient ccGradient;
-		int gsize = cc_body_gradient_direction == CFrameBuffer::gradientVertical ? height : width;
-		if (g_settings.theme.gradient_c2c)
-			cc_gradientData.gradientBuf = ccGradient.gradientColorToColor(col_body, cc_body_gradient_2nd_col, NULL, gsize, cc_body_gradient_mode, cc_body_gradient_intensity);
-		else
-			cc_gradientData.gradientBuf = ccGradient.gradientOneColor(col_body, NULL, gsize, cc_body_gradient_mode, cc_body_gradient_intensity, cc_body_gradient_intensity_v_min, cc_body_gradient_intensity_v_max, cc_body_gradient_saturation);
-		old_gradient_color = col_body;
-		old_gradient_c2c = g_settings.theme.gradient_c2c;
-	}
-
-	cc_gradientData.direction = cc_body_gradient_direction;
-	cc_gradientData.mode = CFrameBuffer::pbrg_noOption;
-}
diff --git a/src/gui/components/cc_item.h b/src/gui/components/cc_item.h
new file mode 100644
index 0000000..a3a7134
--- /dev/null
+++ b/src/gui/components/cc_item.h
@@ -0,0 +1,129 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project 
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_ITEMS__
+#define __CC_ITEMS__
+
+#include "cc_types.h"
+#include "cc_base.h"
+#include "cc_draw.h"
+#include <vector>
+#include <string>
+#include <driver/colorgradient.h>
+
+class CComponentsItem : public CComponents
+{
+	protected:
+		///property: define of item index, all bound items get an index,
+		///default: CC_NO_INDEX as identifer for not embedded item and default index=0 for form as main parent
+		///see also getIndex(), setIndex()
+		int cc_item_index;
+		///property: define of item type, see cc_types.h for possible types
+		int cc_item_type;
+		///property: default enabled
+		bool cc_item_enabled;
+		///property: default not selected
+		bool cc_item_selected;
+		///property: page number, this defines current item page location, means: this item is embedded in a parent container on page number n, see also setPageNumber()
+		///default value is 0 for page one, any value > 0 causes handling for mutilple pages at parent container
+		uint8_t cc_page_number;
+		///specifies that some certain operations especially eg. exec events for that item are possible, see also setFocus(), hasFocus()
+		bool cc_has_focus;
+
+		///Pointer to the form object in which this item is embedded.
+		///Is typically the type CComponentsForm or derived classes, default intialized with NULL
+		CComponentsForm *cc_parent;
+
+		///initialze of basic framebuffer elements with shadow, background and frame.
+		///must be called first in all paint() members before paint any item,
+		///If backround is not required, it's possible to override this with variable paint_bg=false, use doPaintBg(true/false) to set this!
+		///arg do_save_bg=false avoids using of unnecessary pixel memory, eg. if no hide with restore is provided. This is mostly the case  whenever
+		///an item will be hide or overpainted with other methods, or it's embedded  (bound)  in a parent form.
+		void paintInit(bool do_save_bg);
+
+		///add "this" current item to parent
+		void initParent(CComponentsForm* parent);
+
+
+	public:
+		CComponentsItem(CComponentsForm *parent = NULL);
+
+		///sets pointer to the form object in which this item is embedded.
+		virtual void setParent(CComponentsForm *parent){cc_parent = parent;};
+		///returns pointer to the form object in which this item is embedded.
+		virtual CComponentsForm* getParent(){return cc_parent;};
+		///property: returns true if item is added to a form
+		virtual bool isAdded();
+		///indicates wether item has focus
+		virtual bool hasFocus(){return cc_has_focus;}
+		///set or unset focus of item, stand alone items without parent have always set focus to true, inside of a parent form object, always the last added item has focus
+		virtual void setFocus(bool focus);
+
+		///erase or paint over rendered objects without restore of background, it's similar to paintBackgroundBoxRel() known
+		///from CFrameBuffer but with possiblity to define color, default color is 0 (empty background)
+		///NOTE: Items with parent binding use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
+		virtual void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, bool ignore_parent = false);
+
+		///get the current item type, see attribute cc_item_type above
+		virtual int getItemType();
+		///syncronizes item colors with current color settings if required, NOTE: overwrites internal values!
+		virtual void syncSysColors();
+		
+		///set select mode, see also col_frame_sel
+		virtual void setSelected(bool selected){cc_item_selected = selected;};
+		///set enable mode, see also cc_item_enabled
+		virtual void setEnable(bool enabled){cc_item_enabled = enabled;};
+		
+		///get select mode, see also setSelected() above
+		virtual bool isSelected(){return cc_item_selected;};
+		///get enable mode, see also setEnable() above
+		virtual bool isEnabled(){return cc_item_enabled;};
+
+		///get current index of item, see also attribut cc_item_index
+		virtual int getIndex(){return cc_item_index;};
+		///set an index to item, see also attribut cc_item_index.
+		///To generate an index, use genIndex()
+		virtual void setIndex(const int& index){cc_item_index = index;};
+
+		///sets page location of current item, parameter as uint8_t, see: cc_page_number
+		virtual void setPageNumber(const uint8_t& on_page_number){cc_page_number = on_page_number;};
+		///returns current number of page location of current item, see: cc_page_number
+		virtual u_int8_t getPageNumber(){return cc_page_number;};
+
+		///set screen x-position, parameter as uint8_t, percent x value related to current width of parent form or screen
+		virtual void setXPosP(const uint8_t& xpos_percent);
+		///set screen y-position, parameter as uint8_t, percent y value related to current height of parent form or screen
+		virtual void setYPosP(const uint8_t& ypos_percent);
+		///set x and y position as percent value related to current parent form or screen dimensions at once
+		virtual void setPosP(const uint8_t& xpos_percent, const uint8_t& ypos_percent);
+
+		///do center item on screen or within a parent form, parameter along_mode assigns direction of centering
+		virtual void setCenterPos(int along_mode = CC_ALONG_X | CC_ALONG_Y);
+
+		///set item height, parameter as uint8_t, as percent value related to current height of parent form or screen
+		virtual void setHeightP(const uint8_t& h_percent);
+		///set item width, parameter as uint8_t, as percent value related to current width of parent form or screen
+		virtual void setWidthP(const uint8_t& w_percent);
+};
+
+#endif
diff --git a/src/gui/components/cc_item_infobox.cpp b/src/gui/components/cc_item_infobox.cpp
index 676a1db..01a03fb 100644
--- a/src/gui/components/cc_item_infobox.cpp
+++ b/src/gui/components/cc_item_infobox.cpp
@@ -43,7 +43,7 @@ CComponentsInfoBox::CComponentsInfoBox(	const int& x_pos,
 					const int mode,
 					Font* font_text,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_text,
 					fb_pixel_t color_frame,
 					fb_pixel_t color_body,
@@ -55,7 +55,7 @@ CComponentsInfoBox::CComponentsInfoBox(	const int& x_pos,
 	y 		= y_pos;
 	width 		= w;
 	height	 	= h;
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	col_frame 	= color_frame;
 	col_body	= color_body;
 	col_shadow	= color_shadow;
@@ -110,7 +110,7 @@ void CComponentsInfoBox::paintPicture()
 	pic->setColorBody(col_body);
 
 	//set gradient behavior of pic object
-	if (col_body_gradient)
+	if (cc_body_gradient_enable)
 		pic->doPaintBg(false);
 
 	//fit icon into frame
@@ -150,7 +150,7 @@ void CComponentsInfoBox::paint(bool do_save_bg)
 	cctext->doPaintTextBoxBg(ct_paint_textbg);
 	cctext->doPaintBg(false);
 	cctext->setTextColor(ct_col_text);
-	cctext->enableTboxSaveScreen(save_tbox_screen);
+	cctext->enableTboxSaveScreen(cc_txt_save_screen);
 
 	//calculate vars for x-position and dimensions
 	int tx = x_offset + x_text + pic_w;
diff --git a/src/gui/components/cc_item_infobox.h b/src/gui/components/cc_item_infobox.h
index 6a86a6d..189dbb4 100644
--- a/src/gui/components/cc_item_infobox.h
+++ b/src/gui/components/cc_item_infobox.h
@@ -32,6 +32,7 @@
 
 #include "cc_item_text.h"
 #include "cc_item_picture.h"
+#include "cc_item.h"
 #include <string>
 
 //! Sub class of CComponentsItem. Shows box with text and optional icon on screen.
@@ -69,7 +70,7 @@ class CComponentsInfoBox : public CComponentsText
 					const int mode = CTextBox::AUTO_WIDTH,
 					Font* font_text = NULL,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_text = COL_MENUCONTENT_TEXT,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
@@ -78,13 +79,11 @@ class CComponentsInfoBox : public CComponentsText
 		~CComponentsInfoBox();
 
 		///set property: space around fram and beetween picture and textbox
-		inline void setSpaceOffset(const int offset){x_offset = offset;};
+		void setSpaceOffset(const int offset){x_offset = offset;};
 		///set property: path or name of displayed image, parameter as string
 		void setPicture(const std::string& picture_name);
 		///set property: path or name of displayed image, parameter as const char*
 		void setPicture(const char* picture_name);
-		///set property: gradient behavior
-		void enableGradient(bool enable) { col_body_gradient = enable; }
 		///paint item
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 };
diff --git a/src/gui/components/cc_item_picture.cpp b/src/gui/components/cc_item_picture.cpp
index 3dc5a60..78ad584 100644
--- a/src/gui/components/cc_item_picture.cpp
+++ b/src/gui/components/cc_item_picture.cpp
@@ -44,26 +44,26 @@ using namespace std;
 CComponentsPicture::CComponentsPicture(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 					const std::string& image_name,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_background, fb_pixel_t color_shadow, int transparent)
 {
-	init(x_pos, y_pos, w, h, image_name, parent, has_shadow, color_frame, color_background, color_shadow, transparent, SCALE);
+	init(x_pos, y_pos, w, h, image_name, parent, shadow_mode, color_frame, color_background, color_shadow, transparent, SCALE);
 }
 
 CComponentsPicture::CComponentsPicture(	const int &x_pos, const int &y_pos,
 					const std::string& image_name,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_frame, fb_pixel_t color_background, fb_pixel_t color_shadow, int transparent)
 {
-	init(x_pos, y_pos, 0, 0, image_name, parent, has_shadow, color_frame, color_background, color_shadow, transparent, NO_SCALE);
+	init(x_pos, y_pos, 0, 0, image_name, parent, shadow_mode, color_frame, color_background, color_shadow, transparent, NO_SCALE);
 }
 
 
 void CComponentsPicture::init(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 				const string& image_name,
 				CComponentsForm *parent,
-				bool has_shadow,
+				int shadow_mode,
 				fb_pixel_t color_frame, fb_pixel_t color_background, fb_pixel_t color_shadow, int transparent,
 				bool allow_scale)
 {
@@ -75,17 +75,19 @@ void CComponentsPicture::init(	const int &x_pos, const int &y_pos, const int &w,
 	y 		= y_pos;
 	width	= dx	= w;
 	height	= dy	= h;
-	pic_name 	= image_name;
-	shadow		= has_shadow;
+	pic_name = pic_name_old = image_name;
+	shadow		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
 	col_body	= color_background;
 	col_shadow	= color_shadow;
 	do_scale	= allow_scale;
-
+	image_cache	= NULL; //image
+	enable_cache	= false;
 	is_image_painted= false;
 	do_paint	= true;
 	image_transparent = transparent;
+	cc_paint_cache	= false; //bg
 	keep_dx_aspect 	= false;
 	keep_dy_aspect	= false;
 
@@ -93,8 +95,19 @@ void CComponentsPicture::init(	const int &x_pos, const int &y_pos, const int &w,
 	initParent(parent);
 }
 
+void CComponentsPicture::clearCache()
+{
+	if (image_cache){
+		delete[] image_cache;
+		image_cache = NULL;
+	}
+}
+
 void CComponentsPicture::setPicture(const std::string& picture_name)
 {
+	if (pic_name == picture_name)
+		return;
+	clearCache();
 	pic_name = picture_name;
 	initCCItem();
 }
@@ -157,6 +170,9 @@ void CComponentsPicture::initCCItem()
 	if (width == dx && height == dy)
 		return;
 
+	//clean up possible cache on changed dimensions
+	clearCache();
+
 	//temporarily vars
 	int w_2scale = width;
 	int h_2scale = height;
@@ -210,11 +226,17 @@ int CComponentsPicture::getHeight()
 
 void CComponentsPicture::paintPicture()
 {
+	struct timeval t1, t2;
+	if (debug)
+		gettimeofday(&t1, NULL);
+
 	is_image_painted = false;
 	//initialize image position
 	int x_pic = x;
 	int y_pic = y;
 	initPosition(&x_pic, &y_pic);
+	x_pic += fr_thickness;
+	y_pic += fr_thickness;
 	initCCItem();
 
 	if (pic_name.empty())
@@ -222,12 +244,26 @@ void CComponentsPicture::paintPicture()
 
 	if (cc_allow_paint){
 		dprintf(DEBUG_INFO, "[CComponentsPicture] %s: paint image file: pic_name=%s\n", __func__, pic_name.c_str());
-		frameBuffer->SetTransparent(image_transparent);
-		if (do_scale)
-			is_image_painted = g_PicViewer->DisplayImage(pic_name, x_pic, y_pic, width, height);
-		else
-			is_image_painted = frameBuffer->paintIcon(pic_name, x_pic, y_pic, height, 1, do_paint, paint_bg, col_body);
-		frameBuffer->SetTransparentDefault();
+		if (image_cache == NULL){
+			frameBuffer->SetTransparent(image_transparent);
+			if (do_scale)
+				is_image_painted = g_PicViewer->DisplayImage(pic_name, x_pic, y_pic, width-2*fr_thickness, height-2*fr_thickness);
+			else
+				is_image_painted = frameBuffer->paintIcon(pic_name, x_pic, y_pic, height, 1, do_paint, paint_bg, col_body);
+			frameBuffer->SetTransparentDefault();
+			if (enable_cache)
+				image_cache = getScreen(x_pic, y_pic, width, height);
+		}else{
+			frameBuffer->RestoreScreen(x_pic, y_pic, width, height, image_cache);
+		}
+	}
+
+	//benchmark
+	if (debug){
+		gettimeofday(&t2, NULL);
+		uint64_t duration = ((t2.tv_sec * 1000000ULL + t2.tv_usec) - (t1.tv_sec * 1000000ULL + t1.tv_usec)) / 1000ULL;
+		if (duration)
+			fprintf(stderr, "\033[33m[CComponentsPicture] %s: %llu ms to paint image \033[0m\n",	__func__, duration);
 	}
 }
 
@@ -239,21 +275,34 @@ void CComponentsPicture::paint(bool do_save_bg)
 	paintPicture();
 }
 
-void CComponentsPicture::hide(bool no_restore)
+void CComponentsPicture::hide()
 {
-	hideCCItem(no_restore);
+	CComponents::hide();
 	is_image_painted = false;
 }
 
+bool CComponentsPicture::hasChanges()
+{
+	bool ret = false;
+	if (pic_name != pic_name_old){
+		pic_name_old = pic_name;
+		ret = true;
+	}
+	if (CCDraw::hasChanges())
+		ret = true;
+
+	return ret;
+}
+
 
 CComponentsChannelLogo::CComponentsChannelLogo( const int &x_pos, const int &y_pos, const int &w, const int &h,
 						const std::string& channelName,
 						const uint64_t& channelId,
 						CComponentsForm *parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_background, fb_pixel_t color_shadow, int transparent)
 						:CComponentsPicture(x_pos, y_pos, w, h,
-						"", parent, has_shadow,
+						"", parent, shadow_mode,
 						color_frame, color_background, color_shadow, transparent)
 {
 	init(channelId, channelName, SCALE);
@@ -263,10 +312,10 @@ CComponentsChannelLogo::CComponentsChannelLogo( const int &x_pos, const int &y_p
 						const std::string& channelName,
 						const uint64_t& channelId,
 						CComponentsForm *parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_background, fb_pixel_t color_shadow, int transparent)
 						:CComponentsPicture(x_pos, y_pos, 0, 0,
-						"", parent, has_shadow,
+						"", parent, shadow_mode,
 						color_frame, color_background, color_shadow, transparent)
 {
 	init(channelId, channelName, NO_SCALE);
diff --git a/src/gui/components/cc_item_picture.h b/src/gui/components/cc_item_picture.h
index 4915e5e..2ca4639 100644
--- a/src/gui/components/cc_item_picture.h
+++ b/src/gui/components/cc_item_picture.h
@@ -32,6 +32,7 @@
 #endif
 
 #include "cc_base.h"
+#include "cc_item.h"
 #include <string>
 #include <driver/pictureviewer/pictureviewer.h>
 
@@ -49,11 +50,16 @@ class CComponentsPicture : public CComponentsItem
 		///possible image formats
 		std::vector<std::string> v_ext;
 
+		///option to enable disable cache, default = false
+		bool enable_cache;
+		///screen cache content for painted image
+		fb_pixel_t *image_cache;
+
 		///current original image dimensions
 		int dx, dy;
 
 		///property: name of image (without extensionn) full path to image (with extension), icon names to find in /widget/icons.h, icons will paint never scaled
-		std::string pic_name;
+		std::string pic_name, pic_name_old;
  
 		///indicate that image was sucessful painted
 		bool is_image_painted;
@@ -73,7 +79,7 @@ class CComponentsPicture : public CComponentsItem
 		void init(	const int &x_pos, const int &y_pos, const int &w, const int &h,
 				const std::string& image_name,
 				CComponentsForm *parent,
-				bool has_shadow,
+				int shadow_mode,
 				fb_pixel_t color_frame,
 				fb_pixel_t color_background,
 				fb_pixel_t color_shadow,
@@ -104,7 +110,7 @@ class CComponentsPicture : public CComponentsItem
 		CComponentsPicture( 	const int &x_pos, const int &y_pos, const int &w, const int &h,
 					const std::string& image_name,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_background = 0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
@@ -120,11 +126,15 @@ class CComponentsPicture : public CComponentsItem
 		CComponentsPicture( 	const int &x_pos, const int &y_pos,
 					const std::string& image_name,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_background = 0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
 					int transparent = CFrameBuffer::TM_NONE);
+		virtual~CComponentsPicture()
+		{
+			delete[]image_cache;
+		}
 
 		///sets an image name (unscaled icons only), full image path or url to an image file
 		virtual void setPicture(const std::string& picture_name);
@@ -152,8 +162,17 @@ class CComponentsPicture : public CComponentsItem
 
 		///paint item
 		virtual void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
-		///hide item
-		virtual void hide(bool no_restore = false);
+		///hide item, see also CComponents::hide();
+		virtual void hide();
+
+		virtual bool hasChanges();
+
+		///remove possible cache
+		virtual void clearCache();
+		///enable/disable image cache
+		virtual void enableCache(bool enable = true){if (enable_cache == enable) return; enable_cache = enable; if (!enable_cache) clearCache();}
+		///disable image cache, makes clean up too
+		virtual void disableCache(){enableCache(false);}
 };
 
 class 	CComponentsPictureScalable : public CComponentsPicture
@@ -166,12 +185,12 @@ class 	CComponentsPictureScalable : public CComponentsPicture
 		CComponentsPictureScalable( 	const int &x_pos, const int &y_pos,
 						const std::string& image_name,
 						CComponentsForm *parent = NULL,
-						bool has_shadow = CC_SHADOW_OFF,
+						int shadow_mode = CC_SHADOW_OFF,
 						fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 						fb_pixel_t color_background = 0,
 						fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
 						int transparent = CFrameBuffer::TM_NONE)
-						: CComponentsPicture(x_pos, y_pos, 0, 0, image_name, parent, has_shadow, color_frame, color_background, color_shadow, transparent){};
+						: CComponentsPicture(x_pos, y_pos, 0, 0, image_name, parent, shadow_mode, color_frame, color_background, color_shadow, transparent){};
 };
 
 class CComponentsChannelLogo : public CComponentsPicture
@@ -201,7 +220,7 @@ class CComponentsChannelLogo : public CComponentsPicture
 					const std::string& channelName = "",
 					const uint64_t& channelId =0,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_background = 0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
@@ -217,7 +236,7 @@ class CComponentsChannelLogo : public CComponentsPicture
 					const std::string& channelName = "",
 					const uint64_t& channelId =0,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_background = 0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
@@ -249,12 +268,12 @@ class 	CComponentsChannelLogoScalable : public CComponentsChannelLogo
 						const std::string& channelName = "",
 						const uint64_t& channelId =0,
 						CComponentsForm *parent = NULL,
-						bool has_shadow = CC_SHADOW_OFF,
+						int shadow_mode = CC_SHADOW_OFF,
 						fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 						fb_pixel_t color_background = 0,
 						fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
 						int transparent = CFrameBuffer::TM_BLACK)
-						: CComponentsChannelLogo(x_pos, y_pos, 0, 0, channelName, channelId, parent, has_shadow, color_frame, color_background, color_shadow, transparent){};
+						: CComponentsChannelLogo(x_pos, y_pos, 0, 0, channelName, channelId, parent, shadow_mode, color_frame, color_background, color_shadow, transparent){};
 };
 
 #endif
diff --git a/src/gui/components/cc_item_progressbar.cpp b/src/gui/components/cc_item_progressbar.cpp
index 0ddb9ef..e0e1afb 100644
--- a/src/gui/components/cc_item_progressbar.cpp
+++ b/src/gui/components/cc_item_progressbar.cpp
@@ -30,7 +30,7 @@
 #include <math.h>
 #include <global.h>
 #include <neutrino.h>
-
+#include <system/debug.h>
 #include "cc_item_progressbar.h"
 #define ITEMW 4
 #define POINT 2
@@ -39,10 +39,18 @@
 #define GREEN  0x00FF00
 #define YELLOW 0xFFFF00
 
-CProgressBar::CProgressBar(	const int x_pos, const int y_pos, const int w, const int h,
-				fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow,
-				const fb_pixel_t active_col, const fb_pixel_t passive_col,
-				const int r, const int g, const int b,
+CProgressBar::CProgressBar(	const int x_pos,
+				const int y_pos,
+				const int w,
+				const int h,
+				fb_pixel_t color_frame,
+				fb_pixel_t color_body,
+				fb_pixel_t color_shadow,
+				const fb_pixel_t active_col,
+				const fb_pixel_t passive_col,
+				const int R,
+				const int G,
+				const int Y,
 				CComponentsForm *parent)
 {
 	//CComponentsItem
@@ -58,9 +66,9 @@ CProgressBar::CProgressBar(	const int x_pos, const int y_pos, const int w, const
 	col_body	= color_body;
 	col_shadow	= color_shadow;
 
-	pb_red 		= r;
-	pb_green 	= g;
-	pb_yellow 	= b;
+	pb_red 		= R;
+	pb_green 	= G;
+	pb_yellow 	= Y;
 	pb_active_col	= active_col;
 	pb_passive_col 	= passive_col;
 
@@ -80,6 +88,7 @@ CProgressBar::CProgressBar(	const int x_pos, const int y_pos, const int w, const
 	pb_height		= 0;
 	pb_start_x_passive 	= 0;
 	pb_passive_width 	= width;
+	cc_paint_cache		= false;
 	initParent(parent);
 }
 
@@ -124,94 +133,122 @@ class CProgressBarCache
 {
 	private:
 		// keys to lookup:
-		int pb_height, pb_width;
-		int pb_active_col, pb_passive_col;
-		int design;
-		bool pb_invert, gradient;
-		int pb_red, pb_yellow, pb_green;
-
+		int pbc_height, pbc_width;
+		int pbc_active_col, pbc_passive_col;
+		int pbc_design;
+		bool pbc_invert, pbc_gradient;
+		int pbc_red, pbc_green, pbc_yellow;
 		int yoff;
 
-		fb_pixel_t *active, *passive;
+		fb_pixel_t *pbc_active, *pbc_passive;
+ ;
 
 		static inline unsigned int make16color(__u32 rgb){return 0xFF000000 | rgb;};
-		void paintBoxRel(fb_pixel_t *b, int x, int y, int dx, int dy, fb_pixel_t col);
-		void applyGradient(fb_pixel_t *buf);
-		void createBitmaps();
 
-		CProgressBarCache(int _height, int _width, int _pb_active_col, int _pb_passive_col, int _design, bool _invert, bool _gradient, int _red, int _yellow, int _green)
-			: pb_height(_height), pb_width(_width), pb_active_col(_pb_active_col), pb_passive_col(_pb_passive_col), design(_design), pb_invert(_invert), gradient(_gradient),
-			  pb_red(_red), pb_yellow(_yellow), pb_green(_green), yoff(0)
+		void pbcPaintBoxRel(int x, int y, int dx, int dy, fb_pixel_t *pixbuf, fb_pixel_t col);
+		void pbcApplyGradient(fb_pixel_t *pixbuf);
+		void pbcCreateBitmaps();
+
+		CProgressBarCache(	int dy,
+					int dx,
+					int active_col,
+					int passive_col,
+					int design,
+					bool enable_invert,
+					bool enable_gradient,
+					int R,
+					int G,
+					int Y)
+						: pbc_height(dy),
+						pbc_width(dx),
+						pbc_active_col(active_col),
+						pbc_passive_col(passive_col),
+						pbc_design(design),
+						pbc_invert(enable_invert),
+						pbc_gradient(enable_gradient),
+						pbc_red(R),
+						pbc_green(G),
+						pbc_yellow(Y),
+						yoff(0)
 		{
 			if (pbCache.size() > 10)
-				clear();
-			createBitmaps();
+				pbcClear();
+			pbcCreateBitmaps();
 		}
-		void clear();
+		void pbcClear();
 	public:
-		void paint(int x, int y, int pb_active_width, int pb_passive_width);
-		static CProgressBarCache *lookup(int _height, int _width, int _pb_active_col, int _pb_passive_col, int _design, bool _invert, bool _gradient, int _red, int _yellow, int _green);
+		void pbcPaint(int x, int y, int pbc_active_width, int pbc_passive_width);
+		static CProgressBarCache *pbcLookup(	int dy,
+							int dx,
+							int active_col,
+							int passive_col,
+							int design,
+							bool enable_invert,
+							bool enable_gradient,
+							int R,
+							int G,
+							int Y);
 };
 
-void CProgressBarCache::clear()
+void CProgressBarCache::pbcClear()
 {
 	for (std::vector<CProgressBarCache *>::iterator it = pbCache.begin(); it != pbCache.end(); ++it) {
-		if ((*it)->active)
-			free((*it)->active);
-		if ((*it)->passive)
-			free((*it)->passive);
+		if ((*it)->pbc_active)
+			free((*it)->pbc_active);
+		if ((*it)->pbc_passive)
+			free((*it)->pbc_passive);
 	}
 	pbCache.clear();
 }
 
-CProgressBarCache *CProgressBarCache::lookup(int _height, int _width, int _pb_active_col, int _pb_passive_col, int _design, bool _invert, bool _gradient, int _red, int _yellow, int _green)
+CProgressBarCache *CProgressBarCache::pbcLookup(int dy, int dx, int active_col, int passive_col, int design, bool enable_invert, bool enable_gradient, int R, int G, int Y)
 {
 	// sanitize
-	if (_design == CProgressBar::PB_MONO)
-		_red = _yellow = _green = 0;
+	if (design == CProgressBar::PB_MONO)
+		R = G = Y = 0;
 
 	// lookup
 	std::vector<CProgressBarCache *>::iterator it = pbCache.begin();
-	for (; it != pbCache.end() && ((*it)->pb_height != _height || (*it)->pb_width != _width ||
-				       (*it)->pb_active_col != _pb_active_col || (*it)->pb_passive_col != _pb_passive_col ||
-				       (*it)->design != _design || (*it)->pb_invert != _invert || (*it)->gradient != _gradient ||
-				       (*it)->pb_red != _red || (*it)->pb_yellow != _yellow || (*it)->pb_green != _green); ++it);
+	for (; it != pbCache.end() && ((*it)->pbc_height != dy || (*it)->pbc_width != dx ||
+				       (*it)->pbc_active_col != active_col || (*it)->pbc_passive_col != passive_col ||
+				       (*it)->pbc_design != design || (*it)->pbc_invert != enable_invert || (*it)->pbc_gradient != enable_gradient ||
+				       (*it)->pbc_red != R || (*it)->pbc_yellow != Y || (*it)->pbc_green != G); ++it);
 	if (it != pbCache.end())
 		return *it;
 
-	CProgressBarCache *pbc = new CProgressBarCache(_height, _width, _pb_active_col, _pb_passive_col, _design, _invert, _gradient, _red, _yellow, _green);
+	CProgressBarCache *pbc = new CProgressBarCache(dy, dx, active_col, passive_col, design, enable_invert, enable_gradient, R, G, Y);
 	pbCache.push_back(pbc);
 	return pbc;
 }
 
-void CProgressBarCache::paint(int x, int y, int pb_active_width, int pb_passive_width)
+void CProgressBarCache::pbcPaint(int x, int y, int pbc_active_width, int pbc_passive_width)
 {
 	y += yoff;
 	static CFrameBuffer *frameBuffer = CFrameBuffer::getInstance();
 	unsigned int stride = frameBuffer->getStride() / sizeof(fb_pixel_t);
 	fb_pixel_t *p = frameBuffer->getFrameBufferPointer() + y * stride + x;
-	int off = stride - pb_width;
-	if (pb_active_width > pb_width)
-		pb_active_width = pb_width;
-	if (pb_active_width + pb_passive_width != pb_width)
-		pb_passive_width = pb_width - pb_active_width;
-	fb_pixel_t *ap = active;
-	fb_pixel_t *pp = passive;
-	for (int h = 0; h < pb_height; h++) {
+	int off = stride - pbc_width;
+	if (pbc_active_width > pbc_width)
+		pbc_active_width = pbc_width;
+	if (pbc_active_width + pbc_passive_width != pbc_width)
+		pbc_passive_width = pbc_width - pbc_active_width;
+	fb_pixel_t *ap = pbc_active;
+	fb_pixel_t *pp = pbc_passive;
+	for (int h = 0; h < pbc_height; h++) {
 		int w = 0;
-		for (; w < pb_active_width; w++, p++, ap++)
+		for (; w < pbc_active_width; w++, p++, ap++)
 			if (*ap)
 				*p = *ap;
-		pp += pb_active_width;
-		for (; w < pb_width; w++, p++, pp++)
+		pp += pbc_active_width;
+		for (; w < pbc_width; w++, p++, pp++)
 			if (*pp)
 				*p = *pp;
-		ap += pb_passive_width;
+		ap += pbc_passive_width;
 		p += off;
 	}
 }
 
-void CProgressBarCache::paintBoxRel(fb_pixel_t *b, int x, int y, int dx, int dy, fb_pixel_t col)
+void CProgressBarCache::pbcPaintBoxRel(int x, int y, int dx, int dy, fb_pixel_t *pixbuf, fb_pixel_t col)
 {
 	if (x < 0) {
 		dx -= x;
@@ -221,80 +258,80 @@ void CProgressBarCache::paintBoxRel(fb_pixel_t *b, int x, int y, int dx, int dy,
 		dy -= y;
 		y = 0;
 	}
-	if (x + dx > pb_width)
-		dx = pb_width - x;
-	if (y + dy > pb_height)
-		dy = pb_height - y;
+	if (x + dx > pbc_width)
+		dx = pbc_width - x;
+	if (y + dy > pbc_height)
+		dy = pbc_height - y;
 	if (dx < 1 || dy < 1)
 		return;
-	b += pb_width * y + x;
-	fb_pixel_t *e = b + pb_width * (dy - 1) + dx;
-	int off = pb_width - dx;
-	while (b < e) {
-		fb_pixel_t *ex = b + dx;
-		while (b < ex)
-			*b++ = col;
-		b += off;
+	pixbuf += pbc_width * y + x;
+	fb_pixel_t *e = pixbuf + pbc_width * (dy - 1) + dx;
+	int off = pbc_width - dx;
+	while (pixbuf < e) {
+		fb_pixel_t *ex = pixbuf + dx;
+		while (pixbuf < ex)
+			*pixbuf++ = col;
+		pixbuf += off;
 	}
 }
 
-void CProgressBarCache::createBitmaps()
+void CProgressBarCache::pbcCreateBitmaps()
 {
-	active = (fb_pixel_t *) calloc(1, pb_width * pb_height * sizeof(fb_pixel_t));
-	if (!active)
+	pbc_active = (fb_pixel_t *) calloc(1, pbc_width * pbc_height * sizeof(fb_pixel_t));
+	if (!pbc_active)
 		return;
-	passive = (fb_pixel_t *) calloc(1, pb_width * pb_height * sizeof(fb_pixel_t));
-	if (!passive) {
-		free(active);
+	pbc_passive = (fb_pixel_t *) calloc(1, pbc_width * pbc_height * sizeof(fb_pixel_t));
+	if (!pbc_passive) {
+		free(pbc_active);
 		return;
 	}
 
 	int itemw = ITEMW, itemh = ITEMW, pointx = POINT, pointy = POINT;
-	switch (design){
+	switch (pbc_design){
 		default:
 		case CProgressBar::PB_MONO:	// monochrome
-			paintBoxRel(active,  0, 0, pb_width, pb_height, pb_active_col );
-			paintBoxRel(passive, 0, 0, pb_width, pb_height, pb_passive_col);
-			if (gradient) {
-				applyGradient(active);
-				applyGradient(passive);
+			pbcPaintBoxRel(0, 0, pbc_width, pbc_height, pbc_active, pbc_active_col);
+			pbcPaintBoxRel(0, 0, pbc_width, pbc_height, pbc_passive, pbc_passive_col);
+			if (pbc_gradient) {
+				pbcApplyGradient(pbc_active);
+				pbcApplyGradient(pbc_passive);
 			}
 			return;
 		case CProgressBar::PB_MATRIX: // ::::: matrix
 			break;
 		case CProgressBar::PB_LINES_V: // ||||| vert. lines
-			itemh = pb_height;
-			pointy = pb_height;
+			itemh = pbc_height;
+			pointy = pbc_height;
 			break;
 		case CProgressBar::PB_LINES_H: // ===== horiz. lines
 			itemw = POINT;
 			break;
 		case CProgressBar::PB_COLOR: // filled color
 			itemw = 1;
-			itemh = pb_height;
-			pointy = pb_height;
+			itemh = pbc_height;
+			pointy = pbc_height;
 			break;
 	}
 
 	const int spc = itemh - pointy;			/* space between horizontal lines / points */
-	int hcnt = (pb_height + spc) / itemh;		/* how many POINTs is the bar high */
-	yoff = (pb_height + spc - itemh * hcnt) / 2;
+	int hcnt = (pbc_height + spc) / itemh;		/* how many POINTs is the bar high */
+	yoff = (pbc_height + spc - itemh * hcnt) / 2;
 
 	int i = 0;
 
 	int sh_x = 0;
 	/* red, yellow, green are given in percent */
-	int rd = pb_red    * pb_width / (100 * itemw);	/* how many POINTs red */
-	int yw = pb_yellow * pb_width / (100 * itemw);	/* how many POINTs yellow */
-	int gn = pb_green  * pb_width / (100 * itemw);	/* how many POINTs green */
+	int rd = pbc_red    * pbc_width / (100 * itemw);	/* how many POINTs red */
+	int yw = pbc_yellow * pbc_width / (100 * itemw);	/* how many POINTs yellow */
+	int gn = pbc_green  * pbc_width / (100 * itemw);	/* how many POINTs green */
 
 	// fixup rounding errors
-	while ((rd + yw + gn) * itemw < pb_width) {
+	while ((rd + yw + gn) * itemw < pbc_width) {
 		if (gn)
 			gn++;
-		if (yw && ((rd + yw + gn) * itemw < pb_width))
+		if (yw && ((rd + yw + gn) * itemw < pbc_width))
 			yw++;
-		if (rd && ((rd + yw + gn) * itemw < pb_width))
+		if (rd && ((rd + yw + gn) * itemw < pbc_width))
 			rd++;
 	}
 
@@ -310,7 +347,7 @@ void CProgressBarCache::createBitmaps()
 		fb_pixel_t color = make16color(rgb);
 		int sh_y = 0;
 		for (int j = 0; j < hcnt; j++, sh_y += itemh)
-			paintBoxRel(active, sh_x, sh_y, pointx, pointy, color);
+			pbcPaintBoxRel(sh_x, sh_y, pointx, pointy, pbc_active, color);
 	}
 	step = yw - rd - 1;
 	if (step < 1)
@@ -321,7 +358,7 @@ void CProgressBarCache::createBitmaps()
 		fb_pixel_t color = make16color(rgb);
 		int sh_y = 0;
 		for (int j = 0; j < hcnt; j++, sh_y += itemh)
-			paintBoxRel(active, sh_x, sh_y, pointx, pointy, color);
+			pbcPaintBoxRel(sh_x, sh_y, pointx, pointy, pbc_active, color);
 	}
 	int off = diff;
 	b = 0;
@@ -334,12 +371,12 @@ void CProgressBarCache::createBitmaps()
 		fb_pixel_t color = make16color(rgb);
 		int sh_y = 0;
 		for (int j = 0; j < hcnt; j++, sh_y += itemh)
-			paintBoxRel(active, sh_x, sh_y, pointx, pointy, color);
+			pbcPaintBoxRel(sh_x, sh_y, pointx, pointy, pbc_active, color);
 	}
-	if (pb_invert) {
-		for (int l = 0; l < pb_height; l++) {
-			fb_pixel_t *as = active + l * pb_width;
-			fb_pixel_t *ae = as + pb_width - 1;
+	if (pbc_invert) {
+		for (int l = 0; l < pbc_height; l++) {
+			fb_pixel_t *as = pbc_active + l * pbc_width;
+			fb_pixel_t *ae = as + pbc_width - 1;
 			for (; as < ae; as++, ae--) {
 				fb_pixel_t t = *as;
 				*as = *ae;
@@ -348,11 +385,11 @@ void CProgressBarCache::createBitmaps()
 		}
 	}
 
-	if (gradient)
-		applyGradient(active);
+	if (pbc_gradient)
+		pbcApplyGradient(pbc_active);
 
-	fb_pixel_t *a = active, *p = passive;
-	fb_pixel_t *end = a + pb_width * pb_height;
+	fb_pixel_t *a = pbc_active, *p = pbc_passive;
+	fb_pixel_t *end = a + pbc_width * pbc_height;
 	for (; a < end; a++, p++) {
 		fb_pixel_t q = *a;
 		unsigned int gray = ((q & 0xff) + ((q >> 8) & 0xff) + ((q >> 16) & 0xff)) / 3;
@@ -367,17 +404,17 @@ void CProgressBarCache::createBitmaps()
 	}
 }
 
-void CProgressBarCache::applyGradient(fb_pixel_t *b)
+void CProgressBarCache::pbcApplyGradient(fb_pixel_t *b)
 {
-	for (int y = 0; y < pb_height; y++) {
-		int _o = y * pb_width;
+	for (int y = 0; y < pbc_height; y++) {
+		int _o = y * pbc_width;
 		fb_pixel_t last_old = 0;
 		fb_pixel_t last_new = 0;
-		for (int _x = pb_width - 1; _x > -1; _x--) {
+		for (int _x = pbc_width - 1; _x > -1; _x--) {
 			fb_pixel_t &v = *(b + _o + _x);
 			if (v != last_old) {
 				last_old = v;
-				double s = sin((y + .5) * M_PI / pb_height) * .8 + .2;
+				double s = sin((y + .5) * M_PI / pbc_height) * .8 + .2;
 				float fr = float(((last_old >> 16) & 0xff) * s + 0.5);
 				float fg = float(((last_old >>  8) & 0xff) * s + 0.5);
 				float fb = float(((last_old      ) & 0xff) * s + 0.5);
@@ -393,6 +430,10 @@ void CProgressBarCache::applyGradient(fb_pixel_t *b)
 
 void CProgressBar::paintProgress(bool do_save_bg)
 {
+	struct timeval t1, t2;
+	if (debug)
+		gettimeofday(&t1, NULL);
+
 	if (*pb_design == PB_OFF) {
 		paintInit(false);
 		return;
@@ -424,15 +465,23 @@ void CProgressBar::paintProgress(bool do_save_bg)
 
 	if (cc_allow_paint){
 		if (pb_active_width != pb_last_width) {
-			CProgressBarCache *pbc = CProgressBarCache::lookup(pb_height, pb_max_width, pb_active_col, pb_passive_col, *pb_design, pb_invert, *pb_gradient, pb_red, pb_yellow, pb_green);
+			CProgressBarCache *pbc = CProgressBarCache::pbcLookup(pb_height, pb_max_width, pb_active_col, pb_passive_col, *pb_design, pb_invert, *pb_gradient, pb_red, pb_yellow, pb_green);
 			if (pbc)
-				pbc->paint(pb_x, pb_y, pb_active_width, pb_passive_width);
+				pbc->pbcPaint(pb_x, pb_y, pb_active_width, pb_passive_width);
 			is_painted = true;
 		}
 	}
 
 	if (is_painted)
 		pb_last_width = pb_active_width;
+
+	//benchmark
+	if (debug){
+		gettimeofday(&t2, NULL);
+		uint64_t duration = ((t2.tv_sec * 1000000ULL + t2.tv_usec) - (t1.tv_sec * 1000000ULL + t1.tv_usec)) / 1000ULL;
+		if (duration)
+			fprintf(stderr, "\033[33m[CProgressBar] %s: %llu ms to paint progress \033[0m\n",__func__, duration);
+	}
 }
 
 
diff --git a/src/gui/components/cc_item_progressbar.h b/src/gui/components/cc_item_progressbar.h
index 4901f12..c3bcb40 100644
--- a/src/gui/components/cc_item_progressbar.h
+++ b/src/gui/components/cc_item_progressbar.h
@@ -50,7 +50,7 @@
 
 #include "config.h"
 #include "cc_base.h"
-
+#include "cc_item.h"
 #include <string>
 
 class CProgressBar : public CComponentsItem
@@ -91,14 +91,21 @@ class CProgressBar : public CComponentsItem
 		///parameters:
 		///x_pos, y_pos, w, h: position and dimension in pixel
 		///w, h: width / height of bar. Can later be set with paintProgressbar.
-		///r, g, b: percentage of the bar where red/green/yellow is used, only used for colored designs
+		///R, G, Y: percentage of the bar where red/green/yellow is used, only used for colored designs
 		///active_col, passive_col: sets colors for displayed values, activ_col means the the displayed progress
 		///color_frame, color_body, color_shadow: colores of progressbar for frame, body and shadow, Note: color of frame is ineffective on fr_thickness = 0
-		CProgressBar(	const int x_pos = 0, const int y_pos = 0,
-				const int w = -1, const int h = -1,
-				fb_pixel_t color_frame = 0, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
-				const fb_pixel_t active_col = COL_INFOBAR_PLUS_7, const fb_pixel_t passive_col = COL_INFOBAR_PLUS_3,
-				const int r = 40, const int g = 100, const int b =70,
+		CProgressBar(	const int x_pos = 0,
+				const int y_pos = 0,
+				const int w = -1,
+				const int h = -1,
+				fb_pixel_t color_frame = 0,
+				fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
+				fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0,
+				const fb_pixel_t active_col = COL_INFOBAR_PLUS_7,
+				const fb_pixel_t passive_col = COL_INFOBAR_PLUS_3,
+				const int R = 40,
+				const int G = 100,
+				const int Y = 70,
 				CComponentsForm *parent = NULL);
 
 
diff --git a/src/gui/components/cc_item_shapes.cpp b/src/gui/components/cc_item_shapes.cpp
index c4acb65..d6c623b 100644
--- a/src/gui/components/cc_item_shapes.cpp
+++ b/src/gui/components/cc_item_shapes.cpp
@@ -37,17 +37,17 @@ using namespace std;
 //sub class CComponentsShapeSquare from CComponentsItem
 CComponentsShapeSquare::CComponentsShapeSquare(	const int x_pos, const int y_pos, const int w, const int h,
 						CComponentsForm *parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	//CComponentsItem
 	cc_item_type 	= CC_ITEMTYPE_SHAPE_SQUARE;
 
-	x 		= x_pos;
-	y 		= y_pos;
-	width 		= w;
-	height	 	= h;
-	shadow		= has_shadow;
+	x 		= x_old = x_pos;
+	y 		= y_old = y_pos;
+	width 		= width_old = w;
+	height	 	= height_old = h;
+	shadow		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
 	col_body	= color_body;
@@ -65,7 +65,7 @@ void CComponentsShapeSquare::paint(bool do_save_bg)
 //sub class CComponentsShapeCircle from CComponentsItem
 CComponentsShapeCircle::CComponentsShapeCircle(	int x_pos, int y_pos, int diam,
 						CComponentsForm *parent,
-						bool has_shadow,
+						int shadow_mode,
 						fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	//CComponents, CComponentsItem
@@ -75,7 +75,7 @@ CComponentsShapeCircle::CComponentsShapeCircle(	int x_pos, int y_pos, int diam,
 	x 		= x_pos;
 	y 		= y_pos;
 	//width = height	= d = diam;
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
 	col_body	= color_body;
diff --git a/src/gui/components/cc_item_shapes.h b/src/gui/components/cc_item_shapes.h
index 7457d88..47e3ecf 100644
--- a/src/gui/components/cc_item_shapes.h
+++ b/src/gui/components/cc_item_shapes.h
@@ -31,6 +31,7 @@
 #endif
 
 #include "cc_base.h"
+#include "cc_item.h"
 
 //! Sub class of CComponentsItem. Shows a shape with given dimensions and color on screen.
 /*!
@@ -45,7 +46,7 @@ class CComponentsShapeCircle : public CComponentsItem
 	public:
 		CComponentsShapeCircle(	const int x_pos, const int y_pos, const int diam,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		///set property: diam
@@ -62,7 +63,7 @@ class CComponentsShapeSquare : public CComponentsItem
 	public:
 		CComponentsShapeSquare(	const int x_pos, const int y_pos, const int w, const int h,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
diff --git a/src/gui/components/cc_item_text.cpp b/src/gui/components/cc_item_text.cpp
index dd6bec0..bfe7a62 100644
--- a/src/gui/components/cc_item_text.cpp
+++ b/src/gui/components/cc_item_text.cpp
@@ -43,21 +43,23 @@ CComponentsText::CComponentsText(	CComponentsForm *parent,
 					std::string text,
 					const int mode,
 					Font* font_text,
-					bool has_shadow,
+					const int& font_style,
+					int shadow_mode,
 					fb_pixel_t color_text, fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
-	initVarText(x_pos, y_pos, w, h, text, mode, font_text, parent, has_shadow, color_text, color_frame, color_body, color_shadow);
+	initVarText(x_pos, y_pos, w, h, text, mode, font_text, font_style, parent, shadow_mode, color_text, color_frame, color_body, color_shadow);
 }
 
 CComponentsText::CComponentsText(	const int x_pos, const int y_pos, const int w, const int h,
 					std::string text,
 					const int mode,
 					Font* font_text,
+					const int& font_style,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_text, fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
-	initVarText(x_pos, y_pos, w, h, text, mode, font_text, parent, has_shadow, color_text, color_frame, color_body, color_shadow);
+	initVarText(x_pos, y_pos, w, h, text, mode, font_text, font_style, parent, shadow_mode, color_text, color_frame, color_body, color_shadow);
 }
 
 CComponentsText::~CComponentsText()
@@ -71,8 +73,9 @@ void CComponentsText::initVarText(	const int x_pos, const int y_pos, const int w
 					std::string text,
 					const int mode,
 					Font* font_text,
+					const int& font_style,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_text, fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	cc_item_type 	= CC_ITEMBOX_TEXT;
@@ -81,10 +84,10 @@ void CComponentsText::initVarText(	const int x_pos, const int y_pos, const int w
 	ct_text 	= text;
 	ct_old_text	= ct_text;
 	ct_text_mode	= mode;
-	ct_text_style 	= FONT_STYLE_REGULAR;
+	ct_text_style 	= font_style;
 
-	iX = x 		= x_pos;
-	iY = y 		= y_pos;
+	iX = x 		= x_old = x_pos; //TODO: equalize inhertited member names
+	iY = y 		= y_old = y_pos;
 	iWidth=width 	= w;
 	iHeight=height 	= h;
 
@@ -94,13 +97,13 @@ void CComponentsText::initVarText(	const int x_pos, const int y_pos, const int w
 	ct_text_Hborder	= 1;
 	ct_text_Vborder	= 0;
 
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	ct_col_text	= color_text;
-	ct_old_col_text = 0;
+	ct_old_col_text = ct_col_text;
 	col_frame 	= color_frame;
 	col_body 	= color_body;
 	col_shadow	= color_shadow;
-	
+	fr_thickness	= 0;
 	ct_text_sent	= false;
 	ct_paint_textbg = false;
 	ct_force_text_paint = false;
@@ -148,18 +151,19 @@ void CComponentsText::initCCText()
 	ct_textbox->setTextColor(ct_col_text);
 	ct_textbox->setWindowMaxDimensions(iWidth, iHeight);
 	ct_textbox->setWindowMinDimensions(iWidth, iHeight);
-	ct_textbox->enableSaveScreen(save_tbox_screen);
+	ct_textbox->enableSaveScreen(cc_txt_save_screen);
 	ct_textbox->enableUTF8(ct_utf8_encoded);
 
 	//observe behavior of parent form if available
 	bool force_text_paint = ct_force_text_paint;
+#if 0 //FIXME.,
 	if (cc_parent){
 		//if any embedded text item was hided because of hided parent form,
 		//we must ensure repaint of text, otherwise text item is not visible
 		if (cc_parent->isPainted())
 			force_text_paint = true;
 	}
-
+#endif
 	//send text to CTextBox object, but force text paint text if force_text_paint option is enabled
 	//this is managed by CTextBox object itself
 	ct_text_sent = ct_textbox->setText(&ct_text, this->iWidth, force_text_paint);
@@ -183,37 +187,44 @@ void CComponentsText::clearCCText()
 	ct_textbox = NULL;
 }
 
-void CComponentsText::setText(const std::string& stext, const int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
+bool CComponentsText::setText(const std::string& stext, const int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
 {
-	ct_old_text = ct_text;
-	ct_text = stext;
-	if (mode != ~CTextBox::AUTO_WIDTH)
-		ct_text_mode = mode;
-	if (font_text)
-		ct_font = font_text;
-	if (color_text != 0)
-		setTextColor(color_text);
-	if (style != FONT_STYLE_REGULAR)
-		ct_text_style = style;
-
-	dprintf(DEBUG_DEBUG, "[CComponentsText]   [%s - %d] ct_text: %s \n", __func__, __LINE__, ct_text.c_str());
+	if (ct_text != stext || ct_text_mode != mode || ct_font != font_text || ct_col_text != color_text || ct_text_style != style  ){
+		if (ct_text != stext){
+			ct_text = stext;
+			ct_old_text = ct_text;
+		}
+		if (ct_text_mode != mode /*|| mode != ~CTextBox::AUTO_WIDTH*/)
+			ct_text_mode = mode;
+		if (font_text)
+			ct_font = font_text;
+		if (color_text != 0)
+			setTextColor(color_text);
+		if (style != FONT_STYLE_REGULAR)
+			ct_text_style = style;
+
+		dprintf(DEBUG_DEBUG, "[CComponentsText]   [%s - %d] ct_text: %s \n", __func__, __LINE__, ct_text.c_str());
+		return true;
+	}
+
+	return false;
 }
 
-void CComponentsText::setText(neutrino_locale_t locale_text, int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
+bool CComponentsText::setText(neutrino_locale_t locale_text, int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
 {
 	string stext = g_Locale->getText(locale_text);
-	setText(stext, mode, font_text, color_text, style);
+	return setText(stext, mode, font_text, color_text, style);
 }
 
-void CComponentsText::setText(const char* ctext, const int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
+bool CComponentsText::setText(const char* ctext, const int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
 {
- 	setText((string)ctext, mode, font_text, color_text, style);
+	return setText((string)ctext, mode, font_text, color_text, style);
 }
 
-void CComponentsText::setText(const int digit, const int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
+bool CComponentsText::setText(const int digit, const int mode, Font* font_text, const fb_pixel_t& color_text, const int& style)
 {
 	string s_digit = iToString(digit);
-	setText(s_digit, mode, font_text, color_text, style);
+	return setText(s_digit, mode, font_text, color_text, style);
 }
 
 string CComponentsText::getTextFromFile(const string& path_to_textfile)
@@ -244,15 +255,14 @@ bool CComponentsText::setTextFromFile(const string& path_to_textfile, const int
 	if (txt.empty())
 		return false;
 	
-	setText(txt, mode, font_text, color_text, style);
-	
-	return true;
+	return setText(txt, mode, font_text, color_text, style);
 }
 
 void CComponentsText::paintText(bool do_save_bg)
 {
 	paintInit(do_save_bg);
 	initCCText();
+
 	if (ct_text_sent && cc_allow_paint)
 		ct_textbox->paint();
 	ct_text_sent = false;
@@ -263,12 +273,32 @@ void CComponentsText::paint(bool do_save_bg)
 	paintText(do_save_bg);
 }
 
-void CComponentsText::hide(bool no_restore)
+void CComponentsText::hide()
 {
 	if (ct_textbox)
 		ct_textbox->hide();
 	ct_old_text = "";
-	hideCCItem(no_restore);
+	CComponents::hide();
+}
+
+void CComponentsText::setXPos(const int& xpos)
+{
+	iX = x = xpos;
+}
+
+void CComponentsText::setYPos(const int& ypos)
+{
+	iY = y = ypos;
+}
+
+void CComponentsText::setHeight(const int& h)
+{
+	iHeight = height = h;
+}
+
+void CComponentsText::setWidth(const int& w)
+{
+	iWidth = width = w;
 }
 
 //small helper to remove excessiv linbreaks
@@ -308,7 +338,33 @@ int CComponentsText::getTextLinesAutoHeight(const int& textMaxHeight, const int&
 
 void CComponentsText::setTextColor(const fb_pixel_t& color_text)
 {
-	ct_col_text = color_text;
+	if (ct_col_text != color_text){
+		//ct_textbox->clearScreenBuffer();
+
+		ct_col_text = color_text;
+		if (ct_textbox)
+			ct_textbox->setTextColor(ct_col_text);
+	}
+}
+
+bool CComponentsText::clearSavedScreen()
+{
+	bool ret0 = CCDraw::clearSavedScreen();
+	bool ret1 = false;
+#if 0
 	if (ct_textbox)
-		ct_textbox->setTextColor(ct_col_text);
+		ret1 = ct_textbox->clearScreenBuffer();
+#endif
+	return max<bool>(ret0, ret1);
 }
+#if 0
+bool CComponentsText::enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color)
+{
+	if (CCDraw::enableColBodyGradient(enable_mode, sec_color)){
+		if (ct_textbox)
+			ct_textbox->clearScreenBuffer();
+	}
+	return false;
+}
+#endif
+
diff --git a/src/gui/components/cc_item_text.h b/src/gui/components/cc_item_text.h
index c781be0..af36d12 100644
--- a/src/gui/components/cc_item_text.h
+++ b/src/gui/components/cc_item_text.h
@@ -27,6 +27,8 @@
 #define __CC_ITEM_TEXT_H__
 
 #include "cc_base.h"
+#include "cc_item.h"
+#include "cc_text_screen.h"
 #include <gui/widget/textbox.h>
 #include <string>
 
@@ -38,7 +40,7 @@ Handling of text parts based up CTextBox attributes and methodes.
 CComponentsText provides a interface to the embedded CTextBox object.
 */
 
-class CComponentsText : public CComponentsItem, public CBox
+class CComponentsText : public CCTextScreen, public CComponentsItem, public CBox
 {
 	protected:
 		///object: CTextBox object
@@ -81,8 +83,9 @@ class CComponentsText : public CComponentsItem, public CBox
 					std::string text,
 					const int mode,
 					Font* font_text,
+					const int& font_style,
 					CComponentsForm *parent,
-					bool has_shadow,
+					int shadow_mode,
 					fb_pixel_t color_text, fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow);
 
 		///destroy current CTextBox and CBox objects
@@ -103,8 +106,9 @@ class CComponentsText : public CComponentsItem, public CBox
 					std::string text = "",
 					const int mode = CTextBox::AUTO_WIDTH,
 					Font* font_text = NULL,
+					const int& font_style = CComponentsText::FONT_STYLE_REGULAR,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_text = COL_MENUCONTENT_TEXT, fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		CComponentsText(	CComponentsForm *parent,
@@ -112,14 +116,15 @@ class CComponentsText : public CComponentsItem, public CBox
 					std::string text = "",
 					const int mode = CTextBox::AUTO_WIDTH,
 					Font* font_text = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					const int& font_style = CComponentsText::FONT_STYLE_REGULAR,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_text = COL_MENUCONTENT_TEXT, fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6, fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 
 		virtual ~CComponentsText();
 
 		///default members to paint a text box and hide painted text
 		///hide textbox
-		void hide(bool no_restore = false);
+		void hide();
 		///paint text box, parameter do_save_bg: default = true, causes fill of backckrond pixel buffer
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 
@@ -137,26 +142,33 @@ class CComponentsText : public CComponentsItem, public CBox
 		///send option to CTextBox object to paint background box behind text or not
 		virtual inline void doPaintTextBoxBg(bool do_paintbox_bg){ ct_paint_textbg = do_paintbox_bg;};
 
-		///set text as string also possible with overloades members for loacales, const char and text file
-		virtual void setText(const std::string& stext, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
-		///set text with const char*
-		virtual	void setText(const char* ctext, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
-		///set text from locale
-		virtual void setText(neutrino_locale_t locale_text, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
-		///set text from digit, digit is integer
-		virtual void setText(const int digit, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
-		///set text directly from a textfile, path as string is required
+		///set text as string also possible with overloades members for loacales, const char and text file, returns true if text was changed
+		virtual bool setText(const std::string& stext, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
+		///set text with const char*, returns true if text was changed
+		virtual	bool setText(const char* ctext, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
+		///set text from locale, returns true if text was changed
+		virtual bool setText(neutrino_locale_t locale_text, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
+		///set text from digit, digit is integer, returns true if text was changed
+		virtual bool setText(const int digit, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
+		///set text directly from a textfile, path as string is required, returns true if text was changed
 		virtual bool setTextFromFile(const std::string& path_to_textfile, const int mode = ~CTextBox::AUTO_WIDTH, Font* font_text = NULL, const fb_pixel_t& color_text = 0, const int& style = FONT_STYLE_REGULAR);
 		///get text directly from a textfile, path as string is required
 		static std::string getTextFromFile(const std::string& path_to_textfile);
 		///returns current text content of text/label object as std::string
 		virtual std::string getText(){return ct_text;};
 
+		///set screen x-position, parameter as int
+		virtual void setXPos(const int& xpos);
+		///set screen y-position, parameter as int
+		virtual void setYPos(const int& ypos);
+		///set height of component on screen
+		virtual void setHeight(const int& h);
+		///set width of component on screen
+		virtual void setWidth(const int& w);
+
 		///helper to remove linebreak chars from a string if needed
 		virtual void removeLineBreaks(std::string& str);
 
-		///returns true, if text was changed
-		virtual bool textChanged(){return ct_old_text != ct_text;};
 		///force paint of text even if text was changed or not
 		virtual void forceTextPaint(bool force_text_paint = true){ct_force_text_paint = force_text_paint;};
 
@@ -165,16 +177,46 @@ class CComponentsText : public CComponentsItem, public CBox
 
 		///returns count of lines from a text box page
 		virtual int getTextLinesAutoHeight(const int& textMaxHeight, const int& textWidth, const int& mode);
-		// overload function from cc_base CComponents
+		///allows to save bg screen behind text within CTextBox object, see also cc_txt_save_screen
 		void enableTboxSaveScreen(bool mode)
 		{
-			save_tbox_screen = mode;
+			if (cc_txt_save_screen == mode)
+				return;
+			cc_txt_save_screen = mode;
 			if (ct_textbox)
 				ct_textbox->enableSaveScreen(mode);
 		}
 		///enable/disable utf8 encoding
 		void enableUTF8(bool enable = true){ct_utf8_encoded = enable;}
 		void disableUTF8(bool enable = false){enableUTF8(enable);}
+		/*!Clean up screen buffers from background layers.
+		 * Paint cache and gradient cache not touched.
+		 * The default basic methode CCDraw::clearSavedScreen() doesn't considering text bg screen, therefore
+		 * we ensure also clean up the background of textbox object.
+		 * Returns true if any buffer was cleane
+		*/
+		virtual bool clearSavedScreen();
+// 		///set color gradient on/off, returns true if gradient mode was changed
+// 		virtual bool enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/);
+};
+
+
+//! Sub class of CComponentsText. Shows text with transparent background
+class CComponentsTextTransp : public CComponentsText
+{
+	public:
+		CComponentsTextTransp(	CComponentsForm *parent,
+					const int x_pos = 10, const int y_pos = 10, const int w = 150, const int h = 50,
+					std::string text = "",
+					const int mode = CTextBox::AUTO_WIDTH,
+					Font* font_text = NULL,
+					const int& font_style = CComponentsText::FONT_STYLE_REGULAR,
+					fb_pixel_t color_text = COL_MENUCONTENT_TEXT)
+					:CComponentsText(x_pos, y_pos, w, h, text, mode, font_text, font_style, parent, CC_SHADOW_OFF, color_text)
+					{
+						doPaintBg(false);
+						enableTboxSaveScreen(true);
+					};
 };
 
 
@@ -193,13 +235,14 @@ class CComponentsLabel : public CComponentsText
 					std::string text = "",
 					const int mode = CTextBox::AUTO_WIDTH,
 					Font* font_text = NULL,
+					const int& font_style = CComponentsText::FONT_STYLE_REGULAR,
 					CComponentsForm *parent = NULL,
-					bool has_shadow = CC_SHADOW_OFF,
+					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_text = COL_MENUCONTENTINACTIVE_TEXT,
 					fb_pixel_t color_frame = COL_MENUCONTENT_PLUS_6,
 					fb_pixel_t color_body = COL_MENUCONTENT_PLUS_0,
 					fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0)
-					:CComponentsText(x_pos, y_pos, w, h, text, mode, font_text, parent, has_shadow, color_text, color_frame, color_body, color_shadow)
+					:CComponentsText(x_pos, y_pos, w, h, text, mode, font_text, font_style, parent, shadow_mode, color_text, color_frame, color_body, color_shadow)
 		{
 			cc_item_type 	= CC_ITEMTYPE_LABEL;
 		};
diff --git a/src/gui/components/cc_item_tvpic.cpp b/src/gui/components/cc_item_tvpic.cpp
index 24cdcf9..4d038d8 100644
--- a/src/gui/components/cc_item_tvpic.cpp
+++ b/src/gui/components/cc_item_tvpic.cpp
@@ -42,7 +42,7 @@ using namespace std;
 //sub class CComponentsPIP from CComponentsItem
 CComponentsPIP::CComponentsPIP(	const int x_pos, const int y_pos, const int percent,
 				CComponentsForm *parent,
-				bool has_shadow,
+				int shadow_mode,
 				fb_pixel_t color_frame, fb_pixel_t color_body, fb_pixel_t color_shadow)
 {
 	//CComponents, CComponentsItem
@@ -59,7 +59,7 @@ CComponentsPIP::CComponentsPIP(	const int x_pos, const int y_pos, const int perc
 	y 		= y_pos;
 	width 		= percent*screen_w/100;
 	height	 	= percent*screen_h/100;
-	shadow		= has_shadow;
+	shadow		= shadow_mode;
 	shadow_w	= SHADOW_OFFSET;
 	col_frame 	= color_frame;
 	col_body	= color_body;
@@ -73,7 +73,7 @@ CComponentsPIP::CComponentsPIP(	const int x_pos, const int y_pos, const int perc
 CComponentsPIP::~CComponentsPIP()
 {
  	hide();
- 	videoDecoder->Pig(-1, -1, -1, -1);
+//  	videoDecoder->Pig(-1, -1, -1, -1);
 }
 
 void CComponentsPIP::paint(bool do_save_bg)
@@ -111,8 +111,8 @@ void CComponentsPIP::paint(bool do_save_bg)
 }
 
 
-void CComponentsPIP::hide(bool no_restore)
+void CComponentsPIP::hide()
 {
 	videoDecoder->Pig(-1, -1, -1, -1);
-	hideCCItem(no_restore);
+	CComponents::hide();
 }
diff --git a/src/gui/components/cc_item_tvpic.h b/src/gui/components/cc_item_tvpic.h
index 280f6cb..1ffc0eb 100644
--- a/src/gui/components/cc_item_tvpic.h
+++ b/src/gui/components/cc_item_tvpic.h
@@ -31,6 +31,7 @@
 #endif
 
 #include "cc_base.h"
+#include "cc_item.h"
 #include <string>
 
 //! Sub class of CComponentsItem. Shows a mini tv box, similar to a PIP-Feature with current tv-channel.
@@ -52,7 +53,7 @@ class CComponentsPIP : public CComponentsItem
 		///constructor: initialize of position like all other items with x and y values, but dimensions in percent
 		CComponentsPIP(	const int x_pos = 0, const int y_pos = 0, const int percent = 30,
 				CComponentsForm *parent = NULL,
-				bool has_shadow = CC_SHADOW_OFF,
+				int shadow_mode = CC_SHADOW_OFF,
 				fb_pixel_t color_frame = COL_BLACK, fb_pixel_t color_body = COL_BACKGROUND_PLUS_0, fb_pixel_t color_shadow = COL_MENUCONTENTDARK_PLUS_0);
 		~CComponentsPIP();
 
@@ -66,7 +67,7 @@ class CComponentsPIP : public CComponentsItem
 		///show tv box
 		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 		///remove tv box from screen
-		void hide(bool no_restore = false);
+		void hide();
 };
 
 #endif
diff --git a/src/gui/components/cc_text_screen.h b/src/gui/components/cc_text_screen.h
new file mode 100644
index 0000000..afdbe90
--- /dev/null
+++ b/src/gui/components/cc_text_screen.h
@@ -0,0 +1,44 @@
+/*
+	Based up Neutrino-GUI - Tuxbox-Project
+	Copyright (C) 2001 by Steffen Hehn 'McClean'
+
+	Classes for generic GUI-related components.
+	Copyright (C) 2015, Thilo Graf 'dbt'
+
+	License: GPL
+
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __CC_TXT_SCREEN__
+#define __CC_TXT_SCREEN__
+
+
+//! Sub class for CTextBox using CComponent classes.
+/*!
+This class contains flags or helpers to control CTextBox screen and paint handling and mostly used by
+CComponentsText and its derivatives and should be implemented as heredity.
+At the moment used in classes with text handlers. e.g. buttons, headers, ext text ...
+*/
+class CCTextScreen
+{
+	protected:
+		///allows to save bg screen behind caption within CTextBox object, default = false
+		bool cc_txt_save_screen;
+
+	public:
+		CCTextScreen(){cc_txt_save_screen = false;};
+};
+
+#endif
diff --git a/src/gui/components/cc_timer.cpp b/src/gui/components/cc_timer.cpp
index a2d30ec..f7cbfa4 100644
--- a/src/gui/components/cc_timer.cpp
+++ b/src/gui/components/cc_timer.cpp
@@ -61,8 +61,8 @@ void* CComponentsTimer::initTimerThread(void *arg)
 	while(timer) {
 		timer->mutex.lock();
 		timer->OnTimer();
-		mySleep(timer->tm_interval);
 		timer->mutex.unlock();
+		mySleep(timer->tm_interval);
 	}
 
 	return 0;
@@ -79,36 +79,39 @@ bool CComponentsTimer::startTimer()
 	if(!tm_thread) {
 		int res = pthread_create (&tm_thread, NULL, initTimerThread, ptr) ;
 		if (res != 0){
-			dprintf(DEBUG_NORMAL,"[CComponentsTimer]    [%s]  pthread_create  %s\n", __func__, strerror(errno));
+			dprintf(DEBUG_NORMAL,"\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_create\033[0m\n", __func__, __LINE__);
 			return false;
 		}
-		dprintf(DEBUG_INFO,"[CComponentsTimer]    [%s]  timer thread [%lu] created with interval = %d\n", __func__, tm_thread, tm_interval);
+		if (res == 0){
+			dprintf(DEBUG_INFO,"\033[33m[CComponentsTimer] [%s - %d]  timer thread [%lu] created with interval = %d\033[0m\n", __func__,  __LINE__, pthread_self(), tm_interval);
+			CNeutrinoApp::getInstance()->OnBeforeRestart.connect(sl);
+		}else{
+			dprintf(DEBUG_NORMAL, "\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_create\033[0m\n", __func__, __LINE__);
+		}
 	}
-
-	//ensure kill of thread on any restart of neutrino
-	CNeutrinoApp::getInstance()->OnBeforeRestart.connect(sl);
 	return  true;
 }
 
 //stop ticking timer and kill thread, return true on succses
 bool CComponentsTimer::stopTimer()
 {
-	int thres = 0;
 	if(tm_thread) {
-		thres = pthread_cancel(tm_thread);
-		dprintf(DEBUG_INFO,"[CComponentsTimer]    [%s] waiting for timer thread terminate ...\n", __func__);
+		int thres = pthread_cancel(tm_thread);
 		if (thres != 0)
-			dprintf(DEBUG_NORMAL,"[CComponentsTimer]    [%s] pthread_cancel  %s\n", __func__, strerror(errno));
+			dprintf(DEBUG_NORMAL,"\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_cancel\033[0m\n", __func__, __LINE__);
+
 		thres = pthread_join(tm_thread, NULL);
+
 		if (thres != 0)
-			dprintf(DEBUG_NORMAL, "[CComponentsTimer]    [%s] pthread_join  %s\n", __func__, strerror(errno));
-	}
-	if (thres == 0){
-		tm_thread = 0;
-		//ensure disconnect of unused slot
-		sl.disconnect();
-		return true;
+			dprintf(DEBUG_NORMAL, "\033[33m[CComponentsTimer] [%s - %d] ERROR! pthread_join\033[0m\n", __func__, __LINE__);
+
+		if (thres == 0){
+			tm_thread = 0;
+			//ensure disconnect of unused slot
+			sl.disconnect();
+			dprintf(DEBUG_INFO,"\033[33m[CComponentsTimer]    [%s] timer thread terminated ...\033[0m\n", __func__);
+			return true;
+		}
 	}
-
 	return false;
 }
diff --git a/src/gui/components/cc_timer.h b/src/gui/components/cc_timer.h
index 5be4b25..321a0b1 100644
--- a/src/gui/components/cc_timer.h
+++ b/src/gui/components/cc_timer.h
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2013, Thilo Graf 'dbt'
+	Copyright (C) 2013-2015, Thilo Graf 'dbt'
 
 	License: GPL
 
diff --git a/src/gui/components/cc_types.h b/src/gui/components/cc_types.h
index c861309..8636ab6 100644
--- a/src/gui/components/cc_types.h
+++ b/src/gui/components/cc_types.h
@@ -38,7 +38,8 @@ class CComponentsScrollBar;
 ///cc item types
 typedef enum
 {
-	CC_ITEMTYPE_BASE,
+	CC_ITEMTYPE_GENERIC,
+	CC_ITEMTYPE_ITEM,
 	CC_ITEMTYPE_PICTURE,
 	CC_ITEMTYPE_TEXT,
 	CC_ITEMTYPE_TEXT_INFOBOX,
@@ -67,8 +68,9 @@ typedef enum
 }CC_ITEMTYPES_T;
 
 //required typedefs
-typedef struct comp_fbdata_t
+typedef struct cc_fbdata_t
 {
+	bool enabled;
 	int fbdata_type;
 	int x;
 	int y;
@@ -76,32 +78,48 @@ typedef struct comp_fbdata_t
 	int dy;
 	fb_pixel_t color;
 	int r;
+	int rtype;
 	int frame_thickness;
 	fb_pixel_t* pixbuf;
+	gradientData_t *gradient_data;
 	void * data;
-} comp_fbdata_struct_t;
+	bool is_painted;
+} cc_fbdata_struct_t;
 
-//fb data object types
+//fb data object layer types
 typedef enum
 {
 	CC_FBDATA_TYPE_BGSCREEN,
 	CC_FBDATA_TYPE_BOX,
 	CC_FBDATA_TYPE_SHADOW_BOX,
 	CC_FBDATA_TYPE_FRAME,
-	CC_FBDATA_TYPE_LINE,
 	CC_FBDATA_TYPE_BACKGROUND,
 
 	CC_FBDATA_TYPES
 }FBDATA_TYPES;
 
-typedef struct comp_screen_data_t
+//fb color gradient types
+typedef enum
+{
+	CC_COLGRAD_OFF, 		//no gradient
+	CC_COLGRAD_LIGHT_2_DARK,	//normal one color
+	CC_COLGRAD_DARK_2_LIGHT,	//changed
+	CC_COLGRAD_COL_A_2_COL_B,	//gradient from color A to color B
+	CC_COLGRAD_COL_B_2_COL_A,	//gradient from color B to color A
+	CC_COLGRAD_COL_LIGHT_DARK_LIGHT,//gradient from color A to B to A
+	CC_COLGRAD_COL_DARK_LIGHT_DARK,	//gradient from color B to A to B
+
+	CC_COLGRAD_TYPES
+}COLOR_GRADIENT_TYPES;
+
+typedef struct cc_screen_data_t
 {
 	int x;
 	int y;
 	int dx;
 	int dy;
 	fb_pixel_t* pixbuf;
-} comp_screen_data_struct_t;
+} cc_screen_data_struct_t;
 
 //combination of rc messages with related icon
 typedef struct msg_list_t
@@ -136,7 +154,7 @@ enum
 	CC_ITEMBOX_CLOCK
 };
 
-typedef struct comp_element_data_t
+typedef struct cc_element_data_t
 {
 	int		type;
 	int		align;
@@ -147,27 +165,31 @@ typedef struct comp_element_data_t
 	int		height;
 	void*		handler1;
 	void*		handler2;
-}comp_element_data_struct_t;
+}cc_element_data_struct_t;
 
-//text lebel types
-typedef struct locale_ext_txt_t
+//text label types
+typedef struct cc_locale_ext_txt_t
 {
 	neutrino_locale_t label_text;
 	neutrino_locale_t text;
 	Font* font;
-} locale_ext_txt_struct_t;
+} cc_locale_ext_txt_struct_t;
 
-typedef struct string_ext_txt_t
+typedef struct cc_string_ext_txt_t
 {
 	std::string label_text;
 	std::string text;
 	Font* font;
-} string_ext_txt_struct_t;
+} cc_string_ext_txt_struct_t;
 
 #define CC_WIDTH_MIN		16
 #define CC_HEIGHT_MIN		16
-#define CC_SHADOW_ON 		true
-#define CC_SHADOW_OFF 		false
+
+#define CC_SHADOW_OFF 		0
+#define CC_SHADOW_ON 		1
+#define CC_SHADOW_RIGHT 	2
+#define CC_SHADOW_BOTTOM 	4
+
 #define CC_SAVE_SCREEN_YES 	true
 #define CC_SAVE_SCREEN_NO 	false
 
diff --git a/src/gui/infoclock.cpp b/src/gui/infoclock.cpp
index be6cb15..b41da69 100644
--- a/src/gui/infoclock.cpp
+++ b/src/gui/infoclock.cpp
@@ -4,7 +4,7 @@
 
 	Info Clock Window
 	based up CComponentsFrmClock
-	Copyright (C) 2013, Thilo Graf 'dbt'
+	Copyright (C) 2013-2015, Thilo Graf 'dbt'
 	Copyright (C) 2013, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -36,9 +36,9 @@
 
 
 
-CInfoClock::CInfoClock():CComponentsFrmClock( 0, 0, 0, 50, "%H:%M:%S", true, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
+CInfoClock::CInfoClock():CComponentsFrmClock( 1, 1, NULL, "%H:%M:%S", NULL, false, 1, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
 {
-	initVarInfoClock();
+	initCCLockItems();
 }
 
 CInfoClock* CInfoClock::getInstance()
@@ -49,68 +49,62 @@ CInfoClock* CInfoClock::getInstance()
 	return InfoClock;
 }
 
-void CInfoClock::initVarInfoClock()
-{
-	Init();
-}
-
-void CInfoClock::Init()
+void CInfoClock::initCCLockItems()
 {
-	static int oldSize = 0;
-	if (oldSize != g_settings.infoClockFontSize) {
-		oldSize = g_settings.infoClockFontSize;
-		setClockFontSize(g_settings.infoClockFontSize);
-	}
+	paint_bg = g_settings.infoClockBackground;
 
 	//use current theme colors
-	syncSysColors();
+	setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENT_PLUS_0, COL_MENUCONTENTDARK_PLUS_0);
 
 	//set text color
-	if (g_settings.infoClockBackground)
-		setTextColor(COL_MENUCONTENT_TEXT);
-	else
-		setTextColor(COL_INFOCLOCK_TEXT);
-
-	paint_bg = true;
-	if (g_settings.infoClockBackground)
+	if (paint_bg){
+		cl_col_text = COL_MENUCONTENT_TEXT;
 		setColorBody(COL_MENUCONTENT_PLUS_0);
-	else
+	}else{
+		cl_col_text = COL_INFOCLOCK_TEXT;
 		setColorBody(COL_BACKGROUND_PLUS_0);
-
-	setShadowOnOff(g_settings.infoClockBackground);
+	}
 
 	if (g_settings.infoClockSeconds)
 		setClockFormat("%H:%M:%S");
-	else {
-		setClockFormat("%H:%M");
-		setClockBlink("%H %M");
+	else
+		setClockFormat("%H:%M", "%H %M");
+
+	//set height, NOTE: height is strictly bound to settings
+	if (g_settings.infoClockFontSize != height){
+		height = g_settings.infoClockFontSize;
+		int dx = 0;
+		int dy = height;
+		setClockFont(*CNeutrinoFonts::getInstance()->getDynFont(dx, dy, cl_format_str, cl_font_style));
 	}
 
-	int x_old = x, y_old = y, width_old = width, height_old = height;
-	CVolumeHelper::getInstance()->refresh(cl_font);
-	CVolumeHelper::getInstance()->getInfoClockDimensions(&x, &y, &width, &height);
-	if ((x_old != x) || (y_old != y) || (width_old != width) || (height_old != height))
-		clear();
-
 	// set corner radius depending on clock height
 	corner_rad = (g_settings.rounded_corners) ? std::max(height/10, CORNER_RADIUS_SMALL) : 0;
 
-	initCCLockItems();
+	CComponentsFrmClock::initCCLockItems();
+	CVolumeHelper::getInstance()->refresh(cl_font);
+	CVolumeHelper::getInstance()->getInfoClockDimensions(&x, &y, &width, &height);
 }
 
 void CInfoClock::ClearDisplay()
 {
-	kill();
-	Init();
+	bool run = isRun();
+	this->kill();
+	clearSavedScreen();
+	initCCLockItems();
+	//provokes full repaint for next activation, otherwise clock segments only repaints on changed content
+	clear();
+	if (run)
+		Start();
 }
 
-bool CInfoClock::StartClock()
+bool CInfoClock::StartInfoClock()
 {
-	Init();
+	initCCLockItems();
 	return Start();
 }
 
-bool CInfoClock::StopClock()
+bool CInfoClock::StopInfoClock()
 {
 	bool ret = Stop();
 	kill();
@@ -123,13 +117,22 @@ bool CInfoClock::enableInfoClock(bool enable)
 	bool ret = false;
 	if (g_settings.mode_clock) {
 		if (enable) {
-			if (!paintClock)
-				ret = StartClock();
+			if (isBlocked()) //blocked
+				ret = StartInfoClock();
 		}
 		else {
-			if (paintClock)
-				ret = StopClock();
+			if (!isBlocked()) //unblocked
+				ret = StopInfoClock();
 		}
 	}
 	return ret;
 }
+
+//switching clock on or off depends of current displayed or not
+void CInfoClock::switchClockOnOff()
+{
+	if(g_settings.mode_clock)
+		g_settings.mode_clock = false;
+	else
+		g_settings.mode_clock = true;
+}
diff --git a/src/gui/infoclock.h b/src/gui/infoclock.h
index 5fb6f31..e8d48c5 100644
--- a/src/gui/infoclock.h
+++ b/src/gui/infoclock.h
@@ -4,7 +4,7 @@
 
 	Info Clock Window
 	based up CComponentsFrmClock
-	Copyright (C) 2013, Thilo Graf 'dbt'
+	Copyright (C) 2013-2015, Thilo Graf 'dbt'
 	Copyright (C) 2013, Michael Liebmann 'micha-bbg'
 
 	License: GPL
@@ -34,21 +34,21 @@
 
 class CInfoClock : public CComponentsFrmClock
 {
-	protected:
-		void initVarInfoClock();
 	private:
-		void		Init();
+		void		initCCLockItems();
 	public:
 		CInfoClock();
 	// 	~CInfoClock(); // inherited from CComponentsFrmClock
 		static		CInfoClock* getInstance();
 
-		bool 		StartClock();
-		bool 		StopClock();
-		bool		enableInfoClock(bool enable);
+		bool 		StartInfoClock();
+		bool 		StopInfoClock();
+		bool		enableInfoClock(bool enable = true);
+		bool		disableInfoClock() {return enableInfoClock(false);}
 		void		ClearDisplay();
+		void 		setHeight(const int){}//NOTE: dummy member, height is strictly bound to settings
 
-		bool		getStatus(void) { return paintClock; }
+		static void	switchClockOnOff();
 };
 
 #endif
diff --git a/src/gui/streaminfo2.cpp b/src/gui/streaminfo2.cpp
index 150aa81..e52694e 100644
--- a/src/gui/streaminfo2.cpp
+++ b/src/gui/streaminfo2.cpp
@@ -264,7 +264,7 @@ int CStreamInfo2::doSignalStrengthLoop ()
 
 void CStreamInfo2::hide ()
 {
-	pip->hide(true);
+	pip->hide();
 	frameBuffer->paintBackgroundBoxRel (0, 0, max_width, max_height);
 }
 
diff --git a/src/gui/test_menu.cpp b/src/gui/test_menu.cpp
index 109155f..4cce0bb 100644
--- a/src/gui/test_menu.cpp
+++ b/src/gui/test_menu.cpp
@@ -495,9 +495,12 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 			header->addContextButton(NEUTRINO_ICON_BUTTON_RED);
 			header->addContextButton(CComponentsHeader::CC_BTN_HELP | CComponentsHeader::CC_BTN_EXIT | CComponentsHeader::CC_BTN_MENU);
 		}
-		else	//For existing instances it's recommended to remove old button icons before add new buttons,
+		else{	//For existing instances it's recommended to remove old button icons before add new buttons,
 			//otherwise icons will be appended to already existant icons, alternatively use the setContextButton() methode
  			header->removeContextButtons();
+			//enable clock in header with default format
+			header->enableClock(true, "%H:%M", "%H %M", true);
+		}
 
 //		example to manipulate header items
 // 		header->setFrameThickness(5);
@@ -534,10 +537,13 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 // 		header->insertCCItem(1, logo); //replace text with logo
 
 		
-		if (!header->isPainted())
+		if (!header->isPainted()){
 			header->paint();
-		else
+		}
+		else{
 			header->hide();
+		}
+
 		return res;
 	}
 	else if (actionKey == "footer"){
@@ -629,7 +635,7 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 			window->setWindowCaption("|.....................|");
 			window->setDimensionsAll(50, 50, 500, 500);
 			window->setWindowIcon(NEUTRINO_ICON_INFO);
-			window->setShadowOnOff(true);
+			window->enableShadow();
 
 			CComponentsShapeCircle *c10 = new CComponentsShapeCircle(0, 0, 28);
 			CComponentsShapeCircle *c11 = new CComponentsShapeCircle(0, CC_APPEND, 28);
@@ -672,8 +678,8 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 	}
 	else if (actionKey == "running_clock"){	
 		if (clock_r == NULL){
-			clock_r = new CComponentsFrmClock(100, 50, 0, 50, "%H.%M:%S", true);
-			clock_r->setClockFont(SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME);
+			clock_r = new CComponentsFrmClock(100, 50, NULL, "%H.%M:%S", NULL, true);
+			clock_r->setClockFont(g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME]);
 			clock_r->setClockIntervall(1);
 // 			clock_r->doPaintBg(false);
 		}
@@ -684,7 +690,7 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 		}
 		else {
 			if (clock_r->Stop()){
-				clock_r->hide();
+				clock_r->kill();
 				delete clock_r;
 				clock_r = NULL;
 				return menu_return::RETURN_EXIT_ALL;
@@ -693,8 +699,8 @@ int CTestMenu::exec(CMenuTarget* parent, const std::string &actionKey)
 	}
 	else if (actionKey == "clock"){
 		if (clock == NULL){
-			clock = new CComponentsFrmClock(100, 50, 0, 50, "%H:%M", false);
-			clock->setClockFont(SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME);
+			clock = new CComponentsFrmClock(100, 50, NULL, "%d.%m.%Y-%H:%M");
+			clock->setClockFont(g_Font[SNeutrinoSettings::FONT_TYPE_INFOBAR_CHANNAME]);
 		}
 
 		if (!clock->isPainted())
diff --git a/src/gui/timeosd.cpp b/src/gui/timeosd.cpp
index 57f136e..621eef0 100644
--- a/src/gui/timeosd.cpp
+++ b/src/gui/timeosd.cpp
@@ -36,41 +36,46 @@
 
 
 
-CTimeOSD::CTimeOSD():CComponentsFrmClock( 0, 0, 0, 50, "%H:%M:%S", false, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
+CTimeOSD::CTimeOSD():CComponentsFrmClock( 1, 1, NULL, "%H:%M:%S", NULL, false, 1, NULL, CC_SHADOW_ON, COL_LIGHT_GRAY, COL_MENUCONTENT_PLUS_0,COL_MENUCONTENTDARK_PLUS_0)
 {
 	Init();
 }
 
 void CTimeOSD::Init()
 {
-	static int oldSize = 0;
-
-	m_mode = MODE_HIDE;
-	m_time_show = 0;
-
-	if (oldSize != g_settings.infoClockFontSize) {
-		oldSize = g_settings.infoClockFontSize;
-		setClockFontSize(g_settings.infoClockFontSize);
-	}
+	paint_bg = g_settings.infoClockBackground;
 
 	//use current theme colors
-	syncSysColors();
+	setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENT_PLUS_0, COL_MENUCONTENTDARK_PLUS_0);
 
-	paint_bg = g_settings.infoClockBackground;
-
-	setClockFormat("%H:%M:%S");
+	//set text color
+	if (paint_bg){
+		cl_col_text = COL_MENUCONTENT_TEXT;
+		setColorBody(COL_MENUCONTENT_PLUS_0);
+	}else{
+		cl_col_text = COL_INFOCLOCK_TEXT;
+		setColorBody(COL_BACKGROUND_PLUS_0);
+	}
 
-	int x_old = x, y_old = y, width_old = width, height_old = height;
-	CVolumeHelper::getInstance()->refresh(cl_font);
-	CVolumeHelper::getInstance()->getTimeDimensions(&x, &y, &width, &height);
-	if ((x_old != x) || (y_old != y) || (width_old != width) || (height_old != height))
-		clear();
+	if (g_settings.infoClockSeconds)
+		setClockFormat("%H:%M:%S");
+	else
+		setClockFormat("%H:%M", "%H %M");
+
+	//set height, NOTE: height is strictly bound to settings
+	if (g_settings.infoClockFontSize != height){
+		height = g_settings.infoClockFontSize;
+		int dx = 0;
+		int dy = height;
+		setClockFont(*CNeutrinoFonts::getInstance()->getDynFont(dx, dy, cl_format_str, cl_font_style));
+	}
 
 	// set corner radius depending on clock height
 	corner_rad = (g_settings.rounded_corners) ? std::max(height/10, CORNER_RADIUS_SMALL) : 0;
 
-	initCCLockItems();
-
+	CComponentsFrmClock::initCCLockItems();
+	CVolumeHelper::getInstance()->refresh(cl_font);
+	CVolumeHelper::getInstance()->getTimeDimensions(&x, &y, &width, &height);
 	timescale.setType(CProgressBar::PB_TIMESCALE);
 }
 
@@ -85,13 +90,10 @@ CTimeOSD::~CTimeOSD()
 void CTimeOSD::initTimeString()
 {
 	struct tm t;
-	if (m_mode == MODE_DESC) {
-		char tt[20];
-		strftime(tt, sizeof(tt), cl_format_str, gmtime_r(&m_time_show, &t));
-		snprintf(cl_timestr, sizeof(cl_timestr), "-%s", tt);
-	}
-	else
-		strftime(cl_timestr, sizeof(cl_timestr), cl_format_str, gmtime_r(&m_time_show, &t));
+	toggleFormat();
+	if (m_mode == MODE_DESC)
+		cl_format = "-" + cl_format;
+	strftime((char*) &cl_timestr, sizeof(cl_timestr), cl_format.c_str(), gmtime_r(&m_time_show, &t));
 }
 
 void CTimeOSD::show(time_t time_show, bool force)
@@ -101,7 +103,7 @@ void CTimeOSD::show(time_t time_show, bool force)
 		return;
 	m_time_show = time_show;
 
-	syncSysColors();
+	setColorAll(COL_MENUCONTENT_PLUS_6, COL_MENUCONTENT_PLUS_0, COL_MENUCONTENTDARK_PLUS_0); //use current theme colors
 
 	paint_bg = true;
 	if (g_settings.infoClockBackground)
@@ -109,7 +111,7 @@ void CTimeOSD::show(time_t time_show, bool force)
 	else
 		setColorBody(COL_BACKGROUND_PLUS_0);
 
-	setShadowOnOff(g_settings.infoClockBackground);
+	enableShadow(g_settings.infoClockBackground);
 
 	paint(false);
 }
@@ -124,7 +126,6 @@ void CTimeOSD::updatePos(int position, int duration)
 
 	timescale.setProgress(x, y + height/4, width, height/2, percent, 100);
 	timescale.paint();
-	frameBuffer->blit();
 }
 
 void CTimeOSD::update(int position, int duration)
@@ -157,7 +158,6 @@ void CTimeOSD::switchMode(int position, int duration)
 			break;
 		case MODE_BAR:
 			KillAndResetTimescale();
-			frameBuffer->blit();
 			return;
 		default:
 			m_mode = MODE_ASC;
diff --git a/src/gui/timerlist.cpp b/src/gui/timerlist.cpp
index b655292..9064241 100644
--- a/src/gui/timerlist.cpp
+++ b/src/gui/timerlist.cpp
@@ -870,8 +870,8 @@ void CTimerList::paintItem(int pos)
 
 void CTimerList::paintHead()
 {
-	CComponentsHeaderLocalized header(x, y, width, theight, LOCALE_TIMERLIST_NAME, NEUTRINO_ICON_TIMER);
-	header.setShadowOnOff(CC_SHADOW_ON);
+	CComponentsHeaderLocalized header(x, y, width, theight, LOCALE_TIMERLIST_NAME, NEUTRINO_ICON_TIMER, CComponentsHeader::CC_BTN_EXIT, NULL, CC_SHADOW_ON);
+	header.enableClock(true, "%d.%m.%Y %H:%M");
 	header.paint(CC_SAVE_SCREEN_NO);
 }
 
diff --git a/src/gui/volumebar.cpp b/src/gui/volumebar.cpp
index 66e6a58..dad43be 100644
--- a/src/gui/volumebar.cpp
+++ b/src/gui/volumebar.cpp
@@ -248,13 +248,6 @@ void CVolumeBar::paintVolScale()
 }
 
 
-//final paint
-void CVolumeBar::paint(bool do_save_bg)
-{
-	//paint form
-	paintForm(do_save_bg);
-}
-
 
 // CVolumeHelper ####################################################################################################
 
@@ -270,7 +263,7 @@ CVolumeHelper::CVolumeHelper()
 	Init();
 }
 
-void CVolumeHelper::Init(Font** font)
+void CVolumeHelper::Init(Font* font)
 {
 
 	x  = frameBuffer->getScreenX() + h_spacer;
@@ -283,11 +276,11 @@ void CVolumeHelper::Init(Font** font)
 	initInfoClock(font);
 }
 
-void CVolumeHelper::initInfoClock(Font** font)
+void CVolumeHelper::initInfoClock(Font* font)
 {
 	if (clock_font == NULL){
 		if (font == NULL) {
-			clock_font = &g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE];
+			clock_font = g_Font[SNeutrinoSettings::FONT_TYPE_MENU_TITLE];
 		}
 		else
 			clock_font = font;
@@ -296,10 +289,10 @@ void CVolumeHelper::initInfoClock(Font** font)
 		if (font != NULL)
 			clock_font = font;
 	}
-	digit_offset = (*clock_font)->getDigitOffset();
-	digit_h      = (*clock_font)->getDigitHeight();
-	int t1       = (*clock_font)->getMaxDigitWidth();
-	int t2       = (*clock_font)->getRenderWidth(":");
+	digit_offset = (clock_font)->getDigitOffset();
+	digit_h      = (clock_font)->getDigitHeight();
+	int t1       = (clock_font)->getMaxDigitWidth();
+	int t2       = (clock_font)->getRenderWidth(":");
 	clock_dy     = digit_h + (int)((float)digit_offset * 1.3);
 	if (g_settings.infoClockSeconds)
 		clock_dx     = t1*7 + t2*2;
@@ -365,7 +358,7 @@ int CVolumeHelper::getInfoClockX()
 		return clock_ax;
 }
 
-void CVolumeHelper::refresh(Font** font)
+void CVolumeHelper::refresh(Font* font)
 {
 	Init(font);
 }
diff --git a/src/gui/volumebar.h b/src/gui/volumebar.h
index 2ec76dd..02d8a37 100644
--- a/src/gui/volumebar.h
+++ b/src/gui/volumebar.h
@@ -92,7 +92,6 @@ class CVolumeBar : public CComponentsForm
 // 		~CVolumeBar(); inherited from CComponentsForm
 
 		void repaintVolScale();
-		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 };
 
 
@@ -106,13 +105,13 @@ class CVolumeHelper
 		int icon_width, icon_height, digit_width;
 		int h_spacer, v_spacer;
 		int vol_ay, vol_height;
-		Font** clock_font;
+		Font* clock_font;
 		CFrameBuffer *frameBuffer;
 
-		void Init(Font** font=NULL);
+		void Init(Font* font=NULL);
 		void initVolBarSize();
 		void initMuteIcon();
-		void initInfoClock(Font** font);
+		void initInfoClock(Font* font);
 
 	public:
 
@@ -130,7 +129,7 @@ class CVolumeHelper
 		void getTimeDimensions(int *_x, int *_y, int *w, int *h) { *_x = time_ax; *_y = clock_ay; *w = time_dx; *h = clock_dy; }
 		void getVolBarDimensions(int *_y, int *_dy) { *_y = vol_ay; *_dy = vol_height; }
 		void setMuteIconCorrY(int corr) { mute_corrY = corr; }
-		void refresh(Font** font=NULL);
+		void refresh(Font* font=NULL);
 };
 
 #endif
diff --git a/src/gui/widget/progresswindow.cpp b/src/gui/widget/progresswindow.cpp
index 7842451..8e992cf 100644
--- a/src/gui/widget/progresswindow.cpp
+++ b/src/gui/widget/progresswindow.cpp
@@ -33,7 +33,7 @@
 #include <driver/display.h>
 
 CProgressWindow::CProgressWindow(CComponentsForm *parent) 
-: CComponentsWindow(0, 0, 700, 200, string(), NEUTRINO_ICON_INFO, NULL, parent)
+: CComponentsWindow(0, 0, 700, 200, string(), NEUTRINO_ICON_INFO, parent, CC_SHADOW_ON)
 {
 	Init();
 }
@@ -186,9 +186,9 @@ unsigned int CProgressWindow::getGlobalStatus(void)
 	return global_progress;
 }
 
-void CProgressWindow::hide(bool no_restore)
+void CProgressWindow::hide()
 {
-	CComponentsWindow::hide(no_restore);
+	CComponentsWindow::hide();
 }
 
 int CProgressWindow::exec(CMenuTarget* parent, const std::string & /*actionKey*/)
diff --git a/src/gui/widget/progresswindow.h b/src/gui/widget/progresswindow.h
index 44350a9..6b8ff9e 100644
--- a/src/gui/widget/progresswindow.h
+++ b/src/gui/widget/progresswindow.h
@@ -45,7 +45,7 @@ class CProgressWindow : public CComponentsWindow, public CMenuTarget
 
 		CProgressWindow(CComponentsForm *parent = NULL);
 		void setTitle(const neutrino_locale_t title);
-		virtual void hide(bool no_restore = false);
+		virtual void hide();
 
 		virtual int exec( CMenuTarget* parent, const std::string & actionKey );
 
diff --git a/src/system/debug.h b/src/system/debug.h
index 62ea607..40cba38 100644
--- a/src/system/debug.h
+++ b/src/system/debug.h
@@ -24,7 +24,7 @@
 
 #ifndef __neutrino_debug__
 #define __neutrino_debug__
-
+#include <zapit/debug.h>
 extern int debug;
 
 enum
-- 
2.1.4

